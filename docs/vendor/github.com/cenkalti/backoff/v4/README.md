<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# backoff

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/cenkalti/backoff/v4"
```

Package backoff implements backoff algorithms for retrying operations.

Use Retry function for retrying operations that may fail. If Retry does not meet your needs, copy/paste the function into your project and modify as you wish.

There is also Ticker type similar to time.Ticker. You can use it if you need to work with channels.

See Examples section below for usage examples.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Permanent(err error) error](<#func-permanent>)
- [func Retry(o Operation, b BackOff) error](<#func-retry>)
- [func RetryNotify(operation Operation, b BackOff, notify Notify) error](<#func-retrynotify>)
- [func RetryNotifyWithData[T any](operation OperationWithData[T], b BackOff, notify Notify) (T, error)](<#func-retrynotifywithdata>)
- [func RetryNotifyWithTimer(operation Operation, b BackOff, notify Notify, t Timer) error](<#func-retrynotifywithtimer>)
- [func RetryNotifyWithTimerAndData[T any](operation OperationWithData[T], b BackOff, notify Notify, t Timer) (T, error)](<#func-retrynotifywithtimeranddata>)
- [func RetryWithData[T any](o OperationWithData[T], b BackOff) (T, error)](<#func-retrywithdata>)
- [type BackOff](<#type-backoff>)
  - [func WithMaxRetries(b BackOff, max uint64) BackOff](<#func-withmaxretries>)
- [type BackOffContext](<#type-backoffcontext>)
  - [func WithContext(b BackOff, ctx context.Context) BackOffContext](<#func-withcontext>)
- [type Clock](<#type-clock>)
- [type ConstantBackOff](<#type-constantbackoff>)
  - [func NewConstantBackOff(d time.Duration) *ConstantBackOff](<#func-newconstantbackoff>)
  - [func (b *ConstantBackOff) NextBackOff() time.Duration](<#func-constantbackoff-nextbackoff>)
  - [func (b *ConstantBackOff) Reset()](<#func-constantbackoff-reset>)
- [type ExponentialBackOff](<#type-exponentialbackoff>)
  - [func NewExponentialBackOff() *ExponentialBackOff](<#func-newexponentialbackoff>)
  - [func (b *ExponentialBackOff) GetElapsedTime() time.Duration](<#func-exponentialbackoff-getelapsedtime>)
  - [func (b *ExponentialBackOff) NextBackOff() time.Duration](<#func-exponentialbackoff-nextbackoff>)
  - [func (b *ExponentialBackOff) Reset()](<#func-exponentialbackoff-reset>)
- [type Notify](<#type-notify>)
- [type Operation](<#type-operation>)
- [type OperationWithData](<#type-operationwithdata>)
- [type PermanentError](<#type-permanenterror>)
  - [func (e *PermanentError) Error() string](<#func-permanenterror-error>)
  - [func (e *PermanentError) Is(target error) bool](<#func-permanenterror-is>)
  - [func (e *PermanentError) Unwrap() error](<#func-permanenterror-unwrap>)
- [type StopBackOff](<#type-stopbackoff>)
  - [func (b *StopBackOff) NextBackOff() time.Duration](<#func-stopbackoff-nextbackoff>)
  - [func (b *StopBackOff) Reset()](<#func-stopbackoff-reset>)
- [type Ticker](<#type-ticker>)
  - [func NewTicker(b BackOff) *Ticker](<#func-newticker>)
  - [func NewTickerWithTimer(b BackOff, timer Timer) *Ticker](<#func-newtickerwithtimer>)
  - [func (t *Ticker) Stop()](<#func-ticker-stop>)
- [type Timer](<#type-timer>)
- [type ZeroBackOff](<#type-zerobackoff>)
  - [func (b *ZeroBackOff) NextBackOff() time.Duration](<#func-zerobackoff-nextbackoff>)
  - [func (b *ZeroBackOff) Reset()](<#func-zerobackoff-reset>)


## Constants

Default values for ExponentialBackOff.

```go
const (
    DefaultInitialInterval     = 500 * time.Millisecond
    DefaultRandomizationFactor = 0.5
    DefaultMultiplier          = 1.5
    DefaultMaxInterval         = 60 * time.Second
    DefaultMaxElapsedTime      = 15 * time.Minute
)
```

Stop indicates that no more retries should be made for use in NextBackOff\(\).

```go
const Stop time.Duration = -1
```

## Variables

SystemClock implements Clock interface that uses time.Now\(\).

```go
var SystemClock = systemClock{}
```

## func Permanent

```go
func Permanent(err error) error
```

Permanent wraps the given err in a \*PermanentError.

## func Retry

```go
func Retry(o Operation, b BackOff) error
```

Retry the operation o until it does not return error or BackOff stops. o is guaranteed to be run at least once.

If o returns a \*PermanentError, the operation is not retried, and the wrapped error is returned.

Retry sleeps the goroutine for the duration returned by BackOff after a failed operation returns.

## func RetryNotify

```go
func RetryNotify(operation Operation, b BackOff, notify Notify) error
```

RetryNotify calls notify function with the error and wait duration for each failed attempt before sleep.

## func RetryNotifyWithData

```go
func RetryNotifyWithData[T any](operation OperationWithData[T], b BackOff, notify Notify) (T, error)
```

RetryNotifyWithData is like RetryNotify but returns data in the response too.

## func RetryNotifyWithTimer

```go
func RetryNotifyWithTimer(operation Operation, b BackOff, notify Notify, t Timer) error
```

RetryNotifyWithTimer calls notify function with the error and wait duration using the given Timer for each failed attempt before sleep. A default timer that uses system timer is used when nil is passed.

## func RetryNotifyWithTimerAndData

```go
func RetryNotifyWithTimerAndData[T any](operation OperationWithData[T], b BackOff, notify Notify, t Timer) (T, error)
```

RetryNotifyWithTimerAndData is like RetryNotifyWithTimer but returns data in the response too.

## func RetryWithData

```go
func RetryWithData[T any](o OperationWithData[T], b BackOff) (T, error)
```

RetryWithData is like Retry but returns data in the response too.

## type BackOff

BackOff is a backoff policy for retrying an operation.

```go
type BackOff interface {
    // NextBackOff returns the duration to wait before retrying the operation,
    // or backoff. Stop to indicate that no more retries should be made.
    //
    // Example usage:
    //
    // 	duration := backoff.NextBackOff();
    // 	if (duration == backoff.Stop) {
    // 		// Do not retry operation.
    // 	} else {
    // 		// Sleep for duration and retry operation.
    // 	}
    //
    NextBackOff() time.Duration

    // Reset to initial state.
    Reset()
}
```

### func WithMaxRetries

```go
func WithMaxRetries(b BackOff, max uint64) BackOff
```

WithMaxRetries creates a wrapper around another BackOff, which will return Stop if NextBackOff\(\) has been called too many times since the last time Reset\(\) was called

Note: Implementation is not thread\-safe.

## type BackOffContext

BackOffContext is a backoff policy that stops retrying after the context is canceled.

```go
type BackOffContext interface {
    BackOff
    Context() context.Context
}
```

### func WithContext

```go
func WithContext(b BackOff, ctx context.Context) BackOffContext
```

#### WithContext returns a BackOffContext with context ctx

ctx must not be nil

## type Clock

Clock is an interface that returns current time for BackOff.

```go
type Clock interface {
    Now() time.Time
}
```

## type ConstantBackOff

ConstantBackOff is a backoff policy that always returns the same backoff delay. This is in contrast to an exponential backoff policy, which returns a delay that grows longer as you call NextBackOff\(\) over and over again.

```go
type ConstantBackOff struct {
    Interval time.Duration
}
```

### func NewConstantBackOff

```go
func NewConstantBackOff(d time.Duration) *ConstantBackOff
```

### func \(\*ConstantBackOff\) NextBackOff

```go
func (b *ConstantBackOff) NextBackOff() time.Duration
```

### func \(\*ConstantBackOff\) Reset

```go
func (b *ConstantBackOff) Reset()
```

## type ExponentialBackOff

ExponentialBackOff is a backoff implementation that increases the backoff period for each retry attempt using a randomization function that grows exponentially.

NextBackOff\(\) is calculated using the following formula:

randomized interval = RetryInterval \* \(random value in range \[1 \- RandomizationFactor, 1 \+ RandomizationFactor\]\)

In other words NextBackOff\(\) will range between the randomization factor percentage below and above the retry interval.

For example, given the following parameters:

RetryInterval = 2 RandomizationFactor = 0.5 Multiplier = 2

the actual backoff period used in the next retry attempt will range between 1 and 3 seconds, multiplied by the exponential, that is, between 2 and 6 seconds.

Note: MaxInterval caps the RetryInterval and not the randomized interval.

If the time elapsed since an ExponentialBackOff instance is created goes past the MaxElapsedTime, then the method NextBackOff\(\) starts returning backoff.Stop.

The elapsed time can be reset by calling Reset\(\).

Example: Given the following default arguments, for 10 tries the sequence will be, and assuming we go over the MaxElapsedTime on the 10th try:

Request \#  RetryInterval \(seconds\)  Randomized Interval \(seconds\)

```
1          0.5                     [0.25,   0.75]
2          0.75                    [0.375,  1.125]
3          1.125                   [0.562,  1.687]
4          1.687                   [0.8435, 2.53]
5          2.53                    [1.265,  3.795]
6          3.795                   [1.897,  5.692]
7          5.692                   [2.846,  8.538]
8          8.538                   [4.269, 12.807]
9         12.807                   [6.403, 19.210]
```

10         19.210                   backoff.Stop

Note: Implementation is not thread\-safe.

```go
type ExponentialBackOff struct {
    InitialInterval     time.Duration
    RandomizationFactor float64
    Multiplier          float64
    MaxInterval         time.Duration
    // After MaxElapsedTime the ExponentialBackOff returns Stop.
    // It never stops if MaxElapsedTime == 0.
    MaxElapsedTime time.Duration
    Stop           time.Duration
    Clock          Clock
    // contains filtered or unexported fields
}
```

### func NewExponentialBackOff

```go
func NewExponentialBackOff() *ExponentialBackOff
```

NewExponentialBackOff creates an instance of ExponentialBackOff using default values.

### func \(\*ExponentialBackOff\) GetElapsedTime

```go
func (b *ExponentialBackOff) GetElapsedTime() time.Duration
```

GetElapsedTime returns the elapsed time since an ExponentialBackOff instance is created and is reset when Reset\(\) is called.

The elapsed time is computed using time.Now\(\).UnixNano\(\). It is safe to call even while the backoff policy is used by a running ticker.

### func \(\*ExponentialBackOff\) NextBackOff

```go
func (b *ExponentialBackOff) NextBackOff() time.Duration
```

NextBackOff calculates the next backoff interval using the formula: Randomized interval = RetryInterval \* \(1 ± RandomizationFactor\)

### func \(\*ExponentialBackOff\) Reset

```go
func (b *ExponentialBackOff) Reset()
```

Reset the interval back to the initial retry interval and restarts the timer. Reset must be called before using b.

## type Notify

Notify is a notify\-on\-error function. It receives an operation error and backoff delay if the operation failed \(with an error\).

NOTE that if the backoff policy stated to stop retrying, the notify function isn't called.

```go
type Notify func(error, time.Duration)
```

## type Operation

An Operation is executing by Retry\(\) or RetryNotify\(\). The operation will be retried using a backoff policy if it returns an error.

```go
type Operation func() error
```

## type OperationWithData

An OperationWithData is executing by RetryWithData\(\) or RetryNotifyWithData\(\). The operation will be retried using a backoff policy if it returns an error.

```go
type OperationWithData[T any] func() (T, error)
```

## type PermanentError

PermanentError signals that the operation should not be retried.

```go
type PermanentError struct {
    Err error
}
```

### func \(\*PermanentError\) Error

```go
func (e *PermanentError) Error() string
```

### func \(\*PermanentError\) Is

```go
func (e *PermanentError) Is(target error) bool
```

### func \(\*PermanentError\) Unwrap

```go
func (e *PermanentError) Unwrap() error
```

## type StopBackOff

StopBackOff is a fixed backoff policy that always returns backoff.Stop for NextBackOff\(\), meaning that the operation should never be retried.

```go
type StopBackOff struct{}
```

### func \(\*StopBackOff\) NextBackOff

```go
func (b *StopBackOff) NextBackOff() time.Duration
```

### func \(\*StopBackOff\) Reset

```go
func (b *StopBackOff) Reset()
```

## type Ticker

Ticker holds a channel that delivers \`ticks' of a clock at times reported by a BackOff.

Ticks will continue to arrive when the previous operation is still running, so operations that take a while to fail could run in quick succession.

```go
type Ticker struct {
    C <-chan time.Time
    // contains filtered or unexported fields
}
```

### func NewTicker

```go
func NewTicker(b BackOff) *Ticker
```

NewTicker returns a new Ticker containing a channel that will send the time at times specified by the BackOff argument. Ticker is guaranteed to tick at least once.  The channel is closed when Stop method is called or BackOff stops. It is not safe to manipulate the provided backoff policy \(notably calling NextBackOff or Reset\) while the ticker is running.

### func NewTickerWithTimer

```go
func NewTickerWithTimer(b BackOff, timer Timer) *Ticker
```

NewTickerWithTimer returns a new Ticker with a custom timer. A default timer that uses system timer is used when nil is passed.

### func \(\*Ticker\) Stop

```go
func (t *Ticker) Stop()
```

Stop turns off a ticker. After Stop, no more ticks will be sent.

## type Timer

```go
type Timer interface {
    Start(duration time.Duration)
    Stop()
    C() <-chan time.Time
}
```

## type ZeroBackOff

ZeroBackOff is a fixed backoff policy whose backoff time is always zero, meaning that the operation is retried immediately without waiting, indefinitely.

```go
type ZeroBackOff struct{}
```

### func \(\*ZeroBackOff\) NextBackOff

```go
func (b *ZeroBackOff) NextBackOff() time.Duration
```

### func \(\*ZeroBackOff\) Reset

```go
func (b *ZeroBackOff) Reset()
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
