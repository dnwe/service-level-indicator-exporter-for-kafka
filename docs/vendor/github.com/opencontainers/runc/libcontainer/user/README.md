<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# user

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/opencontainers/runc/libcontainer/user"
```

## Index

- [Variables](<#variables>)
- [func GetAdditionalGroups(additionalGroups []string, group io.Reader) ([]int, error)](<#func-getadditionalgroups>)
- [func GetAdditionalGroupsPath(additionalGroups []string, groupPath string) ([]int, error)](<#func-getadditionalgroupspath>)
- [func GetGroup() (io.ReadCloser, error)](<#func-getgroup>)
- [func GetGroupPath() (string, error)](<#func-getgrouppath>)
- [func GetPasswd() (io.ReadCloser, error)](<#func-getpasswd>)
- [func GetPasswdPath() (string, error)](<#func-getpasswdpath>)
- [type ExecUser](<#type-execuser>)
  - [func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (*ExecUser, error)](<#func-getexecuser>)
  - [func GetExecUserPath(userSpec string, defaults *ExecUser, passwdPath, groupPath string) (*ExecUser, error)](<#func-getexecuserpath>)
- [type Group](<#type-group>)
  - [func CurrentGroup() (Group, error)](<#func-currentgroup>)
  - [func LookupGid(gid int) (Group, error)](<#func-lookupgid>)
  - [func LookupGroup(groupname string) (Group, error)](<#func-lookupgroup>)
  - [func ParseGroup(group io.Reader) ([]Group, error)](<#func-parsegroup>)
  - [func ParseGroupFile(path string) ([]Group, error)](<#func-parsegroupfile>)
  - [func ParseGroupFileFilter(path string, filter func(Group) bool) ([]Group, error)](<#func-parsegroupfilefilter>)
  - [func ParseGroupFilter(r io.Reader, filter func(Group) bool) ([]Group, error)](<#func-parsegroupfilter>)
- [type IDMap](<#type-idmap>)
  - [func CurrentProcessGIDMap() ([]IDMap, error)](<#func-currentprocessgidmap>)
  - [func CurrentProcessUIDMap() ([]IDMap, error)](<#func-currentprocessuidmap>)
  - [func ParseIDMap(r io.Reader) ([]IDMap, error)](<#func-parseidmap>)
  - [func ParseIDMapFile(path string) ([]IDMap, error)](<#func-parseidmapfile>)
  - [func ParseIDMapFileFilter(path string, filter func(IDMap) bool) ([]IDMap, error)](<#func-parseidmapfilefilter>)
  - [func ParseIDMapFilter(r io.Reader, filter func(IDMap) bool) ([]IDMap, error)](<#func-parseidmapfilter>)
- [type SubID](<#type-subid>)
  - [func CurrentUserSubGIDs() ([]SubID, error)](<#func-currentusersubgids>)
  - [func CurrentUserSubUIDs() ([]SubID, error)](<#func-currentusersubuids>)
  - [func ParseSubID(subid io.Reader) ([]SubID, error)](<#func-parsesubid>)
  - [func ParseSubIDFile(path string) ([]SubID, error)](<#func-parsesubidfile>)
  - [func ParseSubIDFileFilter(path string, filter func(SubID) bool) ([]SubID, error)](<#func-parsesubidfilefilter>)
  - [func ParseSubIDFilter(r io.Reader, filter func(SubID) bool) ([]SubID, error)](<#func-parsesubidfilter>)
- [type User](<#type-user>)
  - [func CurrentUser() (User, error)](<#func-currentuser>)
  - [func LookupUid(uid int) (User, error)](<#func-lookupuid>)
  - [func LookupUser(username string) (User, error)](<#func-lookupuser>)
  - [func ParsePasswd(passwd io.Reader) ([]User, error)](<#func-parsepasswd>)
  - [func ParsePasswdFile(path string) ([]User, error)](<#func-parsepasswdfile>)
  - [func ParsePasswdFileFilter(path string, filter func(User) bool) ([]User, error)](<#func-parsepasswdfilefilter>)
  - [func ParsePasswdFilter(r io.Reader, filter func(User) bool) ([]User, error)](<#func-parsepasswdfilter>)


## Variables

```go
var (
    // ErrNoPasswdEntries is returned if no matching entries were found in /etc/group.
    ErrNoPasswdEntries = errors.New("no matching entries in passwd file")
    // ErrNoGroupEntries is returned if no matching entries were found in /etc/passwd.
    ErrNoGroupEntries = errors.New("no matching entries in group file")
    // ErrRange is returned if a UID or GID is outside of the valid range.
    ErrRange = fmt.Errorf("uids and gids must be in range %d-%d", minID, maxID)
)
```

## func GetAdditionalGroups

```go
func GetAdditionalGroups(additionalGroups []string, group io.Reader) ([]int, error)
```

GetAdditionalGroups looks up a list of groups by name or group id against the given /etc/group formatted data. If a group name cannot be found, an error will be returned. If a group id cannot be found, or the given group data is nil, the id will be returned as\-is provided it is in the legal range.

## func GetAdditionalGroupsPath

```go
func GetAdditionalGroupsPath(additionalGroups []string, groupPath string) ([]int, error)
```

GetAdditionalGroupsPath is a wrapper around GetAdditionalGroups that opens the groupPath given and gives it as an argument to GetAdditionalGroups.

## func GetGroup

```go
func GetGroup() (io.ReadCloser, error)
```

## func GetGroupPath

```go
func GetGroupPath() (string, error)
```

## func GetPasswd

```go
func GetPasswd() (io.ReadCloser, error)
```

## func GetPasswdPath

```go
func GetPasswdPath() (string, error)
```

## type ExecUser

```go
type ExecUser struct {
    Uid   int
    Gid   int
    Sgids []int
    Home  string
}
```

### func GetExecUser

```go
func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (*ExecUser, error)
```

GetExecUser parses a user specification string \(using the passwd and group readers as sources for /etc/passwd and /etc/group data, respectively\). In the case of blank fields or missing data from the sources, the values in defaults is used.

GetExecUser will return an error if a user or group literal could not be found in any entry in passwd and group respectively.

Examples of valid user specifications are: \* "" \* "user" \* "uid" \* "user:group" \* "uid:gid \* "user:gid" \* "uid:group"

It should be noted that if you specify a numeric user or group id, they will not be evaluated as usernames \(only the metadata will be filled\). So attempting to parse a user with user.Name = "1337" will produce the user with a UID of 1337.

### func GetExecUserPath

```go
func GetExecUserPath(userSpec string, defaults *ExecUser, passwdPath, groupPath string) (*ExecUser, error)
```

GetExecUserPath is a wrapper for GetExecUser. It reads data from each of the given file paths and uses that data as the arguments to GetExecUser. If the files cannot be opened for any reason, the error is ignored and a nil io.Reader is passed instead.

## type Group

```go
type Group struct {
    Name string
    Pass string
    Gid  int
    List []string
}
```

### func CurrentGroup

```go
func CurrentGroup() (Group, error)
```

CurrentGroup looks up the current user's group by their primary group id's entry in /etc/passwd. If the group cannot be found \(or there is no /etc/group file on the filesystem\), then CurrentGroup returns an error.

### func LookupGid

```go
func LookupGid(gid int) (Group, error)
```

LookupGid looks up a group by its group id in /etc/group. If the group cannot be found \(or there is no /etc/group file on the filesystem\), then LookupGid returns an error.

### func LookupGroup

```go
func LookupGroup(groupname string) (Group, error)
```

LookupGroup looks up a group by its name in /etc/group. If the group cannot be found \(or there is no /etc/group file on the filesystem\), then LookupGroup returns an error.

### func ParseGroup

```go
func ParseGroup(group io.Reader) ([]Group, error)
```

### func ParseGroupFile

```go
func ParseGroupFile(path string) ([]Group, error)
```

### func ParseGroupFileFilter

```go
func ParseGroupFileFilter(path string, filter func(Group) bool) ([]Group, error)
```

### func ParseGroupFilter

```go
func ParseGroupFilter(r io.Reader, filter func(Group) bool) ([]Group, error)
```

## type IDMap

IDMap represents an entry in /proc/PID/\{u,g\}id\_map

```go
type IDMap struct {
    ID       int64
    ParentID int64
    Count    int64
}
```

### func CurrentProcessGIDMap

```go
func CurrentProcessGIDMap() ([]IDMap, error)
```

### func CurrentProcessUIDMap

```go
func CurrentProcessUIDMap() ([]IDMap, error)
```

### func ParseIDMap

```go
func ParseIDMap(r io.Reader) ([]IDMap, error)
```

### func ParseIDMapFile

```go
func ParseIDMapFile(path string) ([]IDMap, error)
```

### func ParseIDMapFileFilter

```go
func ParseIDMapFileFilter(path string, filter func(IDMap) bool) ([]IDMap, error)
```

### func ParseIDMapFilter

```go
func ParseIDMapFilter(r io.Reader, filter func(IDMap) bool) ([]IDMap, error)
```

## type SubID

SubID represents an entry in /etc/sub\{u,g\}id

```go
type SubID struct {
    Name  string
    SubID int64
    Count int64
}
```

### func CurrentUserSubGIDs

```go
func CurrentUserSubGIDs() ([]SubID, error)
```

### func CurrentUserSubUIDs

```go
func CurrentUserSubUIDs() ([]SubID, error)
```

### func ParseSubID

```go
func ParseSubID(subid io.Reader) ([]SubID, error)
```

### func ParseSubIDFile

```go
func ParseSubIDFile(path string) ([]SubID, error)
```

### func ParseSubIDFileFilter

```go
func ParseSubIDFileFilter(path string, filter func(SubID) bool) ([]SubID, error)
```

### func ParseSubIDFilter

```go
func ParseSubIDFilter(r io.Reader, filter func(SubID) bool) ([]SubID, error)
```

## type User

```go
type User struct {
    Name  string
    Pass  string
    Uid   int
    Gid   int
    Gecos string
    Home  string
    Shell string
}
```

### func CurrentUser

```go
func CurrentUser() (User, error)
```

CurrentUser looks up the current user by their user id in /etc/passwd. If the user cannot be found \(or there is no /etc/passwd file on the filesystem\), then CurrentUser returns an error.

### func LookupUid

```go
func LookupUid(uid int) (User, error)
```

LookupUid looks up a user by their user id in /etc/passwd. If the user cannot be found \(or there is no /etc/passwd file on the filesystem\), then LookupId returns an error.

### func LookupUser

```go
func LookupUser(username string) (User, error)
```

LookupUser looks up a user by their username in /etc/passwd. If the user cannot be found \(or there is no /etc/passwd file on the filesystem\), then LookupUser returns an error.

### func ParsePasswd

```go
func ParsePasswd(passwd io.Reader) ([]User, error)
```

### func ParsePasswdFile

```go
func ParsePasswdFile(path string) ([]User, error)
```

### func ParsePasswdFileFilter

```go
func ParsePasswdFileFilter(path string, filter func(User) bool) ([]User, error)
```

### func ParsePasswdFilter

```go
func ParsePasswdFilter(r io.Reader, filter func(User) bool) ([]User, error)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
