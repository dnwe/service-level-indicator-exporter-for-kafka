<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# ast

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/hashicorp/hcl/hcl/ast"
```

Package ast declares the types used to represent syntax trees for HCL \(HashiCorp Configuration Language\)

## Index

- [type Comment](<#type-comment>)
  - [func (c *Comment) Pos() token.Pos](<#func-comment-pos>)
- [type CommentGroup](<#type-commentgroup>)
  - [func (c *CommentGroup) Pos() token.Pos](<#func-commentgroup-pos>)
- [type File](<#type-file>)
  - [func (f *File) Pos() token.Pos](<#func-file-pos>)
- [type ListType](<#type-listtype>)
  - [func (l *ListType) Add(node Node)](<#func-listtype-add>)
  - [func (l *ListType) Pos() token.Pos](<#func-listtype-pos>)
- [type LiteralType](<#type-literaltype>)
  - [func (l *LiteralType) Pos() token.Pos](<#func-literaltype-pos>)
- [type Node](<#type-node>)
  - [func Walk(node Node, fn WalkFunc) Node](<#func-walk>)
- [type ObjectItem](<#type-objectitem>)
  - [func (o *ObjectItem) Pos() token.Pos](<#func-objectitem-pos>)
- [type ObjectKey](<#type-objectkey>)
  - [func (o *ObjectKey) GoString() string](<#func-objectkey-gostring>)
  - [func (o *ObjectKey) Pos() token.Pos](<#func-objectkey-pos>)
- [type ObjectList](<#type-objectlist>)
  - [func (o *ObjectList) Add(item *ObjectItem)](<#func-objectlist-add>)
  - [func (o *ObjectList) Children() *ObjectList](<#func-objectlist-children>)
  - [func (o *ObjectList) Elem() *ObjectList](<#func-objectlist-elem>)
  - [func (o *ObjectList) Filter(keys ...string) *ObjectList](<#func-objectlist-filter>)
  - [func (o *ObjectList) GoString() string](<#func-objectlist-gostring>)
  - [func (o *ObjectList) Pos() token.Pos](<#func-objectlist-pos>)
- [type ObjectType](<#type-objecttype>)
  - [func (o *ObjectType) Pos() token.Pos](<#func-objecttype-pos>)
- [type WalkFunc](<#type-walkfunc>)


## type Comment

Comment node represents a single //, \# style or /\*\- style commment

```go
type Comment struct {
    Start token.Pos // position of / or #
    Text  string
}
```

### func \(\*Comment\) Pos

```go
func (c *Comment) Pos() token.Pos
```

## type CommentGroup

CommentGroup node represents a sequence of comments with no other tokens and no empty lines between.

```go
type CommentGroup struct {
    List []*Comment // len(List) > 0
}
```

### func \(\*CommentGroup\) Pos

```go
func (c *CommentGroup) Pos() token.Pos
```

## type File

File represents a single HCL file

```go
type File struct {
    Node     Node            // usually a *ObjectList
    Comments []*CommentGroup // list of all comments in the source
}
```

### func \(\*File\) Pos

```go
func (f *File) Pos() token.Pos
```

## type ListType

ListStatement represents a HCL List type

```go
type ListType struct {
    Lbrack token.Pos // position of "["
    Rbrack token.Pos // position of "]"
    List   []Node    // the elements in lexical order
}
```

### func \(\*ListType\) Add

```go
func (l *ListType) Add(node Node)
```

### func \(\*ListType\) Pos

```go
func (l *ListType) Pos() token.Pos
```

## type LiteralType

LiteralType represents a literal of basic type. Valid types are: token.NUMBER, token.FLOAT, token.BOOL and token.STRING

```go
type LiteralType struct {
    Token token.Token

    // comment types, only used when in a list
    LeadComment *CommentGroup
    LineComment *CommentGroup
}
```

### func \(\*LiteralType\) Pos

```go
func (l *LiteralType) Pos() token.Pos
```

## type Node

Node is an element in the abstract syntax tree.

```go
type Node interface {
    Pos() token.Pos
    // contains filtered or unexported methods
}
```

### func Walk

```go
func Walk(node Node, fn WalkFunc) Node
```

Walk traverses an AST in depth\-first order: It starts by calling fn\(node\); node must not be nil. If fn returns true, Walk invokes fn recursively for each of the non\-nil children of node, followed by a call of fn\(nil\). The returned node of fn can be used to rewrite the passed node to fn.

## type ObjectItem

ObjectItem represents a HCL Object Item. An item is represented with a key \(or keys\). It can be an assignment or an object \(both normal and nested\)

```go
type ObjectItem struct {
    // keys is only one length long if it's of type assignment. If it's a
    // nested object it can be larger than one. In that case "assign" is
    // invalid as there is no assignments for a nested object.
    Keys []*ObjectKey

    // assign contains the position of "=", if any
    Assign token.Pos

    // val is the item itself. It can be an object,list, number, bool or a
    // string. If key length is larger than one, val can be only of type
    // Object.
    Val Node

    LeadComment *CommentGroup // associated lead comment
    LineComment *CommentGroup // associated line comment
}
```

### func \(\*ObjectItem\) Pos

```go
func (o *ObjectItem) Pos() token.Pos
```

## type ObjectKey

ObjectKeys are either an identifier or of type string.

```go
type ObjectKey struct {
    Token token.Token
}
```

### func \(\*ObjectKey\) GoString

```go
func (o *ObjectKey) GoString() string
```

### func \(\*ObjectKey\) Pos

```go
func (o *ObjectKey) Pos() token.Pos
```

## type ObjectList

ObjectList represents a list of ObjectItems. An HCL file itself is an ObjectList.

```go
type ObjectList struct {
    Items []*ObjectItem
}
```

### func \(\*ObjectList\) Add

```go
func (o *ObjectList) Add(item *ObjectItem)
```

### func \(\*ObjectList\) Children

```go
func (o *ObjectList) Children() *ObjectList
```

Children returns further nested objects \(key length \> 0\) within this ObjectList. This should be used with Filter to get at child items.

### func \(\*ObjectList\) Elem

```go
func (o *ObjectList) Elem() *ObjectList
```

Elem returns items in the list that are direct element assignments \(key length == 0\). This should be used with Filter to get at elements.

### func \(\*ObjectList\) Filter

```go
func (o *ObjectList) Filter(keys ...string) *ObjectList
```

Filter filters out the objects with the given key list as a prefix.

The returned list of objects contain ObjectItems where the keys have this prefix already stripped off. This might result in objects with zero\-length key lists if they have no children.

If no matches are found, an empty ObjectList \(non\-nil\) is returned.

### func \(\*ObjectList\) GoString

```go
func (o *ObjectList) GoString() string
```

### func \(\*ObjectList\) Pos

```go
func (o *ObjectList) Pos() token.Pos
```

## type ObjectType

ObjectType represents a HCL Object Type

```go
type ObjectType struct {
    Lbrace token.Pos   // position of "{"
    Rbrace token.Pos   // position of "}"
    List   *ObjectList // the nodes in lexical order
}
```

### func \(\*ObjectType\) Pos

```go
func (o *ObjectType) Pos() token.Pos
```

## type WalkFunc

WalkFunc describes a function to be called for each node during a Walk. The returned node can be used to rewrite the AST. Walking stops the returned bool is false.

```go
type WalkFunc func(Node) (Node, bool)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
