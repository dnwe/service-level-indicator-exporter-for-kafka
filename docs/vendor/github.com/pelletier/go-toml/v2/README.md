<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# toml

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/pelletier/go-toml/v2"
```

Package toml is a library to read and write TOML documents.

## Index

- [func Marshal(v interface{}) ([]byte, error)](<#func-marshal>)
- [func Unmarshal(data []byte, v interface{}) error](<#func-unmarshal>)
- [type DecodeError](<#type-decodeerror>)
  - [func (e *DecodeError) Error() string](<#func-decodeerror-error>)
  - [func (e *DecodeError) Key() Key](<#func-decodeerror-key>)
  - [func (e *DecodeError) Position() (row int, column int)](<#func-decodeerror-position>)
  - [func (e *DecodeError) String() string](<#func-decodeerror-string>)
- [type Decoder](<#type-decoder>)
  - [func NewDecoder(r io.Reader) *Decoder](<#func-newdecoder>)
  - [func (d *Decoder) Decode(v interface{}) error](<#func-decoder-decode>)
  - [func (d *Decoder) DisallowUnknownFields() *Decoder](<#func-decoder-disallowunknownfields>)
- [type Encoder](<#type-encoder>)
  - [func NewEncoder(w io.Writer) *Encoder](<#func-newencoder>)
  - [func (enc *Encoder) Encode(v interface{}) error](<#func-encoder-encode>)
  - [func (enc *Encoder) SetArraysMultiline(multiline bool) *Encoder](<#func-encoder-setarraysmultiline>)
  - [func (enc *Encoder) SetIndentSymbol(s string) *Encoder](<#func-encoder-setindentsymbol>)
  - [func (enc *Encoder) SetIndentTables(indent bool) *Encoder](<#func-encoder-setindenttables>)
  - [func (enc *Encoder) SetTablesInline(inline bool) *Encoder](<#func-encoder-settablesinline>)
- [type Key](<#type-key>)
- [type LocalDate](<#type-localdate>)
  - [func (d LocalDate) AsTime(zone *time.Location) time.Time](<#func-localdate-astime>)
  - [func (d LocalDate) MarshalText() ([]byte, error)](<#func-localdate-marshaltext>)
  - [func (d LocalDate) String() string](<#func-localdate-string>)
  - [func (d *LocalDate) UnmarshalText(b []byte) error](<#func-localdate-unmarshaltext>)
- [type LocalDateTime](<#type-localdatetime>)
  - [func (d LocalDateTime) AsTime(zone *time.Location) time.Time](<#func-localdatetime-astime>)
  - [func (d LocalDateTime) MarshalText() ([]byte, error)](<#func-localdatetime-marshaltext>)
  - [func (d LocalDateTime) String() string](<#func-localdatetime-string>)
  - [func (d *LocalDateTime) UnmarshalText(data []byte) error](<#func-localdatetime-unmarshaltext>)
- [type LocalTime](<#type-localtime>)
  - [func (d LocalTime) MarshalText() ([]byte, error)](<#func-localtime-marshaltext>)
  - [func (d LocalTime) String() string](<#func-localtime-string>)
  - [func (d *LocalTime) UnmarshalText(b []byte) error](<#func-localtime-unmarshaltext>)
- [type StrictMissingError](<#type-strictmissingerror>)
  - [func (s *StrictMissingError) Error() string](<#func-strictmissingerror-error>)
  - [func (s *StrictMissingError) String() string](<#func-strictmissingerror-string>)


## func Marshal

```go
func Marshal(v interface{}) ([]byte, error)
```

Marshal serializes a Go value as a TOML document.

It is a shortcut for Encoder.Encode\(\) with the default options.

## func Unmarshal

```go
func Unmarshal(data []byte, v interface{}) error
```

Unmarshal deserializes a TOML document into a Go value.

It is a shortcut for Decoder.Decode\(\) with the default options.

## type DecodeError

DecodeError represents an error encountered during the parsing or decoding of a TOML document.

In addition to the error message, it contains the position in the document where it happened, as well as a human\-readable representation that shows where the error occurred in the document.

```go
type DecodeError struct {
    // contains filtered or unexported fields
}
```

### func \(\*DecodeError\) Error

```go
func (e *DecodeError) Error() string
```

Error returns the error message contained in the DecodeError.

### func \(\*DecodeError\) Key

```go
func (e *DecodeError) Key() Key
```

Key that was being processed when the error occurred. The key is present only if this DecodeError is part of a StrictMissingError.

### func \(\*DecodeError\) Position

```go
func (e *DecodeError) Position() (row int, column int)
```

Position returns the \(line, column\) pair indicating where the error occurred in the document. Positions are 1\-indexed.

### func \(\*DecodeError\) String

```go
func (e *DecodeError) String() string
```

String returns the human\-readable contextualized error. This string is multi\-line.

## type Decoder

Decoder reads and decode a TOML document from an input stream.

```go
type Decoder struct {
    // contains filtered or unexported fields
}
```

### func NewDecoder

```go
func NewDecoder(r io.Reader) *Decoder
```

NewDecoder creates a new Decoder that will read from r.

### func \(\*Decoder\) Decode

```go
func (d *Decoder) Decode(v interface{}) error
```

Decode the whole content of r into v.

By default, values in the document that don't exist in the target Go value are ignored. See Decoder.DisallowUnknownFields\(\) to change this behavior.

When a TOML local date, time, or date\-time is decoded into a time.Time, its value is represented in time.Local timezone. Otherwise the approriate Local\* structure is used. For time values, precision up to the nanosecond is supported by truncating extra digits.

Empty tables decoded in an interface\{\} create an empty initialized map\[string\]interface\{\}.

Types implementing the encoding.TextUnmarshaler interface are decoded from a TOML string.

When decoding a number, go\-toml will return an error if the number is out of bounds for the target type \(which includes negative numbers when decoding into an unsigned int\).

If an error occurs while decoding the content of the document, this function returns a toml.DecodeError, providing context about the issue. When using strict mode and a field is missing, a \`toml.StrictMissingError\` is returned. In any other case, this function returns a standard Go error.

\# Type mapping

List of supported TOML types and their associated accepted Go types:

```
String           -> string
Integer          -> uint*, int*, depending on size
Float            -> float*, depending on size
Boolean          -> bool
Offset Date-Time -> time.Time
Local Date-time  -> LocalDateTime, time.Time
Local Date       -> LocalDate, time.Time
Local Time       -> LocalTime, time.Time
Array            -> slice and array, depending on elements types
Table            -> map and struct
Inline Table     -> same as Table
Array of Tables  -> same as Array and Table
```

### func \(\*Decoder\) DisallowUnknownFields

```go
func (d *Decoder) DisallowUnknownFields() *Decoder
```

DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains a key that does not match a non\-ignored field.

In that case, the Decoder returns a StrictMissingError that can be used to retrieve the individual errors as well as generate a human readable description of the missing fields.

## type Encoder

Encoder writes a TOML document to an output stream.

```go
type Encoder struct {
    // contains filtered or unexported fields
}
```

### func NewEncoder

```go
func NewEncoder(w io.Writer) *Encoder
```

NewEncoder returns a new Encoder that writes to w.

### func \(\*Encoder\) Encode

```go
func (enc *Encoder) Encode(v interface{}) error
```

Encode writes a TOML representation of v to the stream.

If v cannot be represented to TOML it returns an error.

\# Encoding rules

A top level slice containing only maps or structs is encoded as \[\[table array\]\].

All slices not matching rule 1 are encoded as \[array\]. As a result, any map or struct they contain is encoded as an \{inline table\}.

Nil interfaces and nil pointers are not supported.

Keys in key\-values always have one part.

Intermediate tables are always printed.

By default, strings are encoded as literal string, unless they contain either a newline character or a single quote. In that case they are emitted as quoted strings.

Unsigned integers larger than math.MaxInt64 cannot be encoded. Doing so results in an error. This rule exists because the TOML specification only requires parsers to support at least the 64 bits integer range. Allowing larger numbers would create non\-standard TOML documents, which may not be readable \(at best\) by other implementations. To encode such numbers, a solution is a custom type that implements encoding.TextMarshaler.

When encoding structs, fields are encoded in order of definition, with their exact name.

Tables and array tables are separated by empty lines. However, consecutive subtables definitions are not. For example:

```
[top1]

[top2]
[top2.child1]

[[array]]

[[array]]
[array.child2]
```

\# Struct tags

The encoding of each public struct field can be customized by the format string in the "toml" key of the struct field's tag. This follows encoding/json's convention. The format string starts with the name of the field, optionally followed by a comma\-separated list of options. The name may be empty in order to provide options without overriding the default name.

The "multiline" option emits strings as quoted multi\-line TOML strings. It has no effect on fields that would not be encoded as strings.

The "inline" option turns fields that would be emitted as tables into inline tables instead. It has no effect on other fields.

The "omitempty" option prevents empty values or groups from being emitted.

In addition to the "toml" tag struct tag, a "comment" tag can be used to emit a TOML comment before the value being annotated. Comments are ignored inside inline tables. For array tables, the comment is only present before the first element of the array.

### func \(\*Encoder\) SetArraysMultiline

```go
func (enc *Encoder) SetArraysMultiline(multiline bool) *Encoder
```

SetArraysMultiline forces the encoder to emit all arrays with one element per line.

This behavior can be controlled on an individual struct field basis with the multiline tag:

```
MyField `multiline:"true"`
```

### func \(\*Encoder\) SetIndentSymbol

```go
func (enc *Encoder) SetIndentSymbol(s string) *Encoder
```

SetIndentSymbol defines the string that should be used for indentation. The provided string is repeated for each indentation level. Defaults to two spaces.

### func \(\*Encoder\) SetIndentTables

```go
func (enc *Encoder) SetIndentTables(indent bool) *Encoder
```

SetIndentTables forces the encoder to intent tables and array tables.

### func \(\*Encoder\) SetTablesInline

```go
func (enc *Encoder) SetTablesInline(inline bool) *Encoder
```

SetTablesInline forces the encoder to emit all tables inline.

This behavior can be controlled on an individual struct field basis with the inline tag:

```
MyField `toml:",inline"`
```

## type Key

```go
type Key []string
```

## type LocalDate

LocalDate represents a calendar day in no specific timezone.

```go
type LocalDate struct {
    Year  int
    Month int
    Day   int
}
```

### func \(LocalDate\) AsTime

```go
func (d LocalDate) AsTime(zone *time.Location) time.Time
```

AsTime converts d into a specific time instance at midnight in zone.

### func \(LocalDate\) MarshalText

```go
func (d LocalDate) MarshalText() ([]byte, error)
```

MarshalText returns RFC 3339 representation of d.

### func \(LocalDate\) String

```go
func (d LocalDate) String() string
```

String returns RFC 3339 representation of d.

### func \(\*LocalDate\) UnmarshalText

```go
func (d *LocalDate) UnmarshalText(b []byte) error
```

UnmarshalText parses b using RFC 3339 to fill d.

## type LocalDateTime

LocalDateTime represents a time of a specific day in no specific timezone.

```go
type LocalDateTime struct {
    LocalDate
    LocalTime
}
```

### func \(LocalDateTime\) AsTime

```go
func (d LocalDateTime) AsTime(zone *time.Location) time.Time
```

AsTime converts d into a specific time instance in zone.

### func \(LocalDateTime\) MarshalText

```go
func (d LocalDateTime) MarshalText() ([]byte, error)
```

MarshalText returns RFC 3339 representation of d.

### func \(LocalDateTime\) String

```go
func (d LocalDateTime) String() string
```

String returns RFC 3339 representation of d.

### func \(\*LocalDateTime\) UnmarshalText

```go
func (d *LocalDateTime) UnmarshalText(data []byte) error
```

UnmarshalText parses b using RFC 3339 to fill d.

## type LocalTime

LocalTime represents a time of day of no specific day in no specific timezone.

```go
type LocalTime struct {
    Hour       int // Hour of the day: [0; 24[
    Minute     int // Minute of the hour: [0; 60[
    Second     int // Second of the minute: [0; 60[
    Nanosecond int // Nanoseconds within the second:  [0, 1000000000[
    Precision  int // Number of digits to display for Nanosecond.
}
```

### func \(LocalTime\) MarshalText

```go
func (d LocalTime) MarshalText() ([]byte, error)
```

MarshalText returns RFC 3339 representation of d.

### func \(LocalTime\) String

```go
func (d LocalTime) String() string
```

String returns RFC 3339 representation of d. If d.Nanosecond and d.Precision are zero, the time won't have a nanosecond component. If d.Nanosecond \> 0 but d.Precision = 0, then the minimum number of digits for nanoseconds is provided.

### func \(\*LocalTime\) UnmarshalText

```go
func (d *LocalTime) UnmarshalText(b []byte) error
```

UnmarshalText parses b using RFC 3339 to fill d.

## type StrictMissingError

StrictMissingError occurs in a TOML document that does not have a corresponding field in the target value. It contains all the missing fields in Errors.

Emitted by Decoder when DisallowUnknownFields\(\) was called.

```go
type StrictMissingError struct {
    // One error per field that could not be found.
    Errors []DecodeError
}
```

### func \(\*StrictMissingError\) Error

```go
func (s *StrictMissingError) Error() string
```

Error returns the canonical string for this error.

### func \(\*StrictMissingError\) String

```go
func (s *StrictMissingError) String() string
```

String returns a human readable description of all errors.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
