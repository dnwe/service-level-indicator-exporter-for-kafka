<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# ast

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/pelletier/go-toml/v2/internal/ast"
```

## Index

- [type Builder](<#type-builder>)
  - [func (b *Builder) AttachChild(parent Reference, child Reference)](<#func-builder-attachchild>)
  - [func (b *Builder) Chain(from Reference, to Reference)](<#func-builder-chain>)
  - [func (b *Builder) NodeAt(ref Reference) *Node](<#func-builder-nodeat>)
  - [func (b *Builder) Push(n Node) Reference](<#func-builder-push>)
  - [func (b *Builder) PushAndChain(n Node) Reference](<#func-builder-pushandchain>)
  - [func (b *Builder) Reset()](<#func-builder-reset>)
  - [func (b *Builder) Tree() *Root](<#func-builder-tree>)
- [type Iterator](<#type-iterator>)
  - [func (c *Iterator) IsLast() bool](<#func-iterator-islast>)
  - [func (c *Iterator) Next() bool](<#func-iterator-next>)
  - [func (c *Iterator) Node() *Node](<#func-iterator-node>)
- [type Kind](<#type-kind>)
  - [func (k Kind) String() string](<#func-kind-string>)
- [type Node](<#type-node>)
  - [func (n *Node) Child() *Node](<#func-node-child>)
  - [func (n *Node) Children() Iterator](<#func-node-children>)
  - [func (n *Node) Key() Iterator](<#func-node-key>)
  - [func (n *Node) Next() *Node](<#func-node-next>)
  - [func (n *Node) Valid() bool](<#func-node-valid>)
  - [func (n *Node) Value() *Node](<#func-node-value>)
- [type Range](<#type-range>)
- [type Reference](<#type-reference>)
  - [func (r Reference) Valid() bool](<#func-reference-valid>)
- [type Root](<#type-root>)
  - [func (r *Root) Iterator() Iterator](<#func-root-iterator>)


## type Builder

```go
type Builder struct {
    // contains filtered or unexported fields
}
```

### func \(\*Builder\) AttachChild

```go
func (b *Builder) AttachChild(parent Reference, child Reference)
```

### func \(\*Builder\) Chain

```go
func (b *Builder) Chain(from Reference, to Reference)
```

### func \(\*Builder\) NodeAt

```go
func (b *Builder) NodeAt(ref Reference) *Node
```

### func \(\*Builder\) Push

```go
func (b *Builder) Push(n Node) Reference
```

### func \(\*Builder\) PushAndChain

```go
func (b *Builder) PushAndChain(n Node) Reference
```

### func \(\*Builder\) Reset

```go
func (b *Builder) Reset()
```

### func \(\*Builder\) Tree

```go
func (b *Builder) Tree() *Root
```

## type Iterator

Iterator starts uninitialized, you need to call Next\(\) first.

For example:

```
it := n.Children()
for it.Next() {
		it.Node()
}
```

```go
type Iterator struct {
    // contains filtered or unexported fields
}
```

### func \(\*Iterator\) IsLast

```go
func (c *Iterator) IsLast() bool
```

IsLast returns true if the current node of the iterator is the last one.  Subsequent call to Next\(\) will return false.

### func \(\*Iterator\) Next

```go
func (c *Iterator) Next() bool
```

Next moves the iterator forward and returns true if points to a node, false otherwise.

### func \(\*Iterator\) Node

```go
func (c *Iterator) Node() *Node
```

Node returns a copy of the node pointed at by the iterator.

## type Kind

```go
type Kind int
```

```go
const (
    // meta
    Invalid Kind = iota
    Comment
    Key

    // top level structures
    Table
    ArrayTable
    KeyValue

    // containers values
    Array
    InlineTable

    // values
    String
    Bool
    Float
    Integer
    LocalDate
    LocalTime
    LocalDateTime
    DateTime
)
```

### func \(Kind\) String

```go
func (k Kind) String() string
```

## type Node

Arrays have one child per element in the array.  InlineTables have one child per key\-value pair in the table.  KeyValues have at least two children. The first one is the value. The rest make a potentially dotted key.  Table and Array table have one child per element of the key they represent \(same as KeyValue, but without the last node being the value\).

```go
type Node struct {
    Kind Kind
    Raw  Range  // Raw bytes from the input.
    Data []byte // Node value (either allocated or referencing the input).
    // contains filtered or unexported fields
}
```

### func \(\*Node\) Child

```go
func (n *Node) Child() *Node
```

Child returns a copy of the first child node of this node. Other children can be accessed calling Next on the first child.  Returns an invalid Node if there is none.

### func \(\*Node\) Children

```go
func (n *Node) Children() Iterator
```

Children returns an iterator over a node's children.

### func \(\*Node\) Key

```go
func (n *Node) Key() Iterator
```

Key returns the child nodes making the Key on a supported node. Panics otherwise.  They are guaranteed to be all be of the Kind Key. A simple key would return just one element.

### func \(\*Node\) Next

```go
func (n *Node) Next() *Node
```

Next returns a copy of the next node, or an invalid Node if there is no next node.

### func \(\*Node\) Valid

```go
func (n *Node) Valid() bool
```

Valid returns true if the node's kind is set \(not to Invalid\).

### func \(\*Node\) Value

```go
func (n *Node) Value() *Node
```

Value returns a pointer to the value node of a KeyValue. Guaranteed to be non\-nil.  Panics if not called on a KeyValue node, or if the Children are malformed.

## type Range

```go
type Range struct {
    Offset uint32
    Length uint32
}
```

## type Reference

```go
type Reference int
```

```go
const InvalidReference Reference = -1
```

### func \(Reference\) Valid

```go
func (r Reference) Valid() bool
```

## type Root

Root contains a full AST.

It is immutable once constructed with Builder.

```go
type Root struct {
    // contains filtered or unexported fields
}
```

### func \(\*Root\) Iterator

```go
func (r *Root) Iterator() Iterator
```

Iterator over the top level nodes.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
