<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# time

```go
import "github.com/docker/docker/api/types/time"
```

## Index

- [func GetTimestamp(value string, reference time.Time) (string, error)](<#func-gettimestamp>)
- [func ParseTimestamps(value string, def int64) (int64, int64, error)](<#func-parsetimestamps>)


## func GetTimestamp

```go
func GetTimestamp(value string, reference time.Time) (string, error)
```

GetTimestamp tries to parse given string as golang duration, then RFC3339 time and finally as a Unix timestamp. If any of these were successful, it returns a Unix timestamp as string otherwise returns the given value back. In case of duration input, the returned timestamp is computed as the given reference time minus the amount of the duration.

## func ParseTimestamps

```go
func ParseTimestamps(value string, def int64) (int64, int64, error)
```

ParseTimestamps returns seconds and nanoseconds from a timestamp that has the format "%d.%09d", time.Unix\(\), int64\(time.Nanosecond\(\)\)\) if the incoming nanosecond portion is longer or shorter than 9 digits it is converted to nanoseconds.  The expectation is that the seconds and seconds will be used to create a time variable.  For example:

```
seconds, nanoseconds, err := ParseTimestamp("1136073600.000000001",0)
if err == nil since := time.Unix(seconds, nanoseconds)
```

returns seconds as def\(aultSeconds\) if value == ""



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
