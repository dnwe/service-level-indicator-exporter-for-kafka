<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# mapstructure

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/mitchellh/mapstructure"
```

Package mapstructure exposes functionality to convert one arbitrary Go type into another, typically to convert a map\[string\]interface\{\} into a native Go structure.

The Go structure can be arbitrarily complex, containing slices, other structs, etc. and the decoder will properly decode nested maps and so on into the proper structures in the native Go struct. See the examples to see what the decoder is capable of.

The simplest function to start with is Decode.

### Field Tags

When decoding to a struct, mapstructure will use the field name by default to perform the mapping. For example, if a struct has a field "Username" then mapstructure will look for a key in the source value of "username" \(case insensitive\).

```
type User struct {
    Username string
}
```

You can change the behavior of mapstructure by using struct tags. The default struct tag that mapstructure looks for is "mapstructure" but you can customize it using DecoderConfig.

### Renaming Fields

To rename the key that mapstructure looks for, use the "mapstructure" tag and set a value directly. For example, to change the "username" example above to "user":

```
type User struct {
    Username string `mapstructure:"user"`
}
```

### Embedded Structs and Squashing

Embedded structs are treated as if they're another field with that name. By default, the two structs below are equivalent when decoding with mapstructure:

```
type Person struct {
    Name string
}

type Friend struct {
    Person
}

type Friend struct {
    Person Person
}
```

This would require an input that looks like below:

```
map[string]interface{}{
    "person": map[string]interface{}{"name": "alice"},
}
```

If your "person" value is NOT nested, then you can append ",squash" to your tag value and mapstructure will treat it as if the embedded struct were part of the struct directly. Example:

```
type Friend struct {
    Person `mapstructure:",squash"`
}
```

Now the following input would be accepted:

```
map[string]interface{}{
    "name": "alice",
}
```

When decoding from a struct to a map, the squash tag squashes the struct fields into a single map. Using the example structs from above:

```
Friend{Person: Person{Name: "alice"}}
```

Will be decoded into a map:

```
map[string]interface{}{
    "name": "alice",
}
```

DecoderConfig has a field that changes the behavior of mapstructure to always squash embedded structs.

### Remainder Values

If there are any unmapped keys in the source value, mapstructure by default will silently ignore them. You can error by setting ErrorUnused in DecoderConfig. If you're using Metadata you can also maintain a slice of the unused keys.

You can also use the ",remain" suffix on your tag to collect all unused values in a map. The field with this tag MUST be a map type and should probably be a "map\[string\]interface\{\}" or "map\[interface\{\}\]interface\{\}". See example below:

```
type Friend struct {
    Name  string
    Other map[string]interface{} `mapstructure:",remain"`
}
```

Given the input below, Other would be populated with the other values that weren't used \(everything but "name"\):

```
map[string]interface{}{
    "name":    "bob",
    "address": "123 Maple St.",
}
```

### Omit Empty Values

When decoding from a struct to any other value, you may use the ",omitempty" suffix on your tag to omit that value if it equates to the zero value. The zero value of all types is specified in the Go specification.

For example, the zero type of a numeric type is zero \("0"\). If the struct field value is zero and a numeric type, the field is empty, and it won't be encoded into the destination type.

```
type Source struct {
    Age int `mapstructure:",omitempty"`
}
```

### Unexported fields

Since unexported \(private\) struct fields cannot be set outside the package where they are defined, the decoder will simply skip them.

For this output type definition:

```
type Exported struct {
    private string // this unexported field will be skipped
    Public string
}
```

Using this map as input:

```
map[string]interface{}{
    "private": "I will be ignored",
    "Public":  "I made it through!",
}
```

The following struct will be decoded:

```
type Exported struct {
    private: "" // field is left with an empty string (zero value)
    Public: "I made it through!"
}
```

### Other Configuration

mapstructure is highly configurable. See the DecoderConfig struct for other features and options that are supported.

## Index

- [func Decode(input interface{}, output interface{}) error](<#func-decode>)
- [func DecodeHookExec(raw DecodeHookFunc, from reflect.Value, to reflect.Value) (interface{}, error)](<#func-decodehookexec>)
- [func DecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error](<#func-decodemetadata>)
- [func WeakDecode(input, output interface{}) error](<#func-weakdecode>)
- [func WeakDecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error](<#func-weakdecodemetadata>)
- [func WeaklyTypedHook(f reflect.Kind, t reflect.Kind, data interface{}) (interface{}, error)](<#func-weaklytypedhook>)
- [type DecodeHookFunc](<#type-decodehookfunc>)
  - [func ComposeDecodeHookFunc(fs ...DecodeHookFunc) DecodeHookFunc](<#func-composedecodehookfunc>)
  - [func OrComposeDecodeHookFunc(ff ...DecodeHookFunc) DecodeHookFunc](<#func-orcomposedecodehookfunc>)
  - [func RecursiveStructToMapHookFunc() DecodeHookFunc](<#func-recursivestructtomaphookfunc>)
  - [func StringToIPHookFunc() DecodeHookFunc](<#func-stringtoiphookfunc>)
  - [func StringToIPNetHookFunc() DecodeHookFunc](<#func-stringtoipnethookfunc>)
  - [func StringToSliceHookFunc(sep string) DecodeHookFunc](<#func-stringtoslicehookfunc>)
  - [func StringToTimeDurationHookFunc() DecodeHookFunc](<#func-stringtotimedurationhookfunc>)
  - [func StringToTimeHookFunc(layout string) DecodeHookFunc](<#func-stringtotimehookfunc>)
- [type DecodeHookFuncKind](<#type-decodehookfunckind>)
- [type DecodeHookFuncType](<#type-decodehookfunctype>)
  - [func TextUnmarshallerHookFunc() DecodeHookFuncType](<#func-textunmarshallerhookfunc>)
- [type DecodeHookFuncValue](<#type-decodehookfuncvalue>)
- [type Decoder](<#type-decoder>)
  - [func NewDecoder(config *DecoderConfig) (*Decoder, error)](<#func-newdecoder>)
  - [func (d *Decoder) Decode(input interface{}) error](<#func-decoder-decode>)
- [type DecoderConfig](<#type-decoderconfig>)
- [type Error](<#type-error>)
  - [func (e *Error) Error() string](<#func-error-error>)
  - [func (e *Error) WrappedErrors() []error](<#func-error-wrappederrors>)
- [type Metadata](<#type-metadata>)


## func Decode

```go
func Decode(input interface{}, output interface{}) error
```

Decode takes an input structure and uses reflection to translate it to the output structure. output must be a pointer to a map or struct.

## func DecodeHookExec

```go
func DecodeHookExec(raw DecodeHookFunc, from reflect.Value, to reflect.Value) (interface{}, error)
```

DecodeHookExec executes the given decode hook. This should be used since it'll naturally degrade to the older backwards compatible DecodeHookFunc that took reflect.Kind instead of reflect.Type.

## func DecodeMetadata

```go
func DecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error
```

DecodeMetadata is the same as Decode, but is shorthand to enable metadata collection. See DecoderConfig for more info.

## func WeakDecode

```go
func WeakDecode(input, output interface{}) error
```

WeakDecode is the same as Decode but is shorthand to enable WeaklyTypedInput. See DecoderConfig for more info.

## func WeakDecodeMetadata

```go
func WeakDecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error
```

WeakDecodeMetadata is the same as Decode, but is shorthand to enable both WeaklyTypedInput and metadata collection. See DecoderConfig for more info.

## func WeaklyTypedHook

```go
func WeaklyTypedHook(f reflect.Kind, t reflect.Kind, data interface{}) (interface{}, error)
```

WeaklyTypedHook is a DecodeHookFunc which adds support for weak typing to the decoder.

Note that this is significantly different from the WeaklyTypedInput option of the DecoderConfig.

## type DecodeHookFunc

DecodeHookFunc is the callback function that can be used for data transformations. See "DecodeHook" in the DecoderConfig struct.

The type must be one of DecodeHookFuncType, DecodeHookFuncKind, or DecodeHookFuncValue. Values are a superset of Types \(Values can return types\), and Types are a superset of Kinds \(Types can return Kinds\) and are generally a richer thing to use, but Kinds are simpler if you only need those.

The reason DecodeHookFunc is multi\-typed is for backwards compatibility: we started with Kinds and then realized Types were the better solution, but have a promise to not break backwards compat so we now support both.

```go
type DecodeHookFunc interface{}
```

### func ComposeDecodeHookFunc

```go
func ComposeDecodeHookFunc(fs ...DecodeHookFunc) DecodeHookFunc
```

ComposeDecodeHookFunc creates a single DecodeHookFunc that automatically composes multiple DecodeHookFuncs.

The composed funcs are called in order, with the result of the previous transformation.

### func OrComposeDecodeHookFunc

```go
func OrComposeDecodeHookFunc(ff ...DecodeHookFunc) DecodeHookFunc
```

OrComposeDecodeHookFunc executes all input hook functions until one of them returns no error. In that case its value is returned. If all hooks return an error, OrComposeDecodeHookFunc returns an error concatenating all error messages.

### func RecursiveStructToMapHookFunc

```go
func RecursiveStructToMapHookFunc() DecodeHookFunc
```

### func StringToIPHookFunc

```go
func StringToIPHookFunc() DecodeHookFunc
```

StringToIPHookFunc returns a DecodeHookFunc that converts strings to net.IP

### func StringToIPNetHookFunc

```go
func StringToIPNetHookFunc() DecodeHookFunc
```

StringToIPNetHookFunc returns a DecodeHookFunc that converts strings to net.IPNet

### func StringToSliceHookFunc

```go
func StringToSliceHookFunc(sep string) DecodeHookFunc
```

StringToSliceHookFunc returns a DecodeHookFunc that converts string to \[\]string by splitting on the given sep.

### func StringToTimeDurationHookFunc

```go
func StringToTimeDurationHookFunc() DecodeHookFunc
```

StringToTimeDurationHookFunc returns a DecodeHookFunc that converts strings to time.Duration.

### func StringToTimeHookFunc

```go
func StringToTimeHookFunc(layout string) DecodeHookFunc
```

StringToTimeHookFunc returns a DecodeHookFunc that converts strings to time.Time.

## type DecodeHookFuncKind

DecodeHookFuncKind is a DecodeHookFunc which knows only the Kinds of the source and target types.

```go
type DecodeHookFuncKind func(reflect.Kind, reflect.Kind, interface{}) (interface{}, error)
```

## type DecodeHookFuncType

DecodeHookFuncType is a DecodeHookFunc which has complete information about the source and target types.

```go
type DecodeHookFuncType func(reflect.Type, reflect.Type, interface{}) (interface{}, error)
```

### func TextUnmarshallerHookFunc

```go
func TextUnmarshallerHookFunc() DecodeHookFuncType
```

TextUnmarshallerHookFunc returns a DecodeHookFunc that applies strings to the UnmarshalText function, when the target type implements the encoding.TextUnmarshaler interface

## type DecodeHookFuncValue

DecodeHookFuncValue is a DecodeHookFunc which has complete access to both the source and target values.

```go
type DecodeHookFuncValue func(from reflect.Value, to reflect.Value) (interface{}, error)
```

## type Decoder

A Decoder takes a raw interface value and turns it into structured data, keeping track of rich error information along the way in case anything goes wrong. Unlike the basic top\-level Decode method, you can more finely control how the Decoder behaves using the DecoderConfig structure. The top\-level Decode method is just a convenience that sets up the most basic Decoder.

```go
type Decoder struct {
    // contains filtered or unexported fields
}
```

### func NewDecoder

```go
func NewDecoder(config *DecoderConfig) (*Decoder, error)
```

NewDecoder returns a new decoder for the given configuration. Once a decoder has been returned, the same configuration must not be used again.

### func \(\*Decoder\) Decode

```go
func (d *Decoder) Decode(input interface{}) error
```

Decode decodes the given raw interface to the target pointer specified by the configuration.

## type DecoderConfig

DecoderConfig is the configuration that is used to create a new decoder and allows customization of various aspects of decoding.

```go
type DecoderConfig struct {
    // DecodeHook, if set, will be called before any decoding and any
    // type conversion (if WeaklyTypedInput is on). This lets you modify
    // the values before they're set down onto the resulting struct. The
    // DecodeHook is called for every map and value in the input. This means
    // that if a struct has embedded fields with squash tags the decode hook
    // is called only once with all of the input data, not once for each
    // embedded struct.
    //
    // If an error is returned, the entire decode will fail with that error.
    DecodeHook DecodeHookFunc

    // If ErrorUnused is true, then it is an error for there to exist
    // keys in the original map that were unused in the decoding process
    // (extra keys).
    ErrorUnused bool

    // If ErrorUnset is true, then it is an error for there to exist
    // fields in the result that were not set in the decoding process
    // (extra fields). This only applies to decoding to a struct. This
    // will affect all nested structs as well.
    ErrorUnset bool

    // ZeroFields, if set to true, will zero fields before writing them.
    // For example, a map will be emptied before decoded values are put in
    // it. If this is false, a map will be merged.
    ZeroFields bool

    // If WeaklyTypedInput is true, the decoder will make the following
    // "weak" conversions:
    //
    //   - bools to string (true = "1", false = "0")
    //   - numbers to string (base 10)
    //   - bools to int/uint (true = 1, false = 0)
    //   - strings to int/uint (base implied by prefix)
    //   - int to bool (true if value != 0)
    //   - string to bool (accepts: 1, t, T, TRUE, true, True, 0, f, F,
    //     FALSE, false, False. Anything else is an error)
    //   - empty array = empty map and vice versa
    //   - negative numbers to overflowed uint values (base 10)
    //   - slice of maps to a merged map
    //   - single values are converted to slices if required. Each
    //     element is weakly decoded. For example: "4" can become []int{4}
    //     if the target type is an int slice.
    //
    WeaklyTypedInput bool

    // Squash will squash embedded structs.  A squash tag may also be
    // added to an individual struct field using a tag.  For example:
    //
    //  type Parent struct {
    //      Child `mapstructure:",squash"`
    //  }
    Squash bool

    // Metadata is the struct that will contain extra metadata about
    // the decoding. If this is nil, then no metadata will be tracked.
    Metadata *Metadata

    // Result is a pointer to the struct that will contain the decoded
    // value.
    Result interface{}

    // The tag name that mapstructure reads for field names. This
    // defaults to "mapstructure"
    TagName string

    // IgnoreUntaggedFields ignores all struct fields without explicit
    // TagName, comparable to `mapstructure:"-"` as default behaviour.
    IgnoreUntaggedFields bool

    // MatchName is the function used to match the map key to the struct
    // field name or tag. Defaults to `strings.EqualFold`. This can be used
    // to implement case-sensitive tag values, support snake casing, etc.
    MatchName func(mapKey, fieldName string) bool
}
```

## type Error

Error implements the error interface and can represents multiple errors that occur in the course of a single decode.

```go
type Error struct {
    Errors []string
}
```

### func \(\*Error\) Error

```go
func (e *Error) Error() string
```

### func \(\*Error\) WrappedErrors

```go
func (e *Error) WrappedErrors() []error
```

WrappedErrors implements the errwrap.Wrapper interface to make this return value more useful with the errwrap and go\-multierror libraries.

## type Metadata

Metadata contains information about decoding a structure that is tedious or difficult to get otherwise.

```go
type Metadata struct {
    // Keys are the keys of the structure which were successfully decoded
    Keys []string

    // Unused is a slice of keys that were found in the raw value but
    // weren't decoded since there was no matching field in the result interface
    Unused []string

    // Unset is a slice of field names that were found in the result interface
    // but weren't set in the decoding process since there was no matching value
    // in the input
    Unset []string
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
