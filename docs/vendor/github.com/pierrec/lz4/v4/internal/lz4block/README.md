<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# lz4block

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/pierrec/lz4/v4/internal/lz4block"
```

Package lz4block provides LZ4 BlockSize types and pools of buffers.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func CompressBlock(src, dst []byte) (int, error)](<#func-compressblock>)
- [func CompressBlockBound(n int) int](<#func-compressblockbound>)
- [func CompressBlockHC(src, dst []byte, depth CompressionLevel) (int, error)](<#func-compressblockhc>)
- [func IsValid(b uint32) bool](<#func-isvalid>)
- [func Put(buf []byte)](<#func-put>)
- [func UncompressBlock(src, dst, dict []byte) (int, error)](<#func-uncompressblock>)
- [type BlockSizeIndex](<#type-blocksizeindex>)
  - [func Index(b uint32) BlockSizeIndex](<#func-index>)
  - [func (b BlockSizeIndex) Get() []byte](<#func-blocksizeindex-get>)
  - [func (b BlockSizeIndex) IsValid() bool](<#func-blocksizeindex-isvalid>)
- [type CompressionLevel](<#type-compressionlevel>)
- [type Compressor](<#type-compressor>)
  - [func (c *Compressor) CompressBlock(src, dst []byte) (int, error)](<#func-compressor-compressblock>)
- [type CompressorHC](<#type-compressorhc>)
  - [func (c *CompressorHC) CompressBlock(src, dst []byte, depth CompressionLevel) (_ int, err error)](<#func-compressorhc-compressblock>)


## Constants

```go
const (
    Block64Kb uint32 = 1 << (16 + iota*2)
    Block256Kb
    Block1Mb
    Block4Mb
)
```

## Variables

```go
var (
    BlockPool64K  = sync.Pool{New: func() interface{} { return make([]byte, Block64Kb) }}
    BlockPool256K = sync.Pool{New: func() interface{} { return make([]byte, Block256Kb) }}
    BlockPool1M   = sync.Pool{New: func() interface{} { return make([]byte, Block1Mb) }}
    BlockPool4M   = sync.Pool{New: func() interface{} { return make([]byte, Block4Mb) }}
    BlockPool8M   = sync.Pool{New: func() interface{} { return make([]byte, Block8Mb) }}
)
```

In legacy mode all blocks are compressed regardless of the compressed size: use the bound size.

```go
var Block8Mb = uint32(CompressBlockBound(8 << 20))
```

## func CompressBlock

```go
func CompressBlock(src, dst []byte) (int, error)
```

## func CompressBlockBound

```go
func CompressBlockBound(n int) int
```

## func CompressBlockHC

```go
func CompressBlockHC(src, dst []byte, depth CompressionLevel) (int, error)
```

## func IsValid

```go
func IsValid(b uint32) bool
```

## func Put

```go
func Put(buf []byte)
```

## func UncompressBlock

```go
func UncompressBlock(src, dst, dict []byte) (int, error)
```

## type BlockSizeIndex

```go
type BlockSizeIndex uint8
```

### func Index

```go
func Index(b uint32) BlockSizeIndex
```

### func \(BlockSizeIndex\) Get

```go
func (b BlockSizeIndex) Get() []byte
```

### func \(BlockSizeIndex\) IsValid

```go
func (b BlockSizeIndex) IsValid() bool
```

## type CompressionLevel

```go
type CompressionLevel uint32
```

```go
const Fast CompressionLevel = 0
```

## type Compressor

```go
type Compressor struct {
    // contains filtered or unexported fields
}
```

### func \(\*Compressor\) CompressBlock

```go
func (c *Compressor) CompressBlock(src, dst []byte) (int, error)
```

## type CompressorHC

```go
type CompressorHC struct {
    // contains filtered or unexported fields
}
```

### func \(\*CompressorHC\) CompressBlock

```go
func (c *CompressorHC) CompressBlock(src, dst []byte, depth CompressionLevel) (_ int, err error)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
