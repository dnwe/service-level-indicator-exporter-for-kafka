<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# mux

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/gorilla/mux"
```

Package mux implements a request router and dispatcher.

The name mux stands for "HTTP request multiplexer". Like the standard http.ServeMux, mux.Router matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:

```
* Requests can be matched based on URL host, path, path prefix, schemes,
  header and query values, HTTP methods or using custom matchers.
* URL hosts, paths and query values can have variables with an optional
  regular expression.
* Registered URLs can be built, or "reversed", which helps maintaining
  references to resources.
* Routes can be used as subrouters: nested routes are only tested if the
  parent route matches. This is useful to define groups of routes that
  share common conditions like a host, a path prefix or other repeated
  attributes. As a bonus, this optimizes request matching.
* It implements the http.Handler interface so it is compatible with the
  standard http.ServeMux.
```

Let's start registering a couple of URL paths and handlers:

```
func main() {
	r := mux.NewRouter()
	r.HandleFunc("/", HomeHandler)
	r.HandleFunc("/products", ProductsHandler)
	r.HandleFunc("/articles", ArticlesHandler)
	http.Handle("/", r)
}
```

Here we register three routes mapping URL paths to handlers. This is equivalent to how http.HandleFunc\(\) works: if an incoming request URL matches one of the paths, the corresponding handler is called passing \(http.ResponseWriter, \*http.Request\) as parameters.

Paths can have variables. They are defined using the format \{name\} or \{name:pattern\}. If a regular expression pattern is not defined, the matched variable will be anything until the next slash. For example:

```
r := mux.NewRouter()
r.HandleFunc("/products/{key}", ProductHandler)
r.HandleFunc("/articles/{category}/", ArticlesCategoryHandler)
r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler)
```

Groups can be used inside patterns, as long as they are non\-capturing \(?:re\). For example:

```
r.HandleFunc("/articles/{category}/{sort:(?:asc|desc|new)}", ArticlesCategoryHandler)
```

The names are used to create a map of route variables which can be retrieved calling mux.Vars\(\):

```
vars := mux.Vars(request)
category := vars["category"]
```

Note that if any capturing groups are present, mux will panic\(\) during parsing. To prevent this, convert any capturing groups to non\-capturing, e.g. change "/\{sort:\(asc|desc\)\}" to "/\{sort:\(?:asc|desc\)\}". This is a change from prior versions which behaved unpredictably when capturing groups were present.

And this is all you need to know about the basic usage. More advanced options are explained below.

Routes can also be restricted to a domain or subdomain. Just define a host pattern to be matched. They can also have variables:

```
r := mux.NewRouter()
// Only matches if domain is "www.example.com".
r.Host("www.example.com")
// Matches a dynamic subdomain.
r.Host("{subdomain:[a-z]+}.domain.com")
```

There are several other matchers that can be added. To match path prefixes:

```
r.PathPrefix("/products/")
```

...or HTTP methods:

```
r.Methods("GET", "POST")
```

...or URL schemes:

```
r.Schemes("https")
```

...or header values:

```
r.Headers("X-Requested-With", "XMLHttpRequest")
```

...or query values:

```
r.Queries("key", "value")
```

...or to use a custom matcher function:

```
r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
	return r.ProtoMajor == 0
})
```

...and finally, it is possible to combine several matchers in a single route:

```
r.HandleFunc("/products", ProductsHandler).
  Host("www.example.com").
  Methods("GET").
  Schemes("http")
```

Setting the same matching conditions again and again can be boring, so we have a way to group several routes that share the same requirements. We call it "subrouting".

For example, let's say we have several URLs that should only match when the host is "www.example.com". Create a route for that host and get a "subrouter" from it:

```
r := mux.NewRouter()
s := r.Host("www.example.com").Subrouter()
```

Then register routes in the subrouter:

```
s.HandleFunc("/products/", ProductsHandler)
s.HandleFunc("/products/{key}", ProductHandler)
s.HandleFunc("/articles/{category}/{id:[0-9]+}"), ArticleHandler)
```

The three URL paths we registered above will only be tested if the domain is "www.example.com", because the subrouter is tested first. This is not only convenient, but also optimizes request matching. You can create subrouters combining any attribute matchers accepted by a route.

Subrouters can be used to create domain or path "namespaces": you define subrouters in a central place and then parts of the app can register its paths relatively to a given subrouter.

There's one more thing about subroutes. When a subrouter has a path prefix, the inner routes use it as base for their paths:

```
r := mux.NewRouter()
s := r.PathPrefix("/products").Subrouter()
// "/products/"
s.HandleFunc("/", ProductsHandler)
// "/products/{key}/"
s.HandleFunc("/{key}/", ProductHandler)
// "/products/{key}/details"
s.HandleFunc("/{key}/details", ProductDetailsHandler)
```

Note that the path provided to PathPrefix\(\) represents a "wildcard": calling PathPrefix\("/static/"\).Handler\(...\) means that the handler will be passed any request that matches "/static/\*". This makes it easy to serve static files with mux:

```
func main() {
	var dir string

	flag.StringVar(&dir, "dir", ".", "the directory to serve files from. Defaults to the current dir")
	flag.Parse()
	r := mux.NewRouter()

	// This will serve files under http://localhost:8000/static/<filename>
	r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", http.FileServer(http.Dir(dir))))

	srv := &http.Server{
		Handler:      r,
		Addr:         "127.0.0.1:8000",
		// Good practice: enforce timeouts for servers you create!
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	log.Fatal(srv.ListenAndServe())
}
```

Now let's see how to build registered URLs.

Routes can be named. All routes that define a name can have their URLs built, or "reversed". We define a name calling Name\(\) on a route. For example:

```
r := mux.NewRouter()
r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
  Name("article")
```

To build a URL, get the route and call the URL\(\) method, passing a sequence of key/value pairs for the route variables. For the previous route, we would do:

```
url, err := r.Get("article").URL("category", "technology", "id", "42")
```

...and the result will be a url.URL with the following path:

```
"/articles/technology/42"
```

This also works for host and query value variables:

```
r := mux.NewRouter()
r.Host("{subdomain}.domain.com").
  Path("/articles/{category}/{id:[0-9]+}").
  Queries("filter", "{filter}").
  HandlerFunc(ArticleHandler).
  Name("article")

// url.String() will be "http://news.domain.com/articles/technology/42?filter=gorilla"
url, err := r.Get("article").URL("subdomain", "news",
                                 "category", "technology",
                                 "id", "42",
                                 "filter", "gorilla")
```

All variables defined in the route are required, and their values must conform to the corresponding patterns. These requirements guarantee that a generated URL will always match a registered route \-\- the only exception is for explicitly defined "build\-only" routes which never match.

Regex support also exists for matching Headers within a route. For example, we could do:

```
r.HeadersRegexp("Content-Type", "application/(text|json)")
```

...and the route will match both requests with a Content\-Type of \`application/json\` as well as \`application/text\`

There's also a way to build only the URL host or path for a route: use the methods URLHost\(\) or URLPath\(\) instead. For the previous route, we would do:

```
// "http://news.domain.com/"
host, err := r.Get("article").URLHost("subdomain", "news")

// "/articles/technology/42"
path, err := r.Get("article").URLPath("category", "technology", "id", "42")
```

And if you use subrouters, host and path defined separately can be built as well:

```
r := mux.NewRouter()
s := r.Host("{subdomain}.domain.com").Subrouter()
s.Path("/articles/{category}/{id:[0-9]+}").
  HandlerFunc(ArticleHandler).
  Name("article")

// "http://news.domain.com/articles/technology/42"
url, err := r.Get("article").URL("subdomain", "news",
                                 "category", "technology",
                                 "id", "42")
```

Mux supports the addition of middlewares to a Router, which are executed in the order they are added if a match is found, including its subrouters. Middlewares are \(typically\) small pieces of code which take one request, do something with it, and pass it down to another middleware or the final handler. Some common use cases for middleware are request logging, header manipulation, or ResponseWriter hijacking.

```
type MiddlewareFunc func(http.Handler) http.Handler
```

Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed to it, and then calls the handler passed as parameter to the MiddlewareFunc \(closures can access variables from the context where they are created\).

A very basic middleware which logs the URI of the request being handled could be written as:

```
func simpleMw(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Do stuff here
		log.Println(r.RequestURI)
		// Call the next handler, which can be another middleware in the chain, or the final handler.
		next.ServeHTTP(w, r)
	})
}
```

Middlewares can be added to a router using \`Router.Use\(\)\`:

```
r := mux.NewRouter()
r.HandleFunc("/", handler)
r.Use(simpleMw)
```

A more complex authentication middleware, which maps session token to users, could be written as:

```
// Define our struct
type authenticationMiddleware struct {
	tokenUsers map[string]string
}

// Initialize it somewhere
func (amw *authenticationMiddleware) Populate() {
	amw.tokenUsers["00000000"] = "user0"
	amw.tokenUsers["aaaaaaaa"] = "userA"
	amw.tokenUsers["05f717e5"] = "randomUser"
	amw.tokenUsers["deadbeef"] = "user0"
}

// Middleware function, which will be called for each request
func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("X-Session-Token")

		if user, found := amw.tokenUsers[token]; found {
			// We found the token in our map
			log.Printf("Authenticated user %s\n", user)
			next.ServeHTTP(w, r)
		} else {
			http.Error(w, "Forbidden", http.StatusForbidden)
		}
	})
}

r := mux.NewRouter()
r.HandleFunc("/", handler)

amw := authenticationMiddleware{tokenUsers: make(map[string]string)}
amw.Populate()

r.Use(amw.Middleware)
```

Note: The handler chain will be stopped if your middleware doesn't call \`next.ServeHTTP\(\)\` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to.

## Index

- [Variables](<#variables>)
- [func SetURLVars(r *http.Request, val map[string]string) *http.Request](<#func-seturlvars>)
- [func Vars(r *http.Request) map[string]string](<#func-vars>)
- [type BuildVarsFunc](<#type-buildvarsfunc>)
- [type MatcherFunc](<#type-matcherfunc>)
  - [func (m MatcherFunc) Match(r *http.Request, match *RouteMatch) bool](<#func-matcherfunc-match>)
- [type MiddlewareFunc](<#type-middlewarefunc>)
  - [func CORSMethodMiddleware(r *Router) MiddlewareFunc](<#func-corsmethodmiddleware>)
  - [func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler](<#func-middlewarefunc-middleware>)
- [type Route](<#type-route>)
  - [func CurrentRoute(r *http.Request) *Route](<#func-currentroute>)
  - [func (r *Route) BuildOnly() *Route](<#func-route-buildonly>)
  - [func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route](<#func-route-buildvarsfunc>)
  - [func (r *Route) GetError() error](<#func-route-geterror>)
  - [func (r *Route) GetHandler() http.Handler](<#func-route-gethandler>)
  - [func (r *Route) GetHostTemplate() (string, error)](<#func-route-gethosttemplate>)
  - [func (r *Route) GetMethods() ([]string, error)](<#func-route-getmethods>)
  - [func (r *Route) GetName() string](<#func-route-getname>)
  - [func (r *Route) GetPathRegexp() (string, error)](<#func-route-getpathregexp>)
  - [func (r *Route) GetPathTemplate() (string, error)](<#func-route-getpathtemplate>)
  - [func (r *Route) GetQueriesRegexp() ([]string, error)](<#func-route-getqueriesregexp>)
  - [func (r *Route) GetQueriesTemplates() ([]string, error)](<#func-route-getqueriestemplates>)
  - [func (r *Route) Handler(handler http.Handler) *Route](<#func-route-handler>)
  - [func (r *Route) HandlerFunc(f func(http.ResponseWriter, *http.Request)) *Route](<#func-route-handlerfunc>)
  - [func (r *Route) Headers(pairs ...string) *Route](<#func-route-headers>)
  - [func (r *Route) HeadersRegexp(pairs ...string) *Route](<#func-route-headersregexp>)
  - [func (r *Route) Host(tpl string) *Route](<#func-route-host>)
  - [func (r *Route) Match(req *http.Request, match *RouteMatch) bool](<#func-route-match>)
  - [func (r *Route) MatcherFunc(f MatcherFunc) *Route](<#func-route-matcherfunc>)
  - [func (r *Route) Methods(methods ...string) *Route](<#func-route-methods>)
  - [func (r *Route) Name(name string) *Route](<#func-route-name>)
  - [func (r *Route) Path(tpl string) *Route](<#func-route-path>)
  - [func (r *Route) PathPrefix(tpl string) *Route](<#func-route-pathprefix>)
  - [func (r *Route) Queries(pairs ...string) *Route](<#func-route-queries>)
  - [func (r *Route) Schemes(schemes ...string) *Route](<#func-route-schemes>)
  - [func (r *Route) SkipClean() bool](<#func-route-skipclean>)
  - [func (r *Route) Subrouter() *Router](<#func-route-subrouter>)
  - [func (r *Route) URL(pairs ...string) (*url.URL, error)](<#func-route-url>)
  - [func (r *Route) URLHost(pairs ...string) (*url.URL, error)](<#func-route-urlhost>)
  - [func (r *Route) URLPath(pairs ...string) (*url.URL, error)](<#func-route-urlpath>)
- [type RouteMatch](<#type-routematch>)
- [type Router](<#type-router>)
  - [func NewRouter() *Router](<#func-newrouter>)
  - [func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route](<#func-router-buildvarsfunc>)
  - [func (r *Router) Get(name string) *Route](<#func-router-get>)
  - [func (r *Router) GetRoute(name string) *Route](<#func-router-getroute>)
  - [func (r *Router) Handle(path string, handler http.Handler) *Route](<#func-router-handle>)
  - [func (r *Router) HandleFunc(path string, f func(http.ResponseWriter, *http.Request)) *Route](<#func-router-handlefunc>)
  - [func (r *Router) Headers(pairs ...string) *Route](<#func-router-headers>)
  - [func (r *Router) Host(tpl string) *Route](<#func-router-host>)
  - [func (r *Router) Match(req *http.Request, match *RouteMatch) bool](<#func-router-match>)
  - [func (r *Router) MatcherFunc(f MatcherFunc) *Route](<#func-router-matcherfunc>)
  - [func (r *Router) Methods(methods ...string) *Route](<#func-router-methods>)
  - [func (r *Router) Name(name string) *Route](<#func-router-name>)
  - [func (r *Router) NewRoute() *Route](<#func-router-newroute>)
  - [func (r *Router) Path(tpl string) *Route](<#func-router-path>)
  - [func (r *Router) PathPrefix(tpl string) *Route](<#func-router-pathprefix>)
  - [func (r *Router) Queries(pairs ...string) *Route](<#func-router-queries>)
  - [func (r *Router) Schemes(schemes ...string) *Route](<#func-router-schemes>)
  - [func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request)](<#func-router-servehttp>)
  - [func (r *Router) SkipClean(value bool) *Router](<#func-router-skipclean>)
  - [func (r *Router) StrictSlash(value bool) *Router](<#func-router-strictslash>)
  - [func (r *Router) Use(mwf ...MiddlewareFunc)](<#func-router-use>)
  - [func (r *Router) UseEncodedPath() *Router](<#func-router-useencodedpath>)
  - [func (r *Router) Walk(walkFn WalkFunc) error](<#func-router-walk>)
- [type WalkFunc](<#type-walkfunc>)


## Variables

```go
var (
    // ErrMethodMismatch is returned when the method in the request does not match
    // the method defined against the route.
    ErrMethodMismatch = errors.New("method is not allowed")
    // ErrNotFound is returned when no route match is found.
    ErrNotFound = errors.New("no matching route was found")
)
```

SkipRouter is used as a return value from WalkFuncs to indicate that the router that walk is about to descend down to should be skipped.

```go
var SkipRouter = errors.New("skip this router")
```

## func SetURLVars

```go
func SetURLVars(r *http.Request, val map[string]string) *http.Request
```

SetURLVars sets the URL variables for the given request, to be accessed via mux.Vars for testing route behaviour. Arguments are not modified, a shallow copy is returned.

This API should only be used for testing purposes; it provides a way to inject variables into the request context. Alternatively, URL variables can be set by making a route that captures the required variables, starting a server and sending the request to that server.

## func Vars

```go
func Vars(r *http.Request) map[string]string
```

Vars returns the route variables for the current request, if any.

## type BuildVarsFunc

BuildVarsFunc is the function signature used by custom build variable functions \(which can modify route variables before a route's URL is built\).

```go
type BuildVarsFunc func(map[string]string) map[string]string
```

## type MatcherFunc

MatcherFunc is the function signature used by custom matchers.

```go
type MatcherFunc func(*http.Request, *RouteMatch) bool
```

### func \(MatcherFunc\) Match

```go
func (m MatcherFunc) Match(r *http.Request, match *RouteMatch) bool
```

Match returns the match for a given request.

## type MiddlewareFunc

MiddlewareFunc is a function which receives an http.Handler and returns another http.Handler. Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed to it, and then calls the handler passed as parameter to the MiddlewareFunc.

```go
type MiddlewareFunc func(http.Handler) http.Handler
```

### func CORSMethodMiddleware

```go
func CORSMethodMiddleware(r *Router) MiddlewareFunc
```

CORSMethodMiddleware automatically sets the Access\-Control\-Allow\-Methods response header on requests for routes that have an OPTIONS method matcher to all the method matchers on the route. Routes that do not explicitly handle OPTIONS requests will not be processed by the middleware. See examples for usage.

### func \(MiddlewareFunc\) Middleware

```go
func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler
```

Middleware allows MiddlewareFunc to implement the middleware interface.

## type Route

Route stores information to match a request and build URLs.

```go
type Route struct {
    // contains filtered or unexported fields
}
```

### func CurrentRoute

```go
func CurrentRoute(r *http.Request) *Route
```

CurrentRoute returns the matched route for the current request, if any. This only works when called inside the handler of the matched route because the matched route is stored in the request context which is cleared after the handler returns.

### func \(\*Route\) BuildOnly

```go
func (r *Route) BuildOnly() *Route
```

BuildOnly sets the route to never match: it is only used to build URLs.

### func \(\*Route\) BuildVarsFunc

```go
func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route
```

BuildVarsFunc adds a custom function to be used to modify build variables before a route's URL is built.

### func \(\*Route\) GetError

```go
func (r *Route) GetError() error
```

GetError returns an error resulted from building the route, if any.

### func \(\*Route\) GetHandler

```go
func (r *Route) GetHandler() http.Handler
```

GetHandler returns the handler for the route, if any.

### func \(\*Route\) GetHostTemplate

```go
func (r *Route) GetHostTemplate() (string, error)
```

GetHostTemplate returns the template used to build the route match. This is useful for building simple REST API documentation and for instrumentation against third\-party services. An error will be returned if the route does not define a host.

### func \(\*Route\) GetMethods

```go
func (r *Route) GetMethods() ([]string, error)
```

GetMethods returns the methods the route matches against This is useful for building simple REST API documentation and for instrumentation against third\-party services. An error will be returned if route does not have methods.

### func \(\*Route\) GetName

```go
func (r *Route) GetName() string
```

GetName returns the name for the route, if any.

### func \(\*Route\) GetPathRegexp

```go
func (r *Route) GetPathRegexp() (string, error)
```

GetPathRegexp returns the expanded regular expression used to match route path. This is useful for building simple REST API documentation and for instrumentation against third\-party services. An error will be returned if the route does not define a path.

### func \(\*Route\) GetPathTemplate

```go
func (r *Route) GetPathTemplate() (string, error)
```

GetPathTemplate returns the template used to build the route match. This is useful for building simple REST API documentation and for instrumentation against third\-party services. An error will be returned if the route does not define a path.

### func \(\*Route\) GetQueriesRegexp

```go
func (r *Route) GetQueriesRegexp() ([]string, error)
```

GetQueriesRegexp returns the expanded regular expressions used to match the route queries. This is useful for building simple REST API documentation and for instrumentation against third\-party services. An error will be returned if the route does not have queries.

### func \(\*Route\) GetQueriesTemplates

```go
func (r *Route) GetQueriesTemplates() ([]string, error)
```

GetQueriesTemplates returns the templates used to build the query matching. This is useful for building simple REST API documentation and for instrumentation against third\-party services. An error will be returned if the route does not define queries.

### func \(\*Route\) Handler

```go
func (r *Route) Handler(handler http.Handler) *Route
```

Handler sets a handler for the route.

### func \(\*Route\) HandlerFunc

```go
func (r *Route) HandlerFunc(f func(http.ResponseWriter, *http.Request)) *Route
```

HandlerFunc sets a handler function for the route.

### func \(\*Route\) Headers

```go
func (r *Route) Headers(pairs ...string) *Route
```

Headers adds a matcher for request header values. It accepts a sequence of key/value pairs to be matched. For example:

```
r := mux.NewRouter()
r.Headers("Content-Type", "application/json",
          "X-Requested-With", "XMLHttpRequest")
```

The above route will only match if both request header values match. If the value is an empty string, it will match any value if the key is set.

### func \(\*Route\) HeadersRegexp

```go
func (r *Route) HeadersRegexp(pairs ...string) *Route
```

HeadersRegexp accepts a sequence of key/value pairs, where the value has regex support. For example:

```
r := mux.NewRouter()
r.HeadersRegexp("Content-Type", "application/(text|json)",
          "X-Requested-With", "XMLHttpRequest")
```

The above route will only match if both the request header matches both regular expressions. If the value is an empty string, it will match any value if the key is set. Use the start and end of string anchors \(^ and $\) to match an exact value.

### func \(\*Route\) Host

```go
func (r *Route) Host(tpl string) *Route
```

Host adds a matcher for the URL host. It accepts a template with zero or more URL variables enclosed by \{\}. Variables can define an optional regexp pattern to be matched:

\- \{name\} matches anything until the next dot.

\- \{name:pattern\} matches the given regexp pattern.

For example:

```
r := mux.NewRouter()
r.Host("www.example.com")
r.Host("{subdomain}.domain.com")
r.Host("{subdomain:[a-z]+}.domain.com")
```

Variable names must be unique in a given route. They can be retrieved calling mux.Vars\(request\).

### func \(\*Route\) Match

```go
func (r *Route) Match(req *http.Request, match *RouteMatch) bool
```

Match matches the route against the request.

### func \(\*Route\) MatcherFunc

```go
func (r *Route) MatcherFunc(f MatcherFunc) *Route
```

MatcherFunc adds a custom function to be used as request matcher.

### func \(\*Route\) Methods

```go
func (r *Route) Methods(methods ...string) *Route
```

Methods adds a matcher for HTTP methods. It accepts a sequence of one or more methods to be matched, e.g.: "GET", "POST", "PUT".

### func \(\*Route\) Name

```go
func (r *Route) Name(name string) *Route
```

Name sets the name for the route, used to build URLs. It is an error to call Name more than once on a route.

### func \(\*Route\) Path

```go
func (r *Route) Path(tpl string) *Route
```

Path adds a matcher for the URL path. It accepts a template with zero or more URL variables enclosed by \{\}. The template must start with a "/". Variables can define an optional regexp pattern to be matched:

\- \{name\} matches anything until the next slash.

\- \{name:pattern\} matches the given regexp pattern.

For example:

```
r := mux.NewRouter()
r.Path("/products/").Handler(ProductsHandler)
r.Path("/products/{key}").Handler(ProductsHandler)
r.Path("/articles/{category}/{id:[0-9]+}").
  Handler(ArticleHandler)
```

Variable names must be unique in a given route. They can be retrieved calling mux.Vars\(request\).

### func \(\*Route\) PathPrefix

```go
func (r *Route) PathPrefix(tpl string) *Route
```

PathPrefix adds a matcher for the URL path prefix. This matches if the given template is a prefix of the full URL path. See Route.Path\(\) for details on the tpl argument.

Note that it does not treat slashes specially \("/foobar/" will be matched by the prefix "/foo"\) so you may want to use a trailing slash here.

Also note that the setting of Router.StrictSlash\(\) has no effect on routes with a PathPrefix matcher.

### func \(\*Route\) Queries

```go
func (r *Route) Queries(pairs ...string) *Route
```

Queries adds a matcher for URL query values. It accepts a sequence of key/value pairs. Values may define variables. For example:

```
r := mux.NewRouter()
r.Queries("foo", "bar", "id", "{id:[0-9]+}")
```

The above route will only match if the URL contains the defined queries values, e.g.: ?foo=bar&id=42.

If the value is an empty string, it will match any value if the key is set.

Variables can define an optional regexp pattern to be matched:

\- \{name\} matches anything until the next slash.

\- \{name:pattern\} matches the given regexp pattern.

### func \(\*Route\) Schemes

```go
func (r *Route) Schemes(schemes ...string) *Route
```

Schemes adds a matcher for URL schemes. It accepts a sequence of schemes to be matched, e.g.: "http", "https". If the request's URL has a scheme set, it will be matched against. Generally, the URL scheme will only be set if a previous handler set it, such as the ProxyHeaders handler from gorilla/handlers. If unset, the scheme will be determined based on the request's TLS termination state. The first argument to Schemes will be used when constructing a route URL.

### func \(\*Route\) SkipClean

```go
func (r *Route) SkipClean() bool
```

SkipClean reports whether path cleaning is enabled for this route via Router.SkipClean.

### func \(\*Route\) Subrouter

```go
func (r *Route) Subrouter() *Router
```

Subrouter creates a subrouter for the route.

It will test the inner routes only if the parent route matched. For example:

```
r := mux.NewRouter()
s := r.Host("www.example.com").Subrouter()
s.HandleFunc("/products/", ProductsHandler)
s.HandleFunc("/products/{key}", ProductHandler)
s.HandleFunc("/articles/{category}/{id:[0-9]+}"), ArticleHandler)
```

Here, the routes registered in the subrouter won't be tested if the host doesn't match.

### func \(\*Route\) URL

```go
func (r *Route) URL(pairs ...string) (*url.URL, error)
```

URL builds a URL for the route.

It accepts a sequence of key/value pairs for the route variables. For example, given this route:

```
r := mux.NewRouter()
r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
  Name("article")
```

...a URL for it can be built using:

```
url, err := r.Get("article").URL("category", "technology", "id", "42")
```

...which will return an url.URL with the following path:

```
"/articles/technology/42"
```

This also works for host variables:

```
r := mux.NewRouter()
r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
  Host("{subdomain}.domain.com").
  Name("article")

// url.String() will be "http://news.domain.com/articles/technology/42"
url, err := r.Get("article").URL("subdomain", "news",
                                 "category", "technology",
                                 "id", "42")
```

The scheme of the resulting url will be the first argument that was passed to Schemes:

```
// url.String() will be "https://example.com"
r := mux.NewRouter()
url, err := r.Host("example.com")
             .Schemes("https", "http").URL()
```

All variables defined in the route are required, and their values must conform to the corresponding patterns.

### func \(\*Route\) URLHost

```go
func (r *Route) URLHost(pairs ...string) (*url.URL, error)
```

URLHost builds the host part of the URL for a route. See Route.URL\(\).

The route must have a host defined.

### func \(\*Route\) URLPath

```go
func (r *Route) URLPath(pairs ...string) (*url.URL, error)
```

URLPath builds the path part of the URL for a route. See Route.URL\(\).

The route must have a path defined.

## type RouteMatch

RouteMatch stores information about a matched route.

```go
type RouteMatch struct {
    Route   *Route
    Handler http.Handler
    Vars    map[string]string

    // MatchErr is set to appropriate matching error
    // It is set to ErrMethodMismatch if there is a mismatch in
    // the request method and route method
    MatchErr error
}
```

## type Router

Router registers routes to be matched and dispatches a handler.

It implements the http.Handler interface, so it can be registered to serve requests:

```
var router = mux.NewRouter()

func main() {
    http.Handle("/", router)
}
```

Or, for Google App Engine, register it in a init\(\) function:

```
func init() {
    http.Handle("/", router)
}
```

This will send all incoming requests to the router.

```go
type Router struct {
    // Configurable Handler to be used when no route matches.
    NotFoundHandler http.Handler

    // Configurable Handler to be used when the request method does not match the route.
    MethodNotAllowedHandler http.Handler

    // If true, do not clear the request context after handling the request.
    //
    // Deprecated: No effect, since the context is stored on the request itself.
    KeepContext bool
    // contains filtered or unexported fields
}
```

### func NewRouter

```go
func NewRouter() *Router
```

NewRouter returns a new router instance.

### func \(\*Router\) BuildVarsFunc

```go
func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route
```

BuildVarsFunc registers a new route with a custom function for modifying route variables before building a URL.

### func \(\*Router\) Get

```go
func (r *Router) Get(name string) *Route
```

Get returns a route registered with the given name.

### func \(\*Router\) GetRoute

```go
func (r *Router) GetRoute(name string) *Route
```

GetRoute returns a route registered with the given name. This method was renamed to Get\(\) and remains here for backwards compatibility.

### func \(\*Router\) Handle

```go
func (r *Router) Handle(path string, handler http.Handler) *Route
```

Handle registers a new route with a matcher for the URL path. See Route.Path\(\) and Route.Handler\(\).

### func \(\*Router\) HandleFunc

```go
func (r *Router) HandleFunc(path string, f func(http.ResponseWriter, *http.Request)) *Route
```

HandleFunc registers a new route with a matcher for the URL path. See Route.Path\(\) and Route.HandlerFunc\(\).

### func \(\*Router\) Headers

```go
func (r *Router) Headers(pairs ...string) *Route
```

Headers registers a new route with a matcher for request header values. See Route.Headers\(\).

### func \(\*Router\) Host

```go
func (r *Router) Host(tpl string) *Route
```

Host registers a new route with a matcher for the URL host. See Route.Host\(\).

### func \(\*Router\) Match

```go
func (r *Router) Match(req *http.Request, match *RouteMatch) bool
```

Match attempts to match the given request against the router's registered routes.

If the request matches a route of this router or one of its subrouters the Route, Handler, and Vars fields of the the match argument are filled and this function returns true.

If the request does not match any of this router's or its subrouters' routes then this function returns false. If available, a reason for the match failure will be filled in the match argument's MatchErr field. If the match failure type \(eg: not found\) has a registered handler, the handler is assigned to the Handler field of the match argument.

### func \(\*Router\) MatcherFunc

```go
func (r *Router) MatcherFunc(f MatcherFunc) *Route
```

MatcherFunc registers a new route with a custom matcher function. See Route.MatcherFunc\(\).

### func \(\*Router\) Methods

```go
func (r *Router) Methods(methods ...string) *Route
```

Methods registers a new route with a matcher for HTTP methods. See Route.Methods\(\).

### func \(\*Router\) Name

```go
func (r *Router) Name(name string) *Route
```

Name registers a new route with a name. See Route.Name\(\).

### func \(\*Router\) NewRoute

```go
func (r *Router) NewRoute() *Route
```

NewRoute registers an empty route.

### func \(\*Router\) Path

```go
func (r *Router) Path(tpl string) *Route
```

Path registers a new route with a matcher for the URL path. See Route.Path\(\).

### func \(\*Router\) PathPrefix

```go
func (r *Router) PathPrefix(tpl string) *Route
```

PathPrefix registers a new route with a matcher for the URL path prefix. See Route.PathPrefix\(\).

### func \(\*Router\) Queries

```go
func (r *Router) Queries(pairs ...string) *Route
```

Queries registers a new route with a matcher for URL query values. See Route.Queries\(\).

### func \(\*Router\) Schemes

```go
func (r *Router) Schemes(schemes ...string) *Route
```

Schemes registers a new route with a matcher for URL schemes. See Route.Schemes\(\).

### func \(\*Router\) ServeHTTP

```go
func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request)
```

ServeHTTP dispatches the handler registered in the matched route.

When there is a match, the route variables can be retrieved calling mux.Vars\(request\).

### func \(\*Router\) SkipClean

```go
func (r *Router) SkipClean(value bool) *Router
```

SkipClean defines the path cleaning behaviour for new routes. The initial value is false. Users should be careful about which routes are not cleaned

When true, if the route path is "/path//to", it will remain with the double slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/

When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will become /fetch/http/xkcd.com/534

### func \(\*Router\) StrictSlash

```go
func (r *Router) StrictSlash(value bool) *Router
```

StrictSlash defines the trailing slash behavior for new routes. The initial value is false.

When true, if the route path is "/path/", accessing "/path" will perform a redirect to the former and vice versa. In other words, your application will always see the path as specified in the route.

When false, if the route path is "/path", accessing "/path/" will not match this route and vice versa.

The re\-direct is a HTTP 301 \(Moved Permanently\). Note that when this is set for routes with a non\-idempotent method \(e.g. POST, PUT\), the subsequent re\-directed request will be made as a GET by most clients. Use middleware or client settings to modify this behaviour as needed.

Special case: when a route sets a path prefix using the PathPrefix\(\) method, strict slash is ignored for that route because the redirect behavior can't be determined from a prefix alone. However, any subrouters created from that route inherit the original StrictSlash setting.

### func \(\*Router\) Use

```go
func (r *Router) Use(mwf ...MiddlewareFunc)
```

Use appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.

### func \(\*Router\) UseEncodedPath

```go
func (r *Router) UseEncodedPath() *Router
```

UseEncodedPath tells the router to match the encoded original path to the routes. For eg. "/path/foo%2Fbar/to" will match the path "/path/\{var\}/to".

If not called, the router will match the unencoded path to the routes. For eg. "/path/foo%2Fbar/to" will match the path "/path/foo/bar/to"

### func \(\*Router\) Walk

```go
func (r *Router) Walk(walkFn WalkFunc) error
```

Walk walks the router and all its sub\-routers, calling walkFn for each route in the tree. The routes are walked in the order they were added. Sub\-routers are explored depth\-first.

## type WalkFunc

WalkFunc is the type of the function called for each route visited by Walk. At every invocation, it is given the current route, and the current router, and a list of ancestor routes that lead to the current route.

```go
type WalkFunc func(route *Route, router *Router, ancestors []*Route) error
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
