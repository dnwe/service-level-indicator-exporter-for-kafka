<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# locker

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/moby/locker"
```

Package locker provides a mechanism for creating finer\-grained locking to help free up more global locks to handle other tasks.

The implementation looks close to a sync.Mutex, however the user must provide a reference to use to refer to the underlying lock when locking and unlocking, and unlock may generate an error.

If a lock with a given name does not exist when \`Lock\` is called, one is created. Lock references are automatically cleaned up on \`Unlock\` if nothing else is waiting for the lock.

## Index

- [Variables](<#variables>)
- [type Locker](<#type-locker>)
  - [func New() *Locker](<#func-new>)
  - [func (l *Locker) Lock(name string)](<#func-locker-lock>)
  - [func (l *Locker) Unlock(name string) error](<#func-locker-unlock>)


## Variables

ErrNoSuchLock is returned when the requested lock does not exist

```go
var ErrNoSuchLock = errors.New("no such lock")
```

## type Locker

Locker provides a locking mechanism based on the passed in reference name

```go
type Locker struct {
    // contains filtered or unexported fields
}
```

### func New

```go
func New() *Locker
```

New creates a new Locker

### func \(\*Locker\) Lock

```go
func (l *Locker) Lock(name string)
```

Lock locks a mutex with the given name. If it doesn't exist, one is created

### func \(\*Locker\) Unlock

```go
func (l *Locker) Unlock(name string) error
```

Unlock unlocks the mutex with the given name If the given lock is not being waited on by any other callers, it is deleted



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
