<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# flock

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/gofrs/flock"
```

Package flock implements a thread\-safe interface for file locking. It also includes a non\-blocking TryLock\(\) function to allow locking without blocking execution.

Package flock is released under the BSD 3\-Clause License. See the LICENSE file for more details.

While using this library, remember that the locking behaviors are not guaranteed to be the same on each platform. For example, some UNIX\-like operating systems will transparently convert a shared lock to an exclusive lock. If you Unlock\(\) the flock from a location where you believe that you have the shared lock, you may accidentally drop the exclusive lock.

## Index

- [type Flock](<#type-flock>)
  - [func New(path string) *Flock](<#func-new>)
  - [func NewFlock(path string) *Flock](<#func-newflock>)
  - [func (f *Flock) Close() error](<#func-flock-close>)
  - [func (f *Flock) Lock() error](<#func-flock-lock>)
  - [func (f *Flock) Locked() bool](<#func-flock-locked>)
  - [func (f *Flock) Path() string](<#func-flock-path>)
  - [func (f *Flock) RLock() error](<#func-flock-rlock>)
  - [func (f *Flock) RLocked() bool](<#func-flock-rlocked>)
  - [func (f *Flock) String() string](<#func-flock-string>)
  - [func (f *Flock) TryLock() (bool, error)](<#func-flock-trylock>)
  - [func (f *Flock) TryLockContext(ctx context.Context, retryDelay time.Duration) (bool, error)](<#func-flock-trylockcontext>)
  - [func (f *Flock) TryRLock() (bool, error)](<#func-flock-tryrlock>)
  - [func (f *Flock) TryRLockContext(ctx context.Context, retryDelay time.Duration) (bool, error)](<#func-flock-tryrlockcontext>)
  - [func (f *Flock) Unlock() error](<#func-flock-unlock>)


## type Flock

Flock is the struct type to handle file locking. All fields are unexported, with access to some of the fields provided by getter methods \(Path\(\) and Locked\(\)\).

```go
type Flock struct {
    // contains filtered or unexported fields
}
```

### func New

```go
func New(path string) *Flock
```

New returns a new instance of \*Flock. The only parameter it takes is the path to the desired lockfile.

### func NewFlock

```go
func NewFlock(path string) *Flock
```

NewFlock returns a new instance of \*Flock. The only parameter it takes is the path to the desired lockfile.

Deprecated: Use New instead.

### func \(\*Flock\) Close

```go
func (f *Flock) Close() error
```

Close is equivalent to calling Unlock.

This will release the lock and close the underlying file descriptor. It will not remove the file from disk, that's up to your application.

### func \(\*Flock\) Lock

```go
func (f *Flock) Lock() error
```

Lock is a blocking call to try and take an exclusive file lock. It will wait until it is able to obtain the exclusive file lock. It's recommended that TryLock\(\) be used over this function. This function may block the ability to query the current Locked\(\) or RLocked\(\) status due to a RW\-mutex lock.

If we are already exclusive\-locked, this function short\-circuits and returns immediately assuming it can take the mutex lock.

If the \*Flock has a shared lock \(RLock\), this may transparently replace the shared lock with an exclusive lock on some UNIX\-like operating systems. Be careful when using exclusive locks in conjunction with shared locks \(RLock\(\)\), because calling Unlock\(\) may accidentally release the exclusive lock that was once a shared lock.

### func \(\*Flock\) Locked

```go
func (f *Flock) Locked() bool
```

Locked returns the lock state \(locked: true, unlocked: false\).

Warning: by the time you use the returned value, the state may have changed.

### func \(\*Flock\) Path

```go
func (f *Flock) Path() string
```

Path returns the path as provided in NewFlock\(\).

### func \(\*Flock\) RLock

```go
func (f *Flock) RLock() error
```

RLock is a blocking call to try and take a shared file lock. It will wait until it is able to obtain the shared file lock. It's recommended that TryRLock\(\) be used over this function. This function may block the ability to query the current Locked\(\) or RLocked\(\) status due to a RW\-mutex lock.

If we are already shared\-locked, this function short\-circuits and returns immediately assuming it can take the mutex lock.

### func \(\*Flock\) RLocked

```go
func (f *Flock) RLocked() bool
```

RLocked returns the read lock state \(locked: true, unlocked: false\).

Warning: by the time you use the returned value, the state may have changed.

### func \(\*Flock\) String

```go
func (f *Flock) String() string
```

### func \(\*Flock\) TryLock

```go
func (f *Flock) TryLock() (bool, error)
```

TryLock is the preferred function for taking an exclusive file lock. This function takes an RW\-mutex lock before it tries to lock the file, so there is the possibility that this function may block for a short time if another goroutine is trying to take any action.

The actual file lock is non\-blocking. If we are unable to get the exclusive file lock, the function will return false instead of waiting for the lock. If we get the lock, we also set the \*Flock instance as being exclusive\-locked.

### func \(\*Flock\) TryLockContext

```go
func (f *Flock) TryLockContext(ctx context.Context, retryDelay time.Duration) (bool, error)
```

TryLockContext repeatedly tries to take an exclusive lock until one of the conditions is met: TryLock succeeds, TryLock fails with error, or Context Done channel is closed.

### func \(\*Flock\) TryRLock

```go
func (f *Flock) TryRLock() (bool, error)
```

TryRLock is the preferred function for taking a shared file lock. This function takes an RW\-mutex lock before it tries to lock the file, so there is the possibility that this function may block for a short time if another goroutine is trying to take any action.

The actual file lock is non\-blocking. If we are unable to get the shared file lock, the function will return false instead of waiting for the lock. If we get the lock, we also set the \*Flock instance as being share\-locked.

### func \(\*Flock\) TryRLockContext

```go
func (f *Flock) TryRLockContext(ctx context.Context, retryDelay time.Duration) (bool, error)
```

TryRLockContext repeatedly tries to take a shared lock until one of the conditions is met: TryRLock succeeds, TryRLock fails with error, or Context Done channel is closed.

### func \(\*Flock\) Unlock

```go
func (f *Flock) Unlock() error
```

Unlock is a function to unlock the file. This file takes a RW\-mutex lock, so while it is running the Locked\(\) and RLocked\(\) functions will be blocked.

This function short\-circuits if we are unlocked already. If not, it calls syscall.LOCK\_UN on the file and closes the file descriptor. It does not remove the file from disk. It's up to your application to do.

Please note, if your shared lock became an exclusive lock this may unintentionally drop the exclusive lock if called by the consumer that believes they have a shared lock. Please see Lock\(\) for more details.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
