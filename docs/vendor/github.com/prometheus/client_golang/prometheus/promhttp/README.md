<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# promhttp

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/prometheus/client_golang/prometheus/promhttp"
```

Package promhttp provides tooling around HTTP servers and clients.

First, the package allows the creation of http.Handler instances to expose Prometheus metrics via HTTP. promhttp.Handler acts on the prometheus.DefaultGatherer. With HandlerFor, you can create a handler for a custom registry or anything that implements the Gatherer interface. It also allows the creation of handlers that act differently on errors or allow to log errors.

Second, the package provides tooling to instrument instances of http.Handler via middleware. Middleware wrappers follow the naming scheme InstrumentHandlerX, where X describes the intended use of the middleware. See each function's doc comment for specific details.

Finally, the package allows for an http.RoundTripper to be instrumented via middleware. Middleware wrappers follow the naming scheme InstrumentRoundTripperX, where X describes the intended use of the middleware. See each function's doc comment for specific details.

## Index

- [func Handler() http.Handler](<#func-handler>)
- [func HandlerFor(reg prometheus.Gatherer, opts HandlerOpts) http.Handler](<#func-handlerfor>)
- [func HandlerForTransactional(reg prometheus.TransactionalGatherer, opts HandlerOpts) http.Handler](<#func-handlerfortransactional>)
- [func InstrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler, opts ...Option) http.HandlerFunc](<#func-instrumenthandlercounter>)
- [func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc](<#func-instrumenthandlerduration>)
- [func InstrumentHandlerInFlight(g prometheus.Gauge, next http.Handler) http.Handler](<#func-instrumenthandlerinflight>)
- [func InstrumentHandlerRequestSize(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc](<#func-instrumenthandlerrequestsize>)
- [func InstrumentHandlerResponseSize(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.Handler](<#func-instrumenthandlerresponsesize>)
- [func InstrumentHandlerTimeToWriteHeader(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc](<#func-instrumenthandlertimetowriteheader>)
- [func InstrumentMetricHandler(reg prometheus.Registerer, handler http.Handler) http.Handler](<#func-instrumentmetrichandler>)
- [type HandlerErrorHandling](<#type-handlererrorhandling>)
- [type HandlerOpts](<#type-handleropts>)
- [type InstrumentTrace](<#type-instrumenttrace>)
- [type Logger](<#type-logger>)
- [type Option](<#type-option>)
  - [func WithExemplarFromContext(getExemplarFn func(requestCtx context.Context) prometheus.Labels) Option](<#func-withexemplarfromcontext>)
  - [func WithExtraMethods(methods ...string) Option](<#func-withextramethods>)
- [type RoundTripperFunc](<#type-roundtripperfunc>)
  - [func InstrumentRoundTripperCounter(counter *prometheus.CounterVec, next http.RoundTripper, opts ...Option) RoundTripperFunc](<#func-instrumentroundtrippercounter>)
  - [func InstrumentRoundTripperDuration(obs prometheus.ObserverVec, next http.RoundTripper, opts ...Option) RoundTripperFunc](<#func-instrumentroundtripperduration>)
  - [func InstrumentRoundTripperInFlight(gauge prometheus.Gauge, next http.RoundTripper) RoundTripperFunc](<#func-instrumentroundtripperinflight>)
  - [func InstrumentRoundTripperTrace(it *InstrumentTrace, next http.RoundTripper) RoundTripperFunc](<#func-instrumentroundtrippertrace>)
  - [func (rt RoundTripperFunc) RoundTrip(r *http.Request) (*http.Response, error)](<#func-roundtripperfunc-roundtrip>)


## func Handler

```go
func Handler() http.Handler
```

Handler returns an http.Handler for the prometheus.DefaultGatherer, using default HandlerOpts, i.e. it reports the first error as an HTTP error, it has no error logging, and it applies compression if requested by the client.

The returned http.Handler is already instrumented using the InstrumentMetricHandler function and the prometheus.DefaultRegisterer. If you create multiple http.Handlers by separate calls of the Handler function, the metrics used for instrumentation will be shared between them, providing global scrape counts.

This function is meant to cover the bulk of basic use cases. If you are doing anything that requires more customization \(including using a non\-default Gatherer, different instrumentation, and non\-default HandlerOpts\), use the HandlerFor function. See there for details.

## func HandlerFor

```go
func HandlerFor(reg prometheus.Gatherer, opts HandlerOpts) http.Handler
```

HandlerFor returns an uninstrumented http.Handler for the provided Gatherer. The behavior of the Handler is defined by the provided HandlerOpts. Thus, HandlerFor is useful to create http.Handlers for custom Gatherers, with non\-default HandlerOpts, and/or with custom \(or no\) instrumentation. Use the InstrumentMetricHandler function to apply the same kind of instrumentation as it is used by the Handler function.

## func HandlerForTransactional

```go
func HandlerForTransactional(reg prometheus.TransactionalGatherer, opts HandlerOpts) http.Handler
```

HandlerForTransactional is like HandlerFor, but it uses transactional gather, which can safely change in\-place returned \*dto.MetricFamily before call to \`Gather\` and after call to \`done\` of that \`Gather\`.

## func InstrumentHandlerCounter

```go
func InstrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler, opts ...Option) http.HandlerFunc
```

InstrumentHandlerCounter is a middleware that wraps the provided http.Handler to observe the request result with the provided CounterVec. The CounterVec must have valid metric and label names and must have zero, one, or two non\-const non\-curried labels. For those, the only allowed label names are "code" and "method". The function panics otherwise. For the "method" label a predefined default label value set is used to filter given values. Values besides predefined values will count as \`unknown\` method. \`WithExtraMethods\` can be used to add more methods to the set. Partitioning of the CounterVec happens by HTTP status code and/or HTTP method if the respective instance label names are present in the CounterVec. For unpartitioned counting, use a CounterVec with zero labels.

If the wrapped Handler does not set a status code, a status code of 200 is assumed.

If the wrapped Handler panics, the Counter is not incremented.

See the example for InstrumentHandlerDuration for example usage.

## func InstrumentHandlerDuration

```go
func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc
```

InstrumentHandlerDuration is a middleware that wraps the provided http.Handler to observe the request duration with the provided ObserverVec. The ObserverVec must have valid metric and label names and must have zero, one, or two non\-const non\-curried labels. For those, the only allowed label names are "code" and "method". The function panics otherwise. For the "method" label a predefined default label value set is used to filter given values. Values besides predefined values will count as \`unknown\` method. \`WithExtraMethods\` can be used to add more methods to the set. The Observe method of the Observer in the ObserverVec is called with the request duration in seconds. Partitioning happens by HTTP status code and/or HTTP method if the respective instance label names are present in the ObserverVec. For unpartitioned observations, use an ObserverVec with zero labels. Note that partitioning of Histograms is expensive and should be used judiciously.

If the wrapped Handler does not set a status code, a status code of 200 is assumed.

If the wrapped Handler panics, no values are reported.

Note that this method is only guaranteed to never observe negative durations if used with Go1.9\+.

## func InstrumentHandlerInFlight

```go
func InstrumentHandlerInFlight(g prometheus.Gauge, next http.Handler) http.Handler
```

InstrumentHandlerInFlight is a middleware that wraps the provided http.Handler. It sets the provided prometheus.Gauge to the number of requests currently handled by the wrapped http.Handler.

See the example for InstrumentHandlerDuration for example usage.

## func InstrumentHandlerRequestSize

```go
func InstrumentHandlerRequestSize(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc
```

InstrumentHandlerRequestSize is a middleware that wraps the provided http.Handler to observe the request size with the provided ObserverVec. The ObserverVec must have valid metric and label names and must have zero, one, or two non\-const non\-curried labels. For those, the only allowed label names are "code" and "method". The function panics otherwise. For the "method" label a predefined default label value set is used to filter given values. Values besides predefined values will count as \`unknown\` method. \`WithExtraMethods\` can be used to add more methods to the set. The Observe method of the Observer in the ObserverVec is called with the request size in bytes. Partitioning happens by HTTP status code and/or HTTP method if the respective instance label names are present in the ObserverVec. For unpartitioned observations, use an ObserverVec with zero labels. Note that partitioning of Histograms is expensive and should be used judiciously.

If the wrapped Handler does not set a status code, a status code of 200 is assumed.

If the wrapped Handler panics, no values are reported.

See the example for InstrumentHandlerDuration for example usage.

## func InstrumentHandlerResponseSize

```go
func InstrumentHandlerResponseSize(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.Handler
```

InstrumentHandlerResponseSize is a middleware that wraps the provided http.Handler to observe the response size with the provided ObserverVec. The ObserverVec must have valid metric and label names and must have zero, one, or two non\-const non\-curried labels. For those, the only allowed label names are "code" and "method". The function panics otherwise. For the "method" label a predefined default label value set is used to filter given values. Values besides predefined values will count as \`unknown\` method. \`WithExtraMethods\` can be used to add more methods to the set. The Observe method of the Observer in the ObserverVec is called with the response size in bytes. Partitioning happens by HTTP status code and/or HTTP method if the respective instance label names are present in the ObserverVec. For unpartitioned observations, use an ObserverVec with zero labels. Note that partitioning of Histograms is expensive and should be used judiciously.

If the wrapped Handler does not set a status code, a status code of 200 is assumed.

If the wrapped Handler panics, no values are reported.

See the example for InstrumentHandlerDuration for example usage.

## func InstrumentHandlerTimeToWriteHeader

```go
func InstrumentHandlerTimeToWriteHeader(obs prometheus.ObserverVec, next http.Handler, opts ...Option) http.HandlerFunc
```

InstrumentHandlerTimeToWriteHeader is a middleware that wraps the provided http.Handler to observe with the provided ObserverVec the request duration until the response headers are written. The ObserverVec must have valid metric and label names and must have zero, one, or two non\-const non\-curried labels. For those, the only allowed label names are "code" and "method". The function panics otherwise. For the "method" label a predefined default label value set is used to filter given values. Values besides predefined values will count as \`unknown\` method.\`WithExtraMethods\` can be used to add more methods to the set. The Observe method of the Observer in the ObserverVec is called with the request duration in seconds. Partitioning happens by HTTP status code and/or HTTP method if the respective instance label names are present in the ObserverVec. For unpartitioned observations, use an ObserverVec with zero labels. Note that partitioning of Histograms is expensive and should be used judiciously.

If the wrapped Handler panics before calling WriteHeader, no value is reported.

Note that this method is only guaranteed to never observe negative durations if used with Go1.9\+.

See the example for InstrumentHandlerDuration for example usage.

## func InstrumentMetricHandler

```go
func InstrumentMetricHandler(reg prometheus.Registerer, handler http.Handler) http.Handler
```

InstrumentMetricHandler is usually used with an http.Handler returned by the HandlerFor function. It instruments the provided http.Handler with two metrics: A counter vector "promhttp\_metric\_handler\_requests\_total" to count scrapes partitioned by HTTP status code, and a gauge "promhttp\_metric\_handler\_requests\_in\_flight" to track the number of simultaneous scrapes. This function idempotently registers collectors for both metrics with the provided Registerer. It panics if the registration fails. The provided metrics are useful to see how many scrapes hit the monitored target \(which could be from different Prometheus servers or other scrapers\), and how often they overlap \(which would result in more than one scrape in flight at the same time\). Note that the scrapes\-in\-flight gauge will contain the scrape by which it is exposed, while the scrape counter will only get incremented after the scrape is complete \(as only then the status code is known\). For tracking scrape durations, use the "scrape\_duration\_seconds" gauge created by the Prometheus server upon each scrape.

## type HandlerErrorHandling

HandlerErrorHandling defines how a Handler serving metrics will handle errors.

```go
type HandlerErrorHandling int
```

These constants cause handlers serving metrics to behave as described if errors are encountered.

```go
const (
    // Serve an HTTP status code 500 upon the first error
    // encountered. Report the error message in the body. Note that HTTP
    // errors cannot be served anymore once the beginning of a regular
    // payload has been sent. Thus, in the (unlikely) case that encoding the
    // payload into the negotiated wire format fails, serving the response
    // will simply be aborted. Set an ErrorLog in HandlerOpts to detect
    // those errors.
    HTTPErrorOnError HandlerErrorHandling = iota
    // Ignore errors and try to serve as many metrics as possible.  However,
    // if no metrics can be served, serve an HTTP status code 500 and the
    // last error message in the body. Only use this in deliberate "best
    // effort" metrics collection scenarios. In this case, it is highly
    // recommended to provide other means of detecting errors: By setting an
    // ErrorLog in HandlerOpts, the errors are logged. By providing a
    // Registry in HandlerOpts, the exposed metrics include an error counter
    // "promhttp_metric_handler_errors_total", which can be used for
    // alerts.
    ContinueOnError
    // Panic upon the first error encountered (useful for "crash only" apps).
    PanicOnError
)
```

## type HandlerOpts

HandlerOpts specifies options how to serve metrics via an http.Handler. The zero value of HandlerOpts is a reasonable default.

```go
type HandlerOpts struct {
    // ErrorLog specifies an optional Logger for errors collecting and
    // serving metrics. If nil, errors are not logged at all. Note that the
    // type of a reported error is often prometheus.MultiError, which
    // formats into a multi-line error string. If you want to avoid the
    // latter, create a Logger implementation that detects a
    // prometheus.MultiError and formats the contained errors into one line.
    ErrorLog Logger
    // ErrorHandling defines how errors are handled. Note that errors are
    // logged regardless of the configured ErrorHandling provided ErrorLog
    // is not nil.
    ErrorHandling HandlerErrorHandling
    // If Registry is not nil, it is used to register a metric
    // "promhttp_metric_handler_errors_total", partitioned by "cause". A
    // failed registration causes a panic. Note that this error counter is
    // different from the instrumentation you get from the various
    // InstrumentHandler... helpers. It counts errors that don't necessarily
    // result in a non-2xx HTTP status code. There are two typical cases:
    // (1) Encoding errors that only happen after streaming of the HTTP body
    // has already started (and the status code 200 has been sent). This
    // should only happen with custom collectors. (2) Collection errors with
    // no effect on the HTTP status code because ErrorHandling is set to
    // ContinueOnError.
    Registry prometheus.Registerer
    // If DisableCompression is true, the handler will never compress the
    // response, even if requested by the client.
    DisableCompression bool
    // The number of concurrent HTTP requests is limited to
    // MaxRequestsInFlight. Additional requests are responded to with 503
    // Service Unavailable and a suitable message in the body. If
    // MaxRequestsInFlight is 0 or negative, no limit is applied.
    MaxRequestsInFlight int
    // If handling a request takes longer than Timeout, it is responded to
    // with 503 ServiceUnavailable and a suitable Message. No timeout is
    // applied if Timeout is 0 or negative. Note that with the current
    // implementation, reaching the timeout simply ends the HTTP requests as
    // described above (and even that only if sending of the body hasn't
    // started yet), while the bulk work of gathering all the metrics keeps
    // running in the background (with the eventual result to be thrown
    // away). Until the implementation is improved, it is recommended to
    // implement a separate timeout in potentially slow Collectors.
    Timeout time.Duration
    // If true, the experimental OpenMetrics encoding is added to the
    // possible options during content negotiation. Note that Prometheus
    // 2.5.0+ will negotiate OpenMetrics as first priority. OpenMetrics is
    // the only way to transmit exemplars. However, the move to OpenMetrics
    // is not completely transparent. Most notably, the values of "quantile"
    // labels of Summaries and "le" labels of Histograms are formatted with
    // a trailing ".0" if they would otherwise look like integer numbers
    // (which changes the identity of the resulting series on the Prometheus
    // server).
    EnableOpenMetrics bool
}
```

## type InstrumentTrace

InstrumentTrace is used to offer flexibility in instrumenting the available httptrace.ClientTrace hook functions. Each function is passed a float64 representing the time in seconds since the start of the http request. A user may choose to use separately buckets Histograms, or implement custom instance labels on a per function basis.

```go
type InstrumentTrace struct {
    GotConn              func(float64)
    PutIdleConn          func(float64)
    GotFirstResponseByte func(float64)
    Got100Continue       func(float64)
    DNSStart             func(float64)
    DNSDone              func(float64)
    ConnectStart         func(float64)
    ConnectDone          func(float64)
    TLSHandshakeStart    func(float64)
    TLSHandshakeDone     func(float64)
    WroteHeaders         func(float64)
    Wait100Continue      func(float64)
    WroteRequest         func(float64)
}
```

## type Logger

Logger is the minimal interface HandlerOpts needs for logging. Note that log.Logger from the standard library implements this interface, and it is easy to implement by custom loggers, if they don't do so already anyway.

```go
type Logger interface {
    Println(v ...interface{})
}
```

## type Option

Option are used to configure both handler \(middleware\) or round tripper.

```go
type Option interface {
    // contains filtered or unexported methods
}
```

### func WithExemplarFromContext

```go
func WithExemplarFromContext(getExemplarFn func(requestCtx context.Context) prometheus.Labels) Option
```

WithExemplarFromContext adds allows to put a hook to all counter and histogram metrics. If the hook function returns non\-nil labels, exemplars will be added for that request, otherwise metric will get instrumented without exemplar.

### func WithExtraMethods

```go
func WithExtraMethods(methods ...string) Option
```

WithExtraMethods adds additional HTTP methods to the list of allowed methods. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods for the default list.

See the example for ExampleInstrumentHandlerWithExtraMethods for example usage.

## type RoundTripperFunc

The RoundTripperFunc type is an adapter to allow the use of ordinary functions as RoundTrippers. If f is a function with the appropriate signature, RountTripperFunc\(f\) is a RoundTripper that calls f.

```go
type RoundTripperFunc func(req *http.Request) (*http.Response, error)
```

### func InstrumentRoundTripperCounter

```go
func InstrumentRoundTripperCounter(counter *prometheus.CounterVec, next http.RoundTripper, opts ...Option) RoundTripperFunc
```

InstrumentRoundTripperCounter is a middleware that wraps the provided http.RoundTripper to observe the request result with the provided CounterVec. The CounterVec must have zero, one, or two non\-const non\-curried labels. For those, the only allowed label names are "code" and "method". The function panics otherwise. For the "method" label a predefined default label value set is used to filter given values. Values besides predefined values will count as \`unknown\` method.\`WithExtraMethods\` can be used to add more methods to the set. Partitioning of the CounterVec happens by HTTP status code and/or HTTP method if the respective instance label names are present in the CounterVec. For unpartitioned counting, use a CounterVec with zero labels.

If the wrapped RoundTripper panics or returns a non\-nil error, the Counter is not incremented.

Use with WithExemplarFromContext to instrument the exemplars on the counter of requests.

See the example for ExampleInstrumentRoundTripperDuration for example usage.

### func InstrumentRoundTripperDuration

```go
func InstrumentRoundTripperDuration(obs prometheus.ObserverVec, next http.RoundTripper, opts ...Option) RoundTripperFunc
```

InstrumentRoundTripperDuration is a middleware that wraps the provided http.RoundTripper to observe the request duration with the provided ObserverVec.  The ObserverVec must have zero, one, or two non\-const non\-curried labels. For those, the only allowed label names are "code" and "method". The function panics otherwise. For the "method" label a predefined default label value set is used to filter given values. Values besides predefined values will count as \`unknown\` method. \`WithExtraMethods\` can be used to add more methods to the set. The Observe method of the Observer in the ObserverVec is called with the request duration in seconds. Partitioning happens by HTTP status code and/or HTTP method if the respective instance label names are present in the ObserverVec. For unpartitioned observations, use an ObserverVec with zero labels. Note that partitioning of Histograms is expensive and should be used judiciously.

If the wrapped RoundTripper panics or returns a non\-nil error, no values are reported.

Use with WithExemplarFromContext to instrument the exemplars on the duration histograms.

Note that this method is only guaranteed to never observe negative durations if used with Go1.9\+.

### func InstrumentRoundTripperInFlight

```go
func InstrumentRoundTripperInFlight(gauge prometheus.Gauge, next http.RoundTripper) RoundTripperFunc
```

InstrumentRoundTripperInFlight is a middleware that wraps the provided http.RoundTripper. It sets the provided prometheus.Gauge to the number of requests currently handled by the wrapped http.RoundTripper.

See the example for ExampleInstrumentRoundTripperDuration for example usage.

### func InstrumentRoundTripperTrace

```go
func InstrumentRoundTripperTrace(it *InstrumentTrace, next http.RoundTripper) RoundTripperFunc
```

InstrumentRoundTripperTrace is a middleware that wraps the provided RoundTripper and reports times to hook functions provided in the InstrumentTrace struct. Hook functions that are not present in the provided InstrumentTrace struct are ignored. Times reported to the hook functions are time since the start of the request. Only with Go1.9\+, those times are guaranteed to never be negative. \(Earlier Go versions are not using a monotonic clock.\) Note that partitioning of Histograms is expensive and should be used judiciously.

For hook functions that receive an error as an argument, no observations are made in the event of a non\-nil error value.

See the example for ExampleInstrumentRoundTripperDuration for example usage.

### func \(RoundTripperFunc\) RoundTrip

```go
func (rt RoundTripperFunc) RoundTrip(r *http.Request) (*http.Response, error)
```

RoundTrip implements the RoundTripper interface.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
