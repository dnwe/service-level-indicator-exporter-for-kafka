<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# internal

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/prometheus/client_golang/prometheus/internal"
```

### Copyright \(c\) 2015 Bj√∂rn Rabenstein

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files \(the "Software"\), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

The code in this package is copy/paste to avoid a dependency. Hence this file carries the copyright of the original repo. https://github.com/beorn7/floats

Copyright 2022 The Prometheus Authors Licensed under the Apache License, Version 2.0 \(the "License"\); you may not use this file except in compliance with the License. You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

It provides tools to compare sequences of strings and generate textual diffs.

Maintaining \`GetUnifiedDiffString\` here because original repository \(https://github.com/pmezard/go-difflib\) is no loger maintained.

## Index

- [func AlmostEqualFloat64(a, b, epsilon float64) bool](<#func-almostequalfloat64>)
- [func AlmostEqualFloat64s(a, b []float64, epsilon float64) bool](<#func-almostequalfloat64s>)
- [func GetUnifiedDiffString(diff UnifiedDiff) (string, error)](<#func-getunifieddiffstring>)
- [func NormalizeMetricFamilies(metricFamiliesByName map[string]*dto.MetricFamily) []*dto.MetricFamily](<#func-normalizemetricfamilies>)
- [func RuntimeMetricsBucketsForUnit(buckets []float64, unit string) []float64](<#func-runtimemetricsbucketsforunit>)
- [func RuntimeMetricsToProm(d *metrics.Description) (string, string, string, bool)](<#func-runtimemetricstoprom>)
- [func SplitLines(s string) []string](<#func-splitlines>)
- [func WriteUnifiedDiff(writer io.Writer, diff UnifiedDiff) error](<#func-writeunifieddiff>)
- [type GoCollectorOptions](<#type-gocollectoroptions>)
- [type GoCollectorRule](<#type-gocollectorrule>)
- [type LabelPairSorter](<#type-labelpairsorter>)
  - [func (s LabelPairSorter) Len() int](<#func-labelpairsorter-len>)
  - [func (s LabelPairSorter) Less(i, j int) bool](<#func-labelpairsorter-less>)
  - [func (s LabelPairSorter) Swap(i, j int)](<#func-labelpairsorter-swap>)
- [type Match](<#type-match>)
- [type MetricSorter](<#type-metricsorter>)
  - [func (s MetricSorter) Len() int](<#func-metricsorter-len>)
  - [func (s MetricSorter) Less(i, j int) bool](<#func-metricsorter-less>)
  - [func (s MetricSorter) Swap(i, j int)](<#func-metricsorter-swap>)
- [type OpCode](<#type-opcode>)
- [type SequenceMatcher](<#type-sequencematcher>)
  - [func NewMatcher(a, b []string) *SequenceMatcher](<#func-newmatcher>)
  - [func NewMatcherWithJunk(a, b []string, autoJunk bool, isJunk func(string) bool) *SequenceMatcher](<#func-newmatcherwithjunk>)
  - [func (m *SequenceMatcher) GetGroupedOpCodes(n int) [][]OpCode](<#func-sequencematcher-getgroupedopcodes>)
  - [func (m *SequenceMatcher) GetMatchingBlocks() []Match](<#func-sequencematcher-getmatchingblocks>)
  - [func (m *SequenceMatcher) GetOpCodes() []OpCode](<#func-sequencematcher-getopcodes>)
  - [func (m *SequenceMatcher) QuickRatio() float64](<#func-sequencematcher-quickratio>)
  - [func (m *SequenceMatcher) Ratio() float64](<#func-sequencematcher-ratio>)
  - [func (m *SequenceMatcher) RealQuickRatio() float64](<#func-sequencematcher-realquickratio>)
  - [func (m *SequenceMatcher) SetSeq1(a []string)](<#func-sequencematcher-setseq1>)
  - [func (m *SequenceMatcher) SetSeq2(b []string)](<#func-sequencematcher-setseq2>)
  - [func (m *SequenceMatcher) SetSeqs(a, b []string)](<#func-sequencematcher-setseqs>)
- [type UnifiedDiff](<#type-unifieddiff>)


## func AlmostEqualFloat64

```go
func AlmostEqualFloat64(a, b, epsilon float64) bool
```

AlmostEqualFloat64 returns true if a and b are equal within a relative error of epsilon. See http://floating-point-gui.de/errors/comparison/ for the details of the applied method.

## func AlmostEqualFloat64s

```go
func AlmostEqualFloat64s(a, b []float64, epsilon float64) bool
```

AlmostEqualFloat64s is the slice form of AlmostEqualFloat64.

## func GetUnifiedDiffString

```go
func GetUnifiedDiffString(diff UnifiedDiff) (string, error)
```

Like WriteUnifiedDiff but returns the diff a string.

## func NormalizeMetricFamilies

```go
func NormalizeMetricFamilies(metricFamiliesByName map[string]*dto.MetricFamily) []*dto.MetricFamily
```

NormalizeMetricFamilies returns a MetricFamily slice with empty MetricFamilies pruned and the remaining MetricFamilies sorted by name within the slice, with the contained Metrics sorted within each MetricFamily.

## func RuntimeMetricsBucketsForUnit

```go
func RuntimeMetricsBucketsForUnit(buckets []float64, unit string) []float64
```

RuntimeMetricsBucketsForUnit takes a set of buckets obtained for a runtime/metrics histogram type \(so, lower\-bound inclusive\) and a unit from a runtime/metrics name, and produces a reduced set of buckets. This function always removes any \-Inf bucket as it's represented as the bottom\-most upper\-bound inclusive bucket in Prometheus.

## func RuntimeMetricsToProm

```go
func RuntimeMetricsToProm(d *metrics.Description) (string, string, string, bool)
```

RuntimeMetricsToProm produces a Prometheus metric name from a runtime/metrics metric description and validates whether the metric is suitable for integration with Prometheus.

Returns false if a name could not be produced, or if Prometheus does not understand the runtime/metrics Kind.

Note that the main reason a name couldn't be produced is if the runtime/metrics package exports a name with characters outside the valid Prometheus metric name character set. This is theoretically possible, but should never happen in practice. Still, don't rely on it.

## func SplitLines

```go
func SplitLines(s string) []string
```

Split a string on "\\n" while preserving them. The output can be used as input for UnifiedDiff and ContextDiff structures.

## func WriteUnifiedDiff

```go
func WriteUnifiedDiff(writer io.Writer, diff UnifiedDiff) error
```

Compare two sequences of lines; generate the delta as a unified diff.

Unified diffs are a compact way of showing line changes and a few lines of context.  The number of context lines is set by 'n' which defaults to three.

By default, the diff control lines \(those with \-\-\-, \+\+\+, or @@\) are created with a trailing newline.  This is helpful so that inputs created from file.readlines\(\) result in diffs that are suitable for file.writelines\(\) since both the inputs and outputs have trailing newlines.

For inputs that do not have trailing newlines, set the lineterm argument to "" so that the output will be uniformly newline free.

The unidiff format normally has a header for filenames and modification times.  Any or all of these may be specified using strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'. The modification times are normally expressed in the ISO 8601 format.

## type GoCollectorOptions

GoCollectorOptions should not be used be directly by anything, except \`collectors\` package. Use it via collectors package instead. See issue https://github.com/prometheus/client_golang/issues/1030.

This is internal, so external users only can use it via \`collector.WithGoCollector\*\` methods

```go
type GoCollectorOptions struct {
    DisableMemStatsLikeMetrics bool
    RuntimeMetricSumForHist    map[string]string
    RuntimeMetricRules         []GoCollectorRule
}
```

## type GoCollectorRule

```go
type GoCollectorRule struct {
    Matcher *regexp.Regexp
    Deny    bool
}
```

## type LabelPairSorter

LabelPairSorter implements sort.Interface. It is used to sort a slice of dto.LabelPair pointers.

```go
type LabelPairSorter []*dto.LabelPair
```

### func \(LabelPairSorter\) Len

```go
func (s LabelPairSorter) Len() int
```

### func \(LabelPairSorter\) Less

```go
func (s LabelPairSorter) Less(i, j int) bool
```

### func \(LabelPairSorter\) Swap

```go
func (s LabelPairSorter) Swap(i, j int)
```

## type Match

```go
type Match struct {
    A    int
    B    int
    Size int
}
```

## type MetricSorter

MetricSorter is a sortable slice of \*dto.Metric.

```go
type MetricSorter []*dto.Metric
```

### func \(MetricSorter\) Len

```go
func (s MetricSorter) Len() int
```

### func \(MetricSorter\) Less

```go
func (s MetricSorter) Less(i, j int) bool
```

### func \(MetricSorter\) Swap

```go
func (s MetricSorter) Swap(i, j int)
```

## type OpCode

```go
type OpCode struct {
    Tag byte
    I1  int
    I2  int
    J1  int
    J2  int
}
```

## type SequenceMatcher

SequenceMatcher compares sequence of strings. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980's by Ratcliff and Obershelp under the hyperbolic name "gestalt pattern matching".  The basic idea is to find the longest contiguous matching subsequence that contains no "junk" elements \(R\-O doesn't address junk\).  The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence.  This does not yield minimal edit sequences, but does tend to yield matches that "look right" to people.

SequenceMatcher tries to compute a "human\-friendly diff" between two sequences.  Unlike e.g. UNIX\(tm\) diff, the fundamental notion is the longest \*contiguous\* & junk\-free matching subsequence.  That's what catches peoples' eyes.  The Windows\(tm\) windiff has another interesting notion, pairing up elements that appear uniquely in each sequence. That, and the method here, appear to yield more intuitive difference reports than does diff.  This method appears to be the least vulnerable to synching up on blocks of "junk lines", though \(like blank lines in ordinary text files, or maybe "\<P\>" lines in HTML files\).  That may be because this is the only method of the 3 that has a \*concept\* of "junk" \<wink\>.

Timing:  Basic R\-O is cubic time worst case and quadratic time expected case.  SequenceMatcher is quadratic time for the worst case and has expected\-case behavior dependent in a complicated way on how many elements the sequences have in common; best case time is linear.

```go
type SequenceMatcher struct {
    IsJunk func(string) bool
    // contains filtered or unexported fields
}
```

### func NewMatcher

```go
func NewMatcher(a, b []string) *SequenceMatcher
```

### func NewMatcherWithJunk

```go
func NewMatcherWithJunk(a, b []string, autoJunk bool, isJunk func(string) bool) *SequenceMatcher
```

### func \(\*SequenceMatcher\) GetGroupedOpCodes

```go
func (m *SequenceMatcher) GetGroupedOpCodes(n int) [][]OpCode
```

Isolate change clusters by eliminating ranges with no changes.

Return a generator of groups with up to n lines of context. Each group is in the same format as returned by GetOpCodes\(\).

### func \(\*SequenceMatcher\) GetMatchingBlocks

```go
func (m *SequenceMatcher) GetMatchingBlocks() []Match
```

Return list of triples describing matching subsequences.

Each triple is of the form \(i, j, n\), and means that a\[i:i\+n\] == b\[j:j\+n\].  The triples are monotonically increasing in i and in j. It's also guaranteed that if \(i, j, n\) and \(i', j', n'\) are adjacent triples in the list, and the second is not the last triple in the list, then i\+n \!= i' or j\+n \!= j'. IOW, adjacent triples never describe adjacent equal blocks.

The last triple is a dummy, \(len\(a\), len\(b\), 0\), and is the only triple with n==0.

### func \(\*SequenceMatcher\) GetOpCodes

```go
func (m *SequenceMatcher) GetOpCodes() []OpCode
```

Return list of 5\-tuples describing how to turn a into b.

Each tuple is of the form \(tag, i1, i2, j1, j2\).  The first tuple has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the tuple preceding it, and likewise for j1 == the previous j2.

The tags are characters, with these meanings:

'r' \(replace\):  a\[i1:i2\] should be replaced by b\[j1:j2\]

'd' \(delete\):   a\[i1:i2\] should be deleted, j1==j2 in this case.

'i' \(insert\):   b\[j1:j2\] should be inserted at a\[i1:i1\], i1==i2 in this case.

'e' \(equal\):    a\[i1:i2\] == b\[j1:j2\]

### func \(\*SequenceMatcher\) QuickRatio

```go
func (m *SequenceMatcher) QuickRatio() float64
```

Return an upper bound on ratio\(\) relatively quickly.

This isn't defined beyond that it is an upper bound on .Ratio\(\), and is faster to compute.

### func \(\*SequenceMatcher\) Ratio

```go
func (m *SequenceMatcher) Ratio() float64
```

Return a measure of the sequences' similarity \(float in \[0,1\]\).

Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0\*M / T. Note that this is 1 if the sequences are identical, and 0 if they have nothing in common.

.Ratio\(\) is expensive to compute if you haven't already computed .GetMatchingBlocks\(\) or .GetOpCodes\(\), in which case you may want to try .QuickRatio\(\) or .RealQuickRation\(\) first to get an upper bound.

### func \(\*SequenceMatcher\) RealQuickRatio

```go
func (m *SequenceMatcher) RealQuickRatio() float64
```

Return an upper bound on ratio\(\) very quickly.

This isn't defined beyond that it is an upper bound on .Ratio\(\), and is faster to compute than either .Ratio\(\) or .QuickRatio\(\).

### func \(\*SequenceMatcher\) SetSeq1

```go
func (m *SequenceMatcher) SetSeq1(a []string)
```

Set the first sequence to be compared. The second sequence to be compared is not changed.

SequenceMatcher computes and caches detailed information about the second sequence, so if you want to compare one sequence S against many sequences, use .SetSeq2\(s\) once and call .SetSeq1\(x\) repeatedly for each of the other sequences.

See also SetSeqs\(\) and SetSeq2\(\).

### func \(\*SequenceMatcher\) SetSeq2

```go
func (m *SequenceMatcher) SetSeq2(b []string)
```

Set the second sequence to be compared. The first sequence to be compared is not changed.

### func \(\*SequenceMatcher\) SetSeqs

```go
func (m *SequenceMatcher) SetSeqs(a, b []string)
```

Set two sequences to be compared.

## type UnifiedDiff

Unified diff parameters

```go
type UnifiedDiff struct {
    A        []string // First sequence lines
    FromFile string   // First file name
    FromDate string   // First file time
    B        []string // Second sequence lines
    ToFile   string   // Second file name
    ToDate   string   // Second file time
    Eol      string   // Headers end of line, defaults to LF
    Context  int      // Number of context lines
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
