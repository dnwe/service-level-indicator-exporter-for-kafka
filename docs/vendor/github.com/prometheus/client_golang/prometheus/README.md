<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# prometheus

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/prometheus/client_golang/prometheus"
```

Package prometheus is the core instrumentation package. It provides metrics primitives to instrument code for monitoring. It also offers a registry for metrics. Sub\-packages allow to expose the registered metrics via HTTP \(package promhttp\) or push them to a Pushgateway \(package push\). There is also a sub\-package promauto, which provides metrics constructors with automatic registration.

All exported functions and methods are safe to be used concurrently unless specified otherwise.

\# A Basic Example

As a starting point, a very basic usage example:

```
package main

import (
	"log"
	"net/http"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

type metrics struct {
	cpuTemp  prometheus.Gauge
  hdFailures *prometheus.CounterVec
}

func NewMetrics(reg prometheus.Registerer) *metrics {
  m := &metrics{
    cpuTemp: prometheus.NewGauge(prometheus.GaugeOpts{
      Name: "cpu_temperature_celsius",
      Help: "Current temperature of the CPU.",
    }),
    hdFailures: prometheus.NewCounterVec(
      prometheus.CounterOpts{
        Name: "hd_errors_total",
        Help: "Number of hard-disk errors.",
      },
      []string{"device"},
    ),
  }
  reg.MustRegister(m.cpuTemp)
  reg.MustRegister(m.hdFailures)
  return m
}

func main() {
  // Create a non-global registry.
  reg := prometheus.NewRegistry()

  // Create new metrics and register them using the custom registry.
  m := NewMetrics(reg)
  // Set values for the new created metrics.
	m.cpuTemp.Set(65.3)
	m.hdFailures.With(prometheus.Labels{"device":"/dev/sda"}).Inc()

	// Expose metrics and custom registry via an HTTP server
	// using the HandleFor function. "/metrics" is the usual endpoint for that.
	http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{Registry: reg}))
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

This is a complete program that exports two metrics, a Gauge and a Counter, the latter with a label attached to turn it into a \(one\-dimensional\) vector. It register the metrics using a custom registry and exposes them via an HTTP server on the /metrics endpoint.

\# Metrics

The number of exported identifiers in this package might appear a bit overwhelming. However, in addition to the basic plumbing shown in the example above, you only need to understand the different metric types and their vector versions for basic usage. Furthermore, if you are not concerned with fine\-grained control of when and how to register metrics with the registry, have a look at the promauto package, which will effectively allow you to ignore registration altogether in simple cases.

Above, you have already touched the Counter and the Gauge. There are two more advanced metric types: the Summary and Histogram. A more thorough description of those four metric types can be found in the Prometheus docs: https://prometheus.io/docs/concepts/metric_types/

In addition to the fundamental metric types Gauge, Counter, Summary, and Histogram, a very important part of the Prometheus data model is the partitioning of samples along dimensions called labels, which results in metric vectors. The fundamental types are GaugeVec, CounterVec, SummaryVec, and HistogramVec.

While only the fundamental metric types implement the Metric interface, both the metrics and their vector versions implement the Collector interface. A Collector manages the collection of a number of Metrics, but for convenience, a Metric can also “collect itself”. Note that Gauge, Counter, Summary, and Histogram are interfaces themselves while GaugeVec, CounterVec, SummaryVec, and HistogramVec are not.

To create instances of Metrics and their vector versions, you need a suitable …Opts struct, i.e. GaugeOpts, CounterOpts, SummaryOpts, or HistogramOpts.

\# Custom Collectors and constant Metrics

While you could create your own implementations of Metric, most likely you will only ever implement the Collector interface on your own. At a first glance, a custom Collector seems handy to bundle Metrics for common registration \(with the prime example of the different metric vectors above, which bundle all the metrics of the same name but with different labels\).

There is a more involved use case, too: If you already have metrics available, created outside of the Prometheus context, you don't need the interface of the various Metric types. You essentially want to mirror the existing numbers into Prometheus Metrics during collection. An own implementation of the Collector interface is perfect for that. You can create Metric instances “on the fly” using NewConstMetric, NewConstHistogram, and NewConstSummary \(and their respective Must… versions\). NewConstMetric is used for all metric types with just a float64 as their value: Counter, Gauge, and a special “type” called Untyped. Use the latter if you are not sure if the mirrored metric is a Counter or a Gauge. Creation of the Metric instance happens in the Collect method. The Describe method has to return separate Desc instances, representative of the “throw\-away” metrics to be created later.  NewDesc comes in handy to create those Desc instances. Alternatively, you could return no Desc at all, which will mark the Collector “unchecked”. No checks are performed at registration time, but metric consistency will still be ensured at scrape time, i.e. any inconsistencies will lead to scrape errors. Thus, with unchecked Collectors, the responsibility to not collect metrics that lead to inconsistencies in the total scrape result lies with the implementer of the Collector. While this is not a desirable state, it is sometimes necessary. The typical use case is a situation where the exact metrics to be returned by a Collector cannot be predicted at registration time, but the implementer has sufficient knowledge of the whole system to guarantee metric consistency.

The Collector example illustrates the use case. You can also look at the source code of the processCollector \(mirroring process metrics\), the goCollector \(mirroring Go metrics\), or the expvarCollector \(mirroring expvar metrics\) as examples that are used in this package itself.

If you just need to call a function to get a single float value to collect as a metric, GaugeFunc, CounterFunc, or UntypedFunc might be interesting shortcuts.

\# Advanced Uses of the Registry

While MustRegister is the by far most common way of registering a Collector, sometimes you might want to handle the errors the registration might cause. As suggested by the name, MustRegister panics if an error occurs. With the Register function, the error is returned and can be handled.

An error is returned if the registered Collector is incompatible or inconsistent with already registered metrics. The registry aims for consistency of the collected metrics according to the Prometheus data model. Inconsistencies are ideally detected at registration time, not at collect time. The former will usually be detected at start\-up time of a program, while the latter will only happen at scrape time, possibly not even on the first scrape if the inconsistency only becomes relevant later. That is the main reason why a Collector and a Metric have to describe themselves to the registry.

So far, everything we did operated on the so\-called default registry, as it can be found in the global DefaultRegisterer variable. With NewRegistry, you can create a custom registry, or you can even implement the Registerer or Gatherer interfaces yourself. The methods Register and Unregister work in the same way on a custom registry as the global functions Register and Unregister on the default registry.

There are a number of uses for custom registries: You can use registries with special properties, see NewPedanticRegistry. You can avoid global state, as it is imposed by the DefaultRegisterer. You can use multiple registries at the same time to expose different metrics in different ways.  You can use separate registries for testing purposes.

Also note that the DefaultRegisterer comes registered with a Collector for Go runtime metrics \(via NewGoCollector\) and a Collector for process metrics \(via NewProcessCollector\). With a custom registry, you are in control and decide yourself about the Collectors to register.

\# HTTP Exposition

The Registry implements the Gatherer interface. The caller of the Gather method can then expose the gathered metrics in some way. Usually, the metrics are served via HTTP on the /metrics endpoint. That's happening in the example above. The tools to expose metrics via HTTP are in the promhttp sub\-package.

\# Pushing to the Pushgateway

Function for pushing to the Pushgateway can be found in the push sub\-package.

\# Graphite Bridge

Functions and examples to push metrics from a Gatherer to Graphite can be found in the graphite sub\-package.

\# Other Means of Exposition

More ways of exposing metrics can easily be added by following the approaches of the existing implementations.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func BuildFQName(namespace, subsystem, name string) string](<#func-buildfqname>)
- [func DescribeByCollect(c Collector, descs chan<- *Desc)](<#func-describebycollect>)
- [func ExponentialBuckets(start, factor float64, count int) []float64](<#func-exponentialbuckets>)
- [func ExponentialBucketsRange(min, max float64, count int) []float64](<#func-exponentialbucketsrange>)
- [func LinearBuckets(start, width float64, count int) []float64](<#func-linearbuckets>)
- [func MakeLabelPairs(desc *Desc, labelValues []string) []*dto.LabelPair](<#func-makelabelpairs>)
- [func MustRegister(cs ...Collector)](<#func-mustregister>)
- [func NewPidFileFn(pidFilePath string) func() (int, error)](<#func-newpidfilefn>)
- [func Register(c Collector) error](<#func-register>)
- [func Unregister(c Collector) bool](<#func-unregister>)
- [func WriteToTextfile(filename string, g Gatherer) error](<#func-writetotextfile>)
- [type AlreadyRegisteredError](<#type-alreadyregisterederror>)
  - [func (err AlreadyRegisteredError) Error() string](<#func-alreadyregisterederror-error>)
- [type Collector](<#type-collector>)
  - [func NewBuildInfoCollector() Collector](<#func-newbuildinfocollector>)
  - [func NewExpvarCollector(exports map[string]*Desc) Collector](<#func-newexpvarcollector>)
  - [func NewGoCollector(opts ...func(o *internal.GoCollectorOptions)) Collector](<#func-newgocollector>)
  - [func NewProcessCollector(opts ProcessCollectorOpts) Collector](<#func-newprocesscollector>)
- [type Counter](<#type-counter>)
  - [func NewCounter(opts CounterOpts) Counter](<#func-newcounter>)
- [type CounterFunc](<#type-counterfunc>)
  - [func NewCounterFunc(opts CounterOpts, function func() float64) CounterFunc](<#func-newcounterfunc>)
- [type CounterOpts](<#type-counteropts>)
- [type CounterVec](<#type-countervec>)
  - [func NewCounterVec(opts CounterOpts, labelNames []string) *CounterVec](<#func-newcountervec>)
  - [func (v *CounterVec) CurryWith(labels Labels) (*CounterVec, error)](<#func-countervec-currywith>)
  - [func (v *CounterVec) GetMetricWith(labels Labels) (Counter, error)](<#func-countervec-getmetricwith>)
  - [func (v *CounterVec) GetMetricWithLabelValues(lvs ...string) (Counter, error)](<#func-countervec-getmetricwithlabelvalues>)
  - [func (v *CounterVec) MustCurryWith(labels Labels) *CounterVec](<#func-countervec-mustcurrywith>)
  - [func (v *CounterVec) With(labels Labels) Counter](<#func-countervec-with>)
  - [func (v *CounterVec) WithLabelValues(lvs ...string) Counter](<#func-countervec-withlabelvalues>)
- [type Desc](<#type-desc>)
  - [func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc](<#func-newdesc>)
  - [func NewInvalidDesc(err error) *Desc](<#func-newinvaliddesc>)
  - [func (d *Desc) String() string](<#func-desc-string>)
- [type Exemplar](<#type-exemplar>)
- [type ExemplarAdder](<#type-exemplaradder>)
- [type ExemplarObserver](<#type-exemplarobserver>)
- [type Gatherer](<#type-gatherer>)
- [type GathererFunc](<#type-gathererfunc>)
  - [func (gf GathererFunc) Gather() ([]*dto.MetricFamily, error)](<#func-gathererfunc-gather>)
- [type Gatherers](<#type-gatherers>)
  - [func (gs Gatherers) Gather() ([]*dto.MetricFamily, error)](<#func-gatherers-gather>)
- [type Gauge](<#type-gauge>)
  - [func NewGauge(opts GaugeOpts) Gauge](<#func-newgauge>)
- [type GaugeFunc](<#type-gaugefunc>)
  - [func NewGaugeFunc(opts GaugeOpts, function func() float64) GaugeFunc](<#func-newgaugefunc>)
- [type GaugeOpts](<#type-gaugeopts>)
- [type GaugeVec](<#type-gaugevec>)
  - [func NewGaugeVec(opts GaugeOpts, labelNames []string) *GaugeVec](<#func-newgaugevec>)
  - [func (v *GaugeVec) CurryWith(labels Labels) (*GaugeVec, error)](<#func-gaugevec-currywith>)
  - [func (v *GaugeVec) GetMetricWith(labels Labels) (Gauge, error)](<#func-gaugevec-getmetricwith>)
  - [func (v *GaugeVec) GetMetricWithLabelValues(lvs ...string) (Gauge, error)](<#func-gaugevec-getmetricwithlabelvalues>)
  - [func (v *GaugeVec) MustCurryWith(labels Labels) *GaugeVec](<#func-gaugevec-mustcurrywith>)
  - [func (v *GaugeVec) With(labels Labels) Gauge](<#func-gaugevec-with>)
  - [func (v *GaugeVec) WithLabelValues(lvs ...string) Gauge](<#func-gaugevec-withlabelvalues>)
- [type Histogram](<#type-histogram>)
  - [func NewHistogram(opts HistogramOpts) Histogram](<#func-newhistogram>)
- [type HistogramOpts](<#type-histogramopts>)
- [type HistogramVec](<#type-histogramvec>)
  - [func NewHistogramVec(opts HistogramOpts, labelNames []string) *HistogramVec](<#func-newhistogramvec>)
  - [func (v *HistogramVec) CurryWith(labels Labels) (ObserverVec, error)](<#func-histogramvec-currywith>)
  - [func (v *HistogramVec) GetMetricWith(labels Labels) (Observer, error)](<#func-histogramvec-getmetricwith>)
  - [func (v *HistogramVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)](<#func-histogramvec-getmetricwithlabelvalues>)
  - [func (v *HistogramVec) MustCurryWith(labels Labels) ObserverVec](<#func-histogramvec-mustcurrywith>)
  - [func (v *HistogramVec) With(labels Labels) Observer](<#func-histogramvec-with>)
  - [func (v *HistogramVec) WithLabelValues(lvs ...string) Observer](<#func-histogramvec-withlabelvalues>)
- [type Labels](<#type-labels>)
- [type Metric](<#type-metric>)
  - [func MustNewConstHistogram(desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string) Metric](<#func-mustnewconsthistogram>)
  - [func MustNewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) Metric](<#func-mustnewconstmetric>)
  - [func MustNewConstSummary(desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string) Metric](<#func-mustnewconstsummary>)
  - [func MustNewMetricWithExemplars(m Metric, exemplars ...Exemplar) Metric](<#func-mustnewmetricwithexemplars>)
  - [func NewConstHistogram(desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string) (Metric, error)](<#func-newconsthistogram>)
  - [func NewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) (Metric, error)](<#func-newconstmetric>)
  - [func NewConstSummary(desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string) (Metric, error)](<#func-newconstsummary>)
  - [func NewInvalidMetric(desc *Desc, err error) Metric](<#func-newinvalidmetric>)
  - [func NewMetricWithExemplars(m Metric, exemplars ...Exemplar) (Metric, error)](<#func-newmetricwithexemplars>)
  - [func NewMetricWithTimestamp(t time.Time, m Metric) Metric](<#func-newmetricwithtimestamp>)
- [type MetricVec](<#type-metricvec>)
  - [func NewMetricVec(desc *Desc, newMetric func(lvs ...string) Metric) *MetricVec](<#func-newmetricvec>)
  - [func (m *MetricVec) Collect(ch chan<- Metric)](<#func-metricvec-collect>)
  - [func (m *MetricVec) CurryWith(labels Labels) (*MetricVec, error)](<#func-metricvec-currywith>)
  - [func (m *MetricVec) Delete(labels Labels) bool](<#func-metricvec-delete>)
  - [func (m *MetricVec) DeleteLabelValues(lvs ...string) bool](<#func-metricvec-deletelabelvalues>)
  - [func (m *MetricVec) DeletePartialMatch(labels Labels) int](<#func-metricvec-deletepartialmatch>)
  - [func (m *MetricVec) Describe(ch chan<- *Desc)](<#func-metricvec-describe>)
  - [func (m *MetricVec) GetMetricWith(labels Labels) (Metric, error)](<#func-metricvec-getmetricwith>)
  - [func (m *MetricVec) GetMetricWithLabelValues(lvs ...string) (Metric, error)](<#func-metricvec-getmetricwithlabelvalues>)
  - [func (m *MetricVec) Reset()](<#func-metricvec-reset>)
- [type MultiError](<#type-multierror>)
  - [func (errs *MultiError) Append(err error)](<#func-multierror-append>)
  - [func (errs MultiError) Error() string](<#func-multierror-error>)
  - [func (errs MultiError) MaybeUnwrap() error](<#func-multierror-maybeunwrap>)
- [type MultiTRegistry](<#type-multitregistry>)
  - [func NewMultiTRegistry(tGatherers ...TransactionalGatherer) *MultiTRegistry](<#func-newmultitregistry>)
  - [func (r *MultiTRegistry) Gather() (mfs []*dto.MetricFamily, done func(), err error)](<#func-multitregistry-gather>)
- [type Observer](<#type-observer>)
- [type ObserverFunc](<#type-observerfunc>)
  - [func (f ObserverFunc) Observe(value float64)](<#func-observerfunc-observe>)
- [type ObserverVec](<#type-observervec>)
- [type Opts](<#type-opts>)
- [type ProcessCollectorOpts](<#type-processcollectoropts>)
- [type Registerer](<#type-registerer>)
  - [func WrapRegistererWith(labels Labels, reg Registerer) Registerer](<#func-wrapregistererwith>)
  - [func WrapRegistererWithPrefix(prefix string, reg Registerer) Registerer](<#func-wrapregistererwithprefix>)
- [type Registry](<#type-registry>)
  - [func NewPedanticRegistry() *Registry](<#func-newpedanticregistry>)
  - [func NewRegistry() *Registry](<#func-newregistry>)
  - [func (r *Registry) Collect(ch chan<- Metric)](<#func-registry-collect>)
  - [func (r *Registry) Describe(ch chan<- *Desc)](<#func-registry-describe>)
  - [func (r *Registry) Gather() ([]*dto.MetricFamily, error)](<#func-registry-gather>)
  - [func (r *Registry) MustRegister(cs ...Collector)](<#func-registry-mustregister>)
  - [func (r *Registry) Register(c Collector) error](<#func-registry-register>)
  - [func (r *Registry) Unregister(c Collector) bool](<#func-registry-unregister>)
- [type Summary](<#type-summary>)
  - [func NewSummary(opts SummaryOpts) Summary](<#func-newsummary>)
- [type SummaryOpts](<#type-summaryopts>)
- [type SummaryVec](<#type-summaryvec>)
  - [func NewSummaryVec(opts SummaryOpts, labelNames []string) *SummaryVec](<#func-newsummaryvec>)
  - [func (v *SummaryVec) CurryWith(labels Labels) (ObserverVec, error)](<#func-summaryvec-currywith>)
  - [func (v *SummaryVec) GetMetricWith(labels Labels) (Observer, error)](<#func-summaryvec-getmetricwith>)
  - [func (v *SummaryVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)](<#func-summaryvec-getmetricwithlabelvalues>)
  - [func (v *SummaryVec) MustCurryWith(labels Labels) ObserverVec](<#func-summaryvec-mustcurrywith>)
  - [func (v *SummaryVec) With(labels Labels) Observer](<#func-summaryvec-with>)
  - [func (v *SummaryVec) WithLabelValues(lvs ...string) Observer](<#func-summaryvec-withlabelvalues>)
- [type Timer](<#type-timer>)
  - [func NewTimer(o Observer) *Timer](<#func-newtimer>)
  - [func (t *Timer) ObserveDuration() time.Duration](<#func-timer-observeduration>)
- [type TransactionalGatherer](<#type-transactionalgatherer>)
  - [func ToTransactionalGatherer(g Gatherer) TransactionalGatherer](<#func-totransactionalgatherer>)
- [type UntypedFunc](<#type-untypedfunc>)
  - [func NewUntypedFunc(opts UntypedOpts, function func() float64) UntypedFunc](<#func-newuntypedfunc>)
- [type UntypedOpts](<#type-untypedopts>)
- [type ValueType](<#type-valuetype>)
  - [func (v ValueType) ToDTO() *dto.MetricType](<#func-valuetype-todto>)


## Constants

Default values for SummaryOpts.

```go
const (
    // DefMaxAge is the default duration for which observations stay
    // relevant.
    DefMaxAge time.Duration = 10 * time.Minute
    // DefAgeBuckets is the default number of buckets used to calculate the
    // age of observations.
    DefAgeBuckets = 5
    // DefBufCap is the standard buffer size for collecting Summary observations.
    DefBufCap = 500
)
```

Possible values for the ValueType enum. Use UntypedValue to mark a metric with an unknown type.

```go
const (
    CounterValue
    GaugeValue
    UntypedValue
)
```

DefNativeHistogramZeroThreshold is the default value for NativeHistogramZeroThreshold in the HistogramOpts.

The value is 2^\-128 \(or 0.5\*2^\-127 in the actual IEEE 754 representation\), which is a bucket boundary at all possible resolutions.

```go
const DefNativeHistogramZeroThreshold = 2.938735877055719e-39
```

ExemplarMaxRunes is the max total number of runes allowed in exemplar labels.

```go
const ExemplarMaxRunes = 128
```

NativeHistogramZeroThresholdZero can be used as NativeHistogramZeroThreshold in the HistogramOpts to create a zero bucket of width zero, i.e. a zero bucket that only receives observations of precisely zero.

```go
const NativeHistogramZeroThresholdZero = -1
```

## Variables

DefaultRegisterer and DefaultGatherer are the implementations of the Registerer and Gatherer interface a number of convenience functions in this package act on. Initially, both variables point to the same Registry, which has a process collector \(currently on Linux only, see NewProcessCollector\) and a Go collector \(see NewGoCollector, in particular the note about stop\-the\-world implication with Go versions older than 1.9\) already registered. This approach to keep default instances as global state mirrors the approach of other packages in the Go standard library. Note that there are caveats. Change the variables with caution and only if you understand the consequences. Users who want to avoid global state altogether should not use the convenience functions and act on custom instances instead.

```go
var (
    DefaultRegisterer Registerer = defaultRegistry
    DefaultGatherer   Gatherer   = defaultRegistry
)
```

```go
var (
    CounterMetricTypePtr = func() *dto.MetricType { d := dto.MetricType_COUNTER; return &d }()
    GaugeMetricTypePtr   = func() *dto.MetricType { d := dto.MetricType_GAUGE; return &d }()
    UntypedMetricTypePtr = func() *dto.MetricType { d := dto.MetricType_UNTYPED; return &d }()
)
```

DefBuckets are the default Histogram buckets. The default buckets are tailored to broadly measure the response time \(in seconds\) of a network service. Most likely, however, you will be required to define buckets customized to your use case.

```go
var DefBuckets = []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10}
```

## func BuildFQName

```go
func BuildFQName(namespace, subsystem, name string) string
```

BuildFQName joins the given three name components by "\_". Empty name components are ignored. If the name parameter itself is empty, an empty string is returned, no matter what. Metric implementations included in this library use this function internally to generate the fully\-qualified metric name from the name component in their Opts. Users of the library will only need this function if they implement their own Metric or instantiate a Desc \(with NewDesc\) directly.

## func DescribeByCollect

```go
func DescribeByCollect(c Collector, descs chan<- *Desc)
```

DescribeByCollect is a helper to implement the Describe method of a custom Collector. It collects the metrics from the provided Collector and sends their descriptors to the provided channel.

If a Collector collects the same metrics throughout its lifetime, its Describe method can simply be implemented as:

```
func (c customCollector) Describe(ch chan<- *Desc) {
	DescribeByCollect(c, ch)
}
```

However, this will not work if the metrics collected change dynamically over the lifetime of the Collector in a way that their combined set of descriptors changes as well. The shortcut implementation will then violate the contract of the Describe method. If a Collector sometimes collects no metrics at all \(for example vectors like CounterVec, GaugeVec, etc., which only collect metrics after a metric with a fully specified label set has been accessed\), it might even get registered as an unchecked Collector \(cf. the Register method of the Registerer interface\). Hence, only use this shortcut implementation of Describe if you are certain to fulfill the contract.

The Collector example demonstrates a use of DescribeByCollect.

## func ExponentialBuckets

```go
func ExponentialBuckets(start, factor float64, count int) []float64
```

ExponentialBuckets creates 'count' regular buckets, where the lowest bucket has an upper bound of 'start' and each following bucket's upper bound is 'factor' times the previous bucket's upper bound. The final \+Inf bucket is not counted and not included in the returned slice. The returned slice is meant to be used for the Buckets field of HistogramOpts.

The function panics if 'count' is 0 or negative, if 'start' is 0 or negative, or if 'factor' is less than or equal 1.

## func ExponentialBucketsRange

```go
func ExponentialBucketsRange(min, max float64, count int) []float64
```

ExponentialBucketsRange creates 'count' buckets, where the lowest bucket is 'min' and the highest bucket is 'max'. The final \+Inf bucket is not counted and not included in the returned slice. The returned slice is meant to be used for the Buckets field of HistogramOpts.

The function panics if 'count' is 0 or negative, if 'min' is 0 or negative.

## func LinearBuckets

```go
func LinearBuckets(start, width float64, count int) []float64
```

LinearBuckets creates 'count' regular buckets, each 'width' wide, where the lowest bucket has an upper bound of 'start'. The final \+Inf bucket is not counted and not included in the returned slice. The returned slice is meant to be used for the Buckets field of HistogramOpts.

The function panics if 'count' is zero or negative.

## func MakeLabelPairs

```go
func MakeLabelPairs(desc *Desc, labelValues []string) []*dto.LabelPair
```

MakeLabelPairs is a helper function to create protobuf LabelPairs from the variable and constant labels in the provided Desc. The values for the variable labels are defined by the labelValues slice, which must be in the same order as the corresponding variable labels in the Desc.

This function is only needed for custom Metric implementations. See MetricVec example.

## func MustRegister

```go
func MustRegister(cs ...Collector)
```

MustRegister registers the provided Collectors with the DefaultRegisterer and panics if any error occurs.

MustRegister is a shortcut for DefaultRegisterer.MustRegister\(cs...\). See there for more details.

## func NewPidFileFn

```go
func NewPidFileFn(pidFilePath string) func() (int, error)
```

NewPidFileFn returns a function that retrieves a pid from the specified file. It is meant to be used for the PidFn field in ProcessCollectorOpts.

## func Register

```go
func Register(c Collector) error
```

Register registers the provided Collector with the DefaultRegisterer.

Register is a shortcut for DefaultRegisterer.Register\(c\). See there for more details.

## func Unregister

```go
func Unregister(c Collector) bool
```

Unregister removes the registration of the provided Collector from the DefaultRegisterer.

Unregister is a shortcut for DefaultRegisterer.Unregister\(c\). See there for more details.

## func WriteToTextfile

```go
func WriteToTextfile(filename string, g Gatherer) error
```

WriteToTextfile calls Gather on the provided Gatherer, encodes the result in the Prometheus text format, and writes it to a temporary file. Upon success, the temporary file is renamed to the provided filename.

This is intended for use with the textfile collector of the node exporter. Note that the node exporter expects the filename to be suffixed with ".prom".

## type AlreadyRegisteredError

AlreadyRegisteredError is returned by the Register method if the Collector to be registered has already been registered before, or a different Collector that collects the same metrics has been registered before. Registration fails in that case, but you can detect from the kind of error what has happened. The error contains fields for the existing Collector and the \(rejected\) new Collector that equals the existing one. This can be used to find out if an equal Collector has been registered before and switch over to using the old one, as demonstrated in the example.

```go
type AlreadyRegisteredError struct {
    ExistingCollector, NewCollector Collector
}
```

### func \(AlreadyRegisteredError\) Error

```go
func (err AlreadyRegisteredError) Error() string
```

## type Collector

Collector is the interface implemented by anything that can be used by Prometheus to collect metrics. A Collector has to be registered for collection. See Registerer.Register.

The stock metrics provided by this package \(Gauge, Counter, Summary, Histogram, Untyped\) are also Collectors \(which only ever collect one metric, namely itself\). An implementer of Collector may, however, collect multiple metrics in a coordinated fashion and/or create metrics on the fly. Examples for collectors already implemented in this library are the metric vectors \(i.e. collection of multiple instances of the same Metric but with different label values\) like GaugeVec or SummaryVec, and the ExpvarCollector.

```go
type Collector interface {
    // Describe sends the super-set of all possible descriptors of metrics
    // collected by this Collector to the provided channel and returns once
    // the last descriptor has been sent. The sent descriptors fulfill the
    // consistency and uniqueness requirements described in the Desc
    // documentation.
    //
    // It is valid if one and the same Collector sends duplicate
    // descriptors. Those duplicates are simply ignored. However, two
    // different Collectors must not send duplicate descriptors.
    //
    // Sending no descriptor at all marks the Collector as “unchecked”,
    // i.e. no checks will be performed at registration time, and the
    // Collector may yield any Metric it sees fit in its Collect method.
    //
    // This method idempotently sends the same descriptors throughout the
    // lifetime of the Collector. It may be called concurrently and
    // therefore must be implemented in a concurrency safe way.
    //
    // If a Collector encounters an error while executing this method, it
    // must send an invalid descriptor (created with NewInvalidDesc) to
    // signal the error to the registry.
    Describe(chan<- *Desc)
    // Collect is called by the Prometheus registry when collecting
    // metrics. The implementation sends each collected metric via the
    // provided channel and returns once the last metric has been sent. The
    // descriptor of each sent metric is one of those returned by Describe
    // (unless the Collector is unchecked, see above). Returned metrics that
    // share the same descriptor must differ in their variable label
    // values.
    //
    // This method may be called concurrently and must therefore be
    // implemented in a concurrency safe way. Blocking occurs at the expense
    // of total performance of rendering all registered metrics. Ideally,
    // Collector implementations support concurrent readers.
    Collect(chan<- Metric)
}
```

### func NewBuildInfoCollector

```go
func NewBuildInfoCollector() Collector
```

NewBuildInfoCollector is the obsolete version of collectors.NewBuildInfoCollector. See there for documentation.

Deprecated: Use collectors.NewBuildInfoCollector instead.

### func NewExpvarCollector

```go
func NewExpvarCollector(exports map[string]*Desc) Collector
```

NewExpvarCollector is the obsolete version of collectors.NewExpvarCollector. See there for documentation.

Deprecated: Use collectors.NewExpvarCollector instead.

### func NewGoCollector

```go
func NewGoCollector(opts ...func(o *internal.GoCollectorOptions)) Collector
```

NewGoCollector is the obsolete version of collectors.NewGoCollector. See there for documentation.

Deprecated: Use collectors.NewGoCollector instead.

### func NewProcessCollector

```go
func NewProcessCollector(opts ProcessCollectorOpts) Collector
```

NewProcessCollector is the obsolete version of collectors.NewProcessCollector. See there for documentation.

Deprecated: Use collectors.NewProcessCollector instead.

## type Counter

Counter is a Metric that represents a single numerical value that only ever goes up. That implies that it cannot be used to count items whose number can also go down, e.g. the number of currently running goroutines. Those "counters" are represented by Gauges.

A Counter is typically used to count requests served, tasks completed, errors occurred, etc.

To create Counter instances, use NewCounter.

```go
type Counter interface {
    Metric
    Collector

    // Inc increments the counter by 1. Use Add to increment it by arbitrary
    // non-negative values.
    Inc()
    // Add adds the given value to the counter. It panics if the value is <
    // 0.
    Add(float64)
}
```

### func NewCounter

```go
func NewCounter(opts CounterOpts) Counter
```

NewCounter creates a new Counter based on the provided CounterOpts.

The returned implementation also implements ExemplarAdder. It is safe to perform the corresponding type assertion.

The returned implementation tracks the counter value in two separate variables, a float64 and a uint64. The latter is used to track calls of the Inc method and calls of the Add method with a value that can be represented as a uint64. This allows atomic increments of the counter with optimal performance. \(It is common to have an Inc call in very hot execution paths.\) Both internal tracking values are added up in the Write method. This has to be taken into account when it comes to precision and overflow behavior.

## type CounterFunc

CounterFunc is a Counter whose value is determined at collect time by calling a provided function.

To create CounterFunc instances, use NewCounterFunc.

```go
type CounterFunc interface {
    Metric
    Collector
}
```

### func NewCounterFunc

```go
func NewCounterFunc(opts CounterOpts, function func() float64) CounterFunc
```

NewCounterFunc creates a new CounterFunc based on the provided CounterOpts. The value reported is determined by calling the given function from within the Write method. Take into account that metric collection may happen concurrently. If that results in concurrent calls to Write, like in the case where a CounterFunc is directly registered with Prometheus, the provided function must be concurrency\-safe. The function should also honor the contract for a Counter \(values only go up, not down\), but compliance will not be checked.

Check out the ExampleGaugeFunc examples for the similar GaugeFunc.

## type CounterOpts

CounterOpts is an alias for Opts. See there for doc comments.

```go
type CounterOpts Opts
```

## type CounterVec

CounterVec is a Collector that bundles a set of Counters that all share the same Desc, but have different values for their variable labels. This is used if you want to count the same thing partitioned by various dimensions \(e.g. number of HTTP requests, partitioned by response code and method\). Create instances with NewCounterVec.

```go
type CounterVec struct {
    *MetricVec
}
```

### func NewCounterVec

```go
func NewCounterVec(opts CounterOpts, labelNames []string) *CounterVec
```

NewCounterVec creates a new CounterVec based on the provided CounterOpts and partitioned by the given label names.

### func \(\*CounterVec\) CurryWith

```go
func (v *CounterVec) CurryWith(labels Labels) (*CounterVec, error)
```

CurryWith returns a vector curried with the provided labels, i.e. the returned vector has those labels pre\-set for all labeled operations performed on it. The cardinality of the curried vector is reduced accordingly. The order of the remaining labels stays the same \(just with the curried labels taken out of the sequence – which is relevant for the \(GetMetric\)WithLabelValues methods\). It is possible to curry a curried vector, but only with labels not yet used for currying before.

The metrics contained in the CounterVec are shared between the curried and uncurried vectors. They are just accessed differently. Curried and uncurried vectors behave identically in terms of collection. Only one must be registered with a given registry \(usually the uncurried version\). The Reset method deletes all metrics, even if called on a curried vector.

### func \(\*CounterVec\) GetMetricWith

```go
func (v *CounterVec) GetMetricWith(labels Labels) (Counter, error)
```

GetMetricWith returns the Counter for the given Labels map \(the label names must match those of the variable labels in Desc\). If that label map is accessed for the first time, a new Counter is created. Implications of creating a Counter without using it and keeping the Counter for later use are the same as for GetMetricWithLabelValues.

An error is returned if the number and names of the Labels are inconsistent with those of the variable labels in Desc \(minus any curried labels\).

This method is used for the same purpose as GetMetricWithLabelValues\(...string\). See there for pros and cons of the two methods.

### func \(\*CounterVec\) GetMetricWithLabelValues

```go
func (v *CounterVec) GetMetricWithLabelValues(lvs ...string) (Counter, error)
```

GetMetricWithLabelValues returns the Counter for the given slice of label values \(same order as the variable labels in Desc\). If that combination of label values is accessed for the first time, a new Counter is created.

It is possible to call this method without using the returned Counter to only create the new Counter but leave it at its starting value 0. See also the SummaryVec example.

Keeping the Counter for later use is possible \(and should be considered if performance is critical\), but keep in mind that Reset, DeleteLabelValues and Delete can be used to delete the Counter from the CounterVec. In that case, the Counter will still exist, but it will not be exported anymore, even if a Counter with the same label values is created later.

An error is returned if the number of label values is not the same as the number of variable labels in Desc \(minus any curried labels\).

Note that for more than one label value, this method is prone to mistakes caused by an incorrect order of arguments. Consider GetMetricWith\(Labels\) as an alternative to avoid that type of mistake. For higher label numbers, the latter has a much more readable \(albeit more verbose\) syntax, but it comes with a performance overhead \(for creating and processing the Labels map\). See also the GaugeVec example.

### func \(\*CounterVec\) MustCurryWith

```go
func (v *CounterVec) MustCurryWith(labels Labels) *CounterVec
```

MustCurryWith works as CurryWith but panics where CurryWith would have returned an error.

### func \(\*CounterVec\) With

```go
func (v *CounterVec) With(labels Labels) Counter
```

With works as GetMetricWith, but panics where GetMetricWithLabels would have returned an error. Not returning an error allows shortcuts like

```
myVec.With(prometheus.Labels{"code": "404", "method": "GET"}).Add(42)
```

### func \(\*CounterVec\) WithLabelValues

```go
func (v *CounterVec) WithLabelValues(lvs ...string) Counter
```

WithLabelValues works as GetMetricWithLabelValues, but panics where GetMetricWithLabelValues would have returned an error. Not returning an error allows shortcuts like

```
myVec.WithLabelValues("404", "GET").Add(42)
```

## type Desc

Desc is the descriptor used by every Prometheus Metric. It is essentially the immutable meta\-data of a Metric. The normal Metric implementations included in this package manage their Desc under the hood. Users only have to deal with Desc if they use advanced features like the ExpvarCollector or custom Collectors and Metrics.

Descriptors registered with the same registry have to fulfill certain consistency and uniqueness criteria if they share the same fully\-qualified name: They must have the same help string and the same label names \(aka label dimensions\) in each, constLabels and variableLabels, but they must differ in the values of the constLabels.

Descriptors that share the same fully\-qualified names and the same label values of their constLabels are considered equal.

Use NewDesc to create new Desc instances.

```go
type Desc struct {
    // contains filtered or unexported fields
}
```

### func NewDesc

```go
func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc
```

NewDesc allocates and initializes a new Desc. Errors are recorded in the Desc and will be reported on registration time. variableLabels and constLabels can be nil if no such labels should be set. fqName must not be empty.

variableLabels only contain the label names. Their label values are variable and therefore not part of the Desc. \(They are managed within the Metric.\)

For constLabels, the label values are constant. Therefore, they are fully specified in the Desc. See the Collector example for a usage pattern.

### func NewInvalidDesc

```go
func NewInvalidDesc(err error) *Desc
```

NewInvalidDesc returns an invalid descriptor, i.e. a descriptor with the provided error set. If a collector returning such a descriptor is registered, registration will fail with the provided error. NewInvalidDesc can be used by a Collector to signal inability to describe itself.

### func \(\*Desc\) String

```go
func (d *Desc) String() string
```

## type Exemplar

Exemplar is easier to use, user\-facing representation of \*dto.Exemplar.

```go
type Exemplar struct {
    Value  float64
    Labels Labels
    // Optional.
    // Default value (time.Time{}) indicates its empty, which should be
    // understood as time.Now() time at the moment of creation of metric.
    Timestamp time.Time
}
```

## type ExemplarAdder

ExemplarAdder is implemented by Counters that offer the option of adding a value to the Counter together with an exemplar. Its AddWithExemplar method works like the Add method of the Counter interface but also replaces the currently saved exemplar \(if any\) with a new one, created from the provided value, the current time as timestamp, and the provided labels. Empty Labels will lead to a valid \(label\-less\) exemplar. But if Labels is nil, the current exemplar is left in place. AddWithExemplar panics if the value is \< 0, if any of the provided labels are invalid, or if the provided labels contain more than 128 runes in total.

```go
type ExemplarAdder interface {
    AddWithExemplar(value float64, exemplar Labels)
}
```

## type ExemplarObserver

ExemplarObserver is implemented by Observers that offer the option of observing a value together with an exemplar. Its ObserveWithExemplar method works like the Observe method of an Observer but also replaces the currently saved exemplar \(if any\) with a new one, created from the provided value, the current time as timestamp, and the provided Labels. Empty Labels will lead to a valid \(label\-less\) exemplar. But if Labels is nil, the current exemplar is left in place. ObserveWithExemplar panics if any of the provided labels are invalid or if the provided labels contain more than 128 runes in total.

```go
type ExemplarObserver interface {
    ObserveWithExemplar(value float64, exemplar Labels)
}
```

## type Gatherer

Gatherer is the interface for the part of a registry in charge of gathering the collected metrics into a number of MetricFamilies. The Gatherer interface comes with the same general implication as described for the Registerer interface.

```go
type Gatherer interface {
    // Gather calls the Collect method of the registered Collectors and then
    // gathers the collected metrics into a lexicographically sorted slice
    // of uniquely named MetricFamily protobufs. Gather ensures that the
    // returned slice is valid and self-consistent so that it can be used
    // for valid exposition. As an exception to the strict consistency
    // requirements described for metric.Desc, Gather will tolerate
    // different sets of label names for metrics of the same metric family.
    //
    // Even if an error occurs, Gather attempts to gather as many metrics as
    // possible. Hence, if a non-nil error is returned, the returned
    // MetricFamily slice could be nil (in case of a fatal error that
    // prevented any meaningful metric collection) or contain a number of
    // MetricFamily protobufs, some of which might be incomplete, and some
    // might be missing altogether. The returned error (which might be a
    // MultiError) explains the details. Note that this is mostly useful for
    // debugging purposes. If the gathered protobufs are to be used for
    // exposition in actual monitoring, it is almost always better to not
    // expose an incomplete result and instead disregard the returned
    // MetricFamily protobufs in case the returned error is non-nil.
    Gather() ([]*dto.MetricFamily, error)
}
```

## type GathererFunc

GathererFunc turns a function into a Gatherer.

```go
type GathererFunc func() ([]*dto.MetricFamily, error)
```

### func \(GathererFunc\) Gather

```go
func (gf GathererFunc) Gather() ([]*dto.MetricFamily, error)
```

Gather implements Gatherer.

## type Gatherers

Gatherers is a slice of Gatherer instances that implements the Gatherer interface itself. Its Gather method calls Gather on all Gatherers in the slice in order and returns the merged results. Errors returned from the Gather calls are all returned in a flattened MultiError. Duplicate and inconsistent Metrics are skipped \(first occurrence in slice order wins\) and reported in the returned error.

Gatherers can be used to merge the Gather results from multiple Registries. It also provides a way to directly inject existing MetricFamily protobufs into the gathering by creating a custom Gatherer with a Gather method that simply returns the existing MetricFamily protobufs. Note that no registration is involved \(in contrast to Collector registration\), so obviously registration\-time checks cannot happen. Any inconsistencies between the gathered MetricFamilies are reported as errors by the Gather method, and inconsistent Metrics are dropped. Invalid parts of the MetricFamilies \(e.g. syntactically invalid metric or label names\) will go undetected.

```go
type Gatherers []Gatherer
```

### func \(Gatherers\) Gather

```go
func (gs Gatherers) Gather() ([]*dto.MetricFamily, error)
```

Gather implements Gatherer.

## type Gauge

Gauge is a Metric that represents a single numerical value that can arbitrarily go up and down.

A Gauge is typically used for measured values like temperatures or current memory usage, but also "counts" that can go up and down, like the number of running goroutines.

To create Gauge instances, use NewGauge.

```go
type Gauge interface {
    Metric
    Collector

    // Set sets the Gauge to an arbitrary value.
    Set(float64)
    // Inc increments the Gauge by 1. Use Add to increment it by arbitrary
    // values.
    Inc()
    // Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary
    // values.
    Dec()
    // Add adds the given value to the Gauge. (The value can be negative,
    // resulting in a decrease of the Gauge.)
    Add(float64)
    // Sub subtracts the given value from the Gauge. (The value can be
    // negative, resulting in an increase of the Gauge.)
    Sub(float64)

    // SetToCurrentTime sets the Gauge to the current Unix time in seconds.
    SetToCurrentTime()
}
```

### func NewGauge

```go
func NewGauge(opts GaugeOpts) Gauge
```

NewGauge creates a new Gauge based on the provided GaugeOpts.

The returned implementation is optimized for a fast Set method. If you have a choice for managing the value of a Gauge via Set vs. Inc/Dec/Add/Sub, pick the former. For example, the Inc method of the returned Gauge is slower than the Inc method of a Counter returned by NewCounter. This matches the typical scenarios for Gauges and Counters, where the former tends to be Set\-heavy and the latter Inc\-heavy.

## type GaugeFunc

GaugeFunc is a Gauge whose value is determined at collect time by calling a provided function.

To create GaugeFunc instances, use NewGaugeFunc.

```go
type GaugeFunc interface {
    Metric
    Collector
}
```

### func NewGaugeFunc

```go
func NewGaugeFunc(opts GaugeOpts, function func() float64) GaugeFunc
```

NewGaugeFunc creates a new GaugeFunc based on the provided GaugeOpts. The value reported is determined by calling the given function from within the Write method. Take into account that metric collection may happen concurrently. Therefore, it must be safe to call the provided function concurrently.

NewGaugeFunc is a good way to create an “info” style metric with a constant value of 1. Example: https://github.com/prometheus/common/blob/8558a5b7db3c84fa38b4766966059a7bd5bfa2ee/version/info.go#L36-L56

## type GaugeOpts

GaugeOpts is an alias for Opts. See there for doc comments.

```go
type GaugeOpts Opts
```

## type GaugeVec

GaugeVec is a Collector that bundles a set of Gauges that all share the same Desc, but have different values for their variable labels. This is used if you want to count the same thing partitioned by various dimensions \(e.g. number of operations queued, partitioned by user and operation type\). Create instances with NewGaugeVec.

```go
type GaugeVec struct {
    *MetricVec
}
```

### func NewGaugeVec

```go
func NewGaugeVec(opts GaugeOpts, labelNames []string) *GaugeVec
```

NewGaugeVec creates a new GaugeVec based on the provided GaugeOpts and partitioned by the given label names.

### func \(\*GaugeVec\) CurryWith

```go
func (v *GaugeVec) CurryWith(labels Labels) (*GaugeVec, error)
```

CurryWith returns a vector curried with the provided labels, i.e. the returned vector has those labels pre\-set for all labeled operations performed on it. The cardinality of the curried vector is reduced accordingly. The order of the remaining labels stays the same \(just with the curried labels taken out of the sequence – which is relevant for the \(GetMetric\)WithLabelValues methods\). It is possible to curry a curried vector, but only with labels not yet used for currying before.

The metrics contained in the GaugeVec are shared between the curried and uncurried vectors. They are just accessed differently. Curried and uncurried vectors behave identically in terms of collection. Only one must be registered with a given registry \(usually the uncurried version\). The Reset method deletes all metrics, even if called on a curried vector.

### func \(\*GaugeVec\) GetMetricWith

```go
func (v *GaugeVec) GetMetricWith(labels Labels) (Gauge, error)
```

GetMetricWith returns the Gauge for the given Labels map \(the label names must match those of the variable labels in Desc\). If that label map is accessed for the first time, a new Gauge is created. Implications of creating a Gauge without using it and keeping the Gauge for later use are the same as for GetMetricWithLabelValues.

An error is returned if the number and names of the Labels are inconsistent with those of the variable labels in Desc \(minus any curried labels\).

This method is used for the same purpose as GetMetricWithLabelValues\(...string\). See there for pros and cons of the two methods.

### func \(\*GaugeVec\) GetMetricWithLabelValues

```go
func (v *GaugeVec) GetMetricWithLabelValues(lvs ...string) (Gauge, error)
```

GetMetricWithLabelValues returns the Gauge for the given slice of label values \(same order as the variable labels in Desc\). If that combination of label values is accessed for the first time, a new Gauge is created.

It is possible to call this method without using the returned Gauge to only create the new Gauge but leave it at its starting value 0. See also the SummaryVec example.

Keeping the Gauge for later use is possible \(and should be considered if performance is critical\), but keep in mind that Reset, DeleteLabelValues and Delete can be used to delete the Gauge from the GaugeVec. In that case, the Gauge will still exist, but it will not be exported anymore, even if a Gauge with the same label values is created later. See also the CounterVec example.

An error is returned if the number of label values is not the same as the number of variable labels in Desc \(minus any curried labels\).

Note that for more than one label value, this method is prone to mistakes caused by an incorrect order of arguments. Consider GetMetricWith\(Labels\) as an alternative to avoid that type of mistake. For higher label numbers, the latter has a much more readable \(albeit more verbose\) syntax, but it comes with a performance overhead \(for creating and processing the Labels map\).

### func \(\*GaugeVec\) MustCurryWith

```go
func (v *GaugeVec) MustCurryWith(labels Labels) *GaugeVec
```

MustCurryWith works as CurryWith but panics where CurryWith would have returned an error.

### func \(\*GaugeVec\) With

```go
func (v *GaugeVec) With(labels Labels) Gauge
```

With works as GetMetricWith, but panics where GetMetricWithLabels would have returned an error. Not returning an error allows shortcuts like

```
myVec.With(prometheus.Labels{"code": "404", "method": "GET"}).Add(42)
```

### func \(\*GaugeVec\) WithLabelValues

```go
func (v *GaugeVec) WithLabelValues(lvs ...string) Gauge
```

WithLabelValues works as GetMetricWithLabelValues, but panics where GetMetricWithLabelValues would have returned an error. Not returning an error allows shortcuts like

```
myVec.WithLabelValues("404", "GET").Add(42)
```

## type Histogram

A Histogram counts individual observations from an event or sample stream in configurable static buckets \(or in dynamic sparse buckets as part of the experimental Native Histograms, see below for more details\). Similar to a Summary, it also provides a sum of observations and an observation count.

On the Prometheus server, quantiles can be calculated from a Histogram using the histogram\_quantile PromQL function.

Note that Histograms, in contrast to Summaries, can be aggregated in PromQL \(see the documentation for detailed procedures\). However, Histograms require the user to pre\-define suitable buckets, and they are in general less accurate. \(Both problems are addressed by the experimental Native Histograms. To use them, configure a NativeHistogramBucketFactor in the HistogramOpts. They also require a Prometheus server v2.40\+ with the corresponding feature flag enabled.\)

The Observe method of a Histogram has a very low performance overhead in comparison with the Observe method of a Summary.

To create Histogram instances, use NewHistogram.

```go
type Histogram interface {
    Metric
    Collector

    // Observe adds a single observation to the histogram. Observations are
    // usually positive or zero. Negative observations are accepted but
    // prevent current versions of Prometheus from properly detecting
    // counter resets in the sum of observations. (The experimental Native
    // Histograms handle negative observations properly.) See
    // https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
    // for details.
    Observe(float64)
}
```

### func NewHistogram

```go
func NewHistogram(opts HistogramOpts) Histogram
```

NewHistogram creates a new Histogram based on the provided HistogramOpts. It panics if the buckets in HistogramOpts are not in strictly increasing order.

The returned implementation also implements ExemplarObserver. It is safe to perform the corresponding type assertion. Exemplars are tracked separately for each bucket.

## type HistogramOpts

HistogramOpts bundles the options for creating a Histogram metric. It is mandatory to set Name to a non\-empty string. All other fields are optional and can safely be left at their zero value, although it is strongly encouraged to set a Help string.

```go
type HistogramOpts struct {
    // Namespace, Subsystem, and Name are components of the fully-qualified
    // name of the Histogram (created by joining these components with
    // "_"). Only Name is mandatory, the others merely help structuring the
    // name. Note that the fully-qualified name of the Histogram must be a
    // valid Prometheus metric name.
    Namespace string
    Subsystem string
    Name      string

    // Help provides information about this Histogram.
    //
    // Metrics with the same fully-qualified name must have the same Help
    // string.
    Help string

    // ConstLabels are used to attach fixed labels to this metric. Metrics
    // with the same fully-qualified name must have the same label names in
    // their ConstLabels.
    //
    // ConstLabels are only used rarely. In particular, do not use them to
    // attach the same labels to all your metrics. Those use cases are
    // better covered by target labels set by the scraping Prometheus
    // server, or by one specific metric (e.g. a build_info or a
    // machine_role metric). See also
    // https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels
    ConstLabels Labels

    // Buckets defines the buckets into which observations are counted. Each
    // element in the slice is the upper inclusive bound of a bucket. The
    // values must be sorted in strictly increasing order. There is no need
    // to add a highest bucket with +Inf bound, it will be added
    // implicitly. If Buckets is left as nil or set to a slice of length
    // zero, it is replaced by default buckets. The default buckets are
    // DefBuckets if no buckets for a native histogram (see below) are used,
    // otherwise the default is no buckets. (In other words, if you want to
    // use both reguler buckets and buckets for a native histogram, you have
    // to define the regular buckets here explicitly.)
    Buckets []float64

    // If NativeHistogramBucketFactor is greater than one, so-called sparse
    // buckets are used (in addition to the regular buckets, if defined
    // above). A Histogram with sparse buckets will be ingested as a Native
    // Histogram by a Prometheus server with that feature enabled (requires
    // Prometheus v2.40+). Sparse buckets are exponential buckets covering
    // the whole float64 range (with the exception of the “zero” bucket, see
    // SparseBucketsZeroThreshold below). From any one bucket to the next,
    // the width of the bucket grows by a constant
    // factor. NativeHistogramBucketFactor provides an upper bound for this
    // factor (exception see below). The smaller
    // NativeHistogramBucketFactor, the more buckets will be used and thus
    // the more costly the histogram will become. A generally good trade-off
    // between cost and accuracy is a value of 1.1 (each bucket is at most
    // 10% wider than the previous one), which will result in each power of
    // two divided into 8 buckets (e.g. there will be 8 buckets between 1
    // and 2, same as between 2 and 4, and 4 and 8, etc.).
    //
    // Details about the actually used factor: The factor is calculated as
    // 2^(2^n), where n is an integer number between (and including) -8 and
    // 4. n is chosen so that the resulting factor is the largest that is
    // still smaller or equal to NativeHistogramBucketFactor. Note that the
    // smallest possible factor is therefore approx. 1.00271 (i.e. 2^(2^-8)
    // ). If NativeHistogramBucketFactor is greater than 1 but smaller than
    // 2^(2^-8), then the actually used factor is still 2^(2^-8) even though
    // it is larger than the provided NativeHistogramBucketFactor.
    //
    // NOTE: Native Histograms are still an experimental feature. Their
    // behavior might still change without a major version
    // bump. Subsequently, all NativeHistogram... options here might still
    // change their behavior or name (or might completely disappear) without
    // a major version bump.
    NativeHistogramBucketFactor float64
    // All observations with an absolute value of less or equal
    // NativeHistogramZeroThreshold are accumulated into a “zero”
    // bucket. For best results, this should be close to a bucket
    // boundary. This is usually the case if picking a power of two. If
    // NativeHistogramZeroThreshold is left at zero,
    // DefSparseBucketsZeroThreshold is used as the threshold. To configure
    // a zero bucket with an actual threshold of zero (i.e. only
    // observations of precisely zero will go into the zero bucket), set
    // NativeHistogramZeroThreshold to the NativeHistogramZeroThresholdZero
    // constant (or any negative float value).
    NativeHistogramZeroThreshold float64

    // The remaining fields define a strategy to limit the number of
    // populated sparse buckets. If NativeHistogramMaxBucketNumber is left
    // at zero, the number of buckets is not limited. (Note that this might
    // lead to unbounded memory consumption if the values observed by the
    // Histogram are sufficiently wide-spread. In particular, this could be
    // used as a DoS attack vector. Where the observed values depend on
    // external inputs, it is highly recommended to set a
    // NativeHistogramMaxBucketNumber.)  Once the set
    // NativeHistogramMaxBucketNumber is exceeded, the following strategy is
    // enacted: First, if the last reset (or the creation) of the histogram
    // is at least NativeHistogramMinResetDuration ago, then the whole
    // histogram is reset to its initial state (including regular
    // buckets). If less time has passed, or if
    // NativeHistogramMinResetDuration is zero, no reset is
    // performed. Instead, the zero threshold is increased sufficiently to
    // reduce the number of buckets to or below
    // NativeHistogramMaxBucketNumber, but not to more than
    // NativeHistogramMaxZeroThreshold. Thus, if
    // NativeHistogramMaxZeroThreshold is already at or below the current
    // zero threshold, nothing happens at this step. After that, if the
    // number of buckets still exceeds NativeHistogramMaxBucketNumber, the
    // resolution of the histogram is reduced by doubling the width of the
    // sparse buckets (up to a growth factor between one bucket to the next
    // of 2^(2^4) = 65536, see above).
    NativeHistogramMaxBucketNumber  uint32
    NativeHistogramMinResetDuration time.Duration
    NativeHistogramMaxZeroThreshold float64
}
```

## type HistogramVec

HistogramVec is a Collector that bundles a set of Histograms that all share the same Desc, but have different values for their variable labels. This is used if you want to count the same thing partitioned by various dimensions \(e.g. HTTP request latencies, partitioned by status code and method\). Create instances with NewHistogramVec.

```go
type HistogramVec struct {
    *MetricVec
}
```

### func NewHistogramVec

```go
func NewHistogramVec(opts HistogramOpts, labelNames []string) *HistogramVec
```

NewHistogramVec creates a new HistogramVec based on the provided HistogramOpts and partitioned by the given label names.

### func \(\*HistogramVec\) CurryWith

```go
func (v *HistogramVec) CurryWith(labels Labels) (ObserverVec, error)
```

CurryWith returns a vector curried with the provided labels, i.e. the returned vector has those labels pre\-set for all labeled operations performed on it. The cardinality of the curried vector is reduced accordingly. The order of the remaining labels stays the same \(just with the curried labels taken out of the sequence – which is relevant for the \(GetMetric\)WithLabelValues methods\). It is possible to curry a curried vector, but only with labels not yet used for currying before.

The metrics contained in the HistogramVec are shared between the curried and uncurried vectors. They are just accessed differently. Curried and uncurried vectors behave identically in terms of collection. Only one must be registered with a given registry \(usually the uncurried version\). The Reset method deletes all metrics, even if called on a curried vector.

### func \(\*HistogramVec\) GetMetricWith

```go
func (v *HistogramVec) GetMetricWith(labels Labels) (Observer, error)
```

GetMetricWith returns the Histogram for the given Labels map \(the label names must match those of the variable labels in Desc\). If that label map is accessed for the first time, a new Histogram is created. Implications of creating a Histogram without using it and keeping the Histogram for later use are the same as for GetMetricWithLabelValues.

An error is returned if the number and names of the Labels are inconsistent with those of the variable labels in Desc \(minus any curried labels\).

This method is used for the same purpose as GetMetricWithLabelValues\(...string\). See there for pros and cons of the two methods.

### func \(\*HistogramVec\) GetMetricWithLabelValues

```go
func (v *HistogramVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)
```

GetMetricWithLabelValues returns the Histogram for the given slice of label values \(same order as the variable labels in Desc\). If that combination of label values is accessed for the first time, a new Histogram is created.

It is possible to call this method without using the returned Histogram to only create the new Histogram but leave it at its starting value, a Histogram without any observations.

Keeping the Histogram for later use is possible \(and should be considered if performance is critical\), but keep in mind that Reset, DeleteLabelValues and Delete can be used to delete the Histogram from the HistogramVec. In that case, the Histogram will still exist, but it will not be exported anymore, even if a Histogram with the same label values is created later. See also the CounterVec example.

An error is returned if the number of label values is not the same as the number of variable labels in Desc \(minus any curried labels\).

Note that for more than one label value, this method is prone to mistakes caused by an incorrect order of arguments. Consider GetMetricWith\(Labels\) as an alternative to avoid that type of mistake. For higher label numbers, the latter has a much more readable \(albeit more verbose\) syntax, but it comes with a performance overhead \(for creating and processing the Labels map\). See also the GaugeVec example.

### func \(\*HistogramVec\) MustCurryWith

```go
func (v *HistogramVec) MustCurryWith(labels Labels) ObserverVec
```

MustCurryWith works as CurryWith but panics where CurryWith would have returned an error.

### func \(\*HistogramVec\) With

```go
func (v *HistogramVec) With(labels Labels) Observer
```

With works as GetMetricWith but panics where GetMetricWithLabels would have returned an error. Not returning an error allows shortcuts like

```
myVec.With(prometheus.Labels{"code": "404", "method": "GET"}).Observe(42.21)
```

### func \(\*HistogramVec\) WithLabelValues

```go
func (v *HistogramVec) WithLabelValues(lvs ...string) Observer
```

WithLabelValues works as GetMetricWithLabelValues, but panics where GetMetricWithLabelValues would have returned an error. Not returning an error allows shortcuts like

```
myVec.WithLabelValues("404", "GET").Observe(42.21)
```

## type Labels

Labels represents a collection of label name \-\> value mappings. This type is commonly used with the With\(Labels\) and GetMetricWith\(Labels\) methods of metric vector Collectors, e.g.:

```
myVec.With(Labels{"code": "404", "method": "GET"}).Add(42)
```

The other use\-case is the specification of constant label pairs in Opts or to create a Desc.

```go
type Labels map[string]string
```

## type Metric

A Metric models a single sample value with its meta data being exported to Prometheus. Implementations of Metric in this package are Gauge, Counter, Histogram, Summary, and Untyped.

```go
type Metric interface {
    // Desc returns the descriptor for the Metric. This method idempotently
    // returns the same descriptor throughout the lifetime of the
    // Metric. The returned descriptor is immutable by contract. A Metric
    // unable to describe itself must return an invalid descriptor (created
    // with NewInvalidDesc).
    Desc() *Desc
    // Write encodes the Metric into a "Metric" Protocol Buffer data
    // transmission object.
    //
    // Metric implementations must observe concurrency safety as reads of
    // this metric may occur at any time, and any blocking occurs at the
    // expense of total performance of rendering all registered
    // metrics. Ideally, Metric implementations should support concurrent
    // readers.
    //
    // While populating dto.Metric, it is the responsibility of the
    // implementation to ensure validity of the Metric protobuf (like valid
    // UTF-8 strings or syntactically valid metric and label names). It is
    // recommended to sort labels lexicographically. Callers of Write should
    // still make sure of sorting if they depend on it.
    Write(*dto.Metric) error
}
```

### func MustNewConstHistogram

```go
func MustNewConstHistogram(desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string) Metric
```

MustNewConstHistogram is a version of NewConstHistogram that panics where NewConstHistogram would have returned an error.

### func MustNewConstMetric

```go
func MustNewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) Metric
```

MustNewConstMetric is a version of NewConstMetric that panics where NewConstMetric would have returned an error.

### func MustNewConstSummary

```go
func MustNewConstSummary(desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string) Metric
```

MustNewConstSummary is a version of NewConstSummary that panics where NewConstMetric would have returned an error.

### func MustNewMetricWithExemplars

```go
func MustNewMetricWithExemplars(m Metric, exemplars ...Exemplar) Metric
```

MustNewMetricWithExemplars is a version of NewMetricWithExemplars that panics where NewMetricWithExemplars would have returned an error.

### func NewConstHistogram

```go
func NewConstHistogram(desc *Desc, count uint64, sum float64, buckets map[float64]uint64, labelValues ...string) (Metric, error)
```

NewConstHistogram returns a metric representing a Prometheus histogram with fixed values for the count, sum, and bucket counts. As those parameters cannot be changed, the returned value does not implement the Histogram interface \(but only the Metric interface\). Users of this package will not have much use for it in regular operations. However, when implementing custom Collectors, it is useful as a throw\-away metric that is generated on the fly to send it to Prometheus in the Collect method.

buckets is a map of upper bounds to cumulative counts, excluding the \+Inf bucket. The \+Inf bucket is implicit, and its value is equal to the provided count.

NewConstHistogram returns an error if the length of labelValues is not consistent with the variable labels in Desc or if Desc is invalid.

### func NewConstMetric

```go
func NewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) (Metric, error)
```

NewConstMetric returns a metric with one fixed value that cannot be changed. Users of this package will not have much use for it in regular operations. However, when implementing custom Collectors, it is useful as a throw\-away metric that is generated on the fly to send it to Prometheus in the Collect method. NewConstMetric returns an error if the length of labelValues is not consistent with the variable labels in Desc or if Desc is invalid.

### func NewConstSummary

```go
func NewConstSummary(desc *Desc, count uint64, sum float64, quantiles map[float64]float64, labelValues ...string) (Metric, error)
```

NewConstSummary returns a metric representing a Prometheus summary with fixed values for the count, sum, and quantiles. As those parameters cannot be changed, the returned value does not implement the Summary interface \(but only the Metric interface\). Users of this package will not have much use for it in regular operations. However, when implementing custom Collectors, it is useful as a throw\-away metric that is generated on the fly to send it to Prometheus in the Collect method.

quantiles maps ranks to quantile values. For example, a median latency of 0.23s and a 99th percentile latency of 0.56s would be expressed as:

```
map[float64]float64{0.5: 0.23, 0.99: 0.56}
```

NewConstSummary returns an error if the length of labelValues is not consistent with the variable labels in Desc or if Desc is invalid.

### func NewInvalidMetric

```go
func NewInvalidMetric(desc *Desc, err error) Metric
```

NewInvalidMetric returns a metric whose Write method always returns the provided error. It is useful if a Collector finds itself unable to collect a metric and wishes to report an error to the registry.

### func NewMetricWithExemplars

```go
func NewMetricWithExemplars(m Metric, exemplars ...Exemplar) (Metric, error)
```

NewMetricWithExemplars returns a new Metric wrapping the provided Metric with given exemplars. Exemplars are validated.

Only last applicable exemplar is injected from the list. For example for Counter it means last exemplar is injected. For Histogram, it means last applicable exemplar for each bucket is injected.

NewMetricWithExemplars works best with MustNewConstMetric and MustNewConstHistogram, see example.

### func NewMetricWithTimestamp

```go
func NewMetricWithTimestamp(t time.Time, m Metric) Metric
```

NewMetricWithTimestamp returns a new Metric wrapping the provided Metric in a way that it has an explicit timestamp set to the provided Time. This is only useful in rare cases as the timestamp of a Prometheus metric should usually be set by the Prometheus server during scraping. Exceptions include mirroring metrics with given timestamps from other metric sources.

NewMetricWithTimestamp works best with MustNewConstMetric, MustNewConstHistogram, and MustNewConstSummary, see example.

Currently, the exposition formats used by Prometheus are limited to millisecond resolution. Thus, the provided time will be rounded down to the next full millisecond value.

## type MetricVec

MetricVec is a Collector to bundle metrics of the same name that differ in their label values. MetricVec is not used directly but as a building block for implementations of vectors of a given metric type, like GaugeVec, CounterVec, SummaryVec, and HistogramVec. It is exported so that it can be used for custom Metric implementations.

To create a FooVec for custom Metric Foo, embed a pointer to MetricVec in FooVec and initialize it with NewMetricVec. Implement wrappers for GetMetricWithLabelValues and GetMetricWith that return \(Foo, error\) rather than \(Metric, error\). Similarly, create a wrapper for CurryWith that returns \(\*FooVec, error\) rather than \(\*MetricVec, error\). It is recommended to also add the convenience methods WithLabelValues, With, and MustCurryWith, which panic instead of returning errors. See also the MetricVec example.

```go
type MetricVec struct {
    // contains filtered or unexported fields
}
```

### func NewMetricVec

```go
func NewMetricVec(desc *Desc, newMetric func(lvs ...string) Metric) *MetricVec
```

NewMetricVec returns an initialized metricVec.

### func \(\*MetricVec\) Collect

```go
func (m *MetricVec) Collect(ch chan<- Metric)
```

Collect implements Collector.

### func \(\*MetricVec\) CurryWith

```go
func (m *MetricVec) CurryWith(labels Labels) (*MetricVec, error)
```

CurryWith returns a vector curried with the provided labels, i.e. the returned vector has those labels pre\-set for all labeled operations performed on it. The cardinality of the curried vector is reduced accordingly. The order of the remaining labels stays the same \(just with the curried labels taken out of the sequence – which is relevant for the \(GetMetric\)WithLabelValues methods\). It is possible to curry a curried vector, but only with labels not yet used for currying before.

The metrics contained in the MetricVec are shared between the curried and uncurried vectors. They are just accessed differently. Curried and uncurried vectors behave identically in terms of collection. Only one must be registered with a given registry \(usually the uncurried version\). The Reset method deletes all metrics, even if called on a curried vector.

Note that CurryWith is usually not called directly but through a wrapper around MetricVec, implementing a vector for a specific Metric implementation, for example GaugeVec.

### func \(\*MetricVec\) Delete

```go
func (m *MetricVec) Delete(labels Labels) bool
```

Delete deletes the metric where the variable labels are the same as those passed in as labels. It returns true if a metric was deleted.

It is not an error if the number and names of the Labels are inconsistent with those of the VariableLabels in Desc. However, such inconsistent Labels can never match an actual metric, so the method will always return false in that case.

This method is used for the same purpose as DeleteLabelValues\(...string\). See there for pros and cons of the two methods.

### func \(\*MetricVec\) DeleteLabelValues

```go
func (m *MetricVec) DeleteLabelValues(lvs ...string) bool
```

DeleteLabelValues removes the metric where the variable labels are the same as those passed in as labels \(same order as the VariableLabels in Desc\). It returns true if a metric was deleted.

It is not an error if the number of label values is not the same as the number of VariableLabels in Desc. However, such inconsistent label count can never match an actual metric, so the method will always return false in that case.

Note that for more than one label value, this method is prone to mistakes caused by an incorrect order of arguments. Consider Delete\(Labels\) as an alternative to avoid that type of mistake. For higher label numbers, the latter has a much more readable \(albeit more verbose\) syntax, but it comes with a performance overhead \(for creating and processing the Labels map\). See also the CounterVec example.

### func \(\*MetricVec\) DeletePartialMatch

```go
func (m *MetricVec) DeletePartialMatch(labels Labels) int
```

DeletePartialMatch deletes all metrics where the variable labels contain all of those passed in as labels. The order of the labels does not matter. It returns the number of metrics deleted.

Note that curried labels will never be matched if deleting from the curried vector. To match curried labels with DeletePartialMatch, it must be called on the base vector.

### func \(\*MetricVec\) Describe

```go
func (m *MetricVec) Describe(ch chan<- *Desc)
```

Describe implements Collector.

### func \(\*MetricVec\) GetMetricWith

```go
func (m *MetricVec) GetMetricWith(labels Labels) (Metric, error)
```

GetMetricWith returns the Metric for the given Labels map \(the label names must match those of the variable labels in Desc\). If that label map is accessed for the first time, a new Metric is created. Implications of creating a Metric without using it and keeping the Metric for later use are the same as for GetMetricWithLabelValues.

An error is returned if the number and names of the Labels are inconsistent with those of the variable labels in Desc \(minus any curried labels\).

This method is used for the same purpose as GetMetricWithLabelValues\(...string\). See there for pros and cons of the two methods.

Note that GetMetricWith is usually not called directly but through a wrapper around MetricVec, implementing a vector for a specific Metric implementation, for example GaugeVec.

### func \(\*MetricVec\) GetMetricWithLabelValues

```go
func (m *MetricVec) GetMetricWithLabelValues(lvs ...string) (Metric, error)
```

GetMetricWithLabelValues returns the Metric for the given slice of label values \(same order as the variable labels in Desc\). If that combination of label values is accessed for the first time, a new Metric is created \(by calling the newMetric function provided during construction of the MetricVec\).

It is possible to call this method without using the returned Metric to only create the new Metric but leave it in its initial state.

Keeping the Metric for later use is possible \(and should be considered if performance is critical\), but keep in mind that Reset, DeleteLabelValues and Delete can be used to delete the Metric from the MetricVec. In that case, the Metric will still exist, but it will not be exported anymore, even if a Metric with the same label values is created later.

An error is returned if the number of label values is not the same as the number of variable labels in Desc \(minus any curried labels\).

Note that for more than one label value, this method is prone to mistakes caused by an incorrect order of arguments. Consider GetMetricWith\(Labels\) as an alternative to avoid that type of mistake. For higher label numbers, the latter has a much more readable \(albeit more verbose\) syntax, but it comes with a performance overhead \(for creating and processing the Labels map\).

Note that GetMetricWithLabelValues is usually not called directly but through a wrapper around MetricVec, implementing a vector for a specific Metric implementation, for example GaugeVec.

### func \(\*MetricVec\) Reset

```go
func (m *MetricVec) Reset()
```

Reset deletes all metrics in this vector.

## type MultiError

MultiError is a slice of errors implementing the error interface. It is used by a Gatherer to report multiple errors during MetricFamily gathering.

```go
type MultiError []error
```

### func \(\*MultiError\) Append

```go
func (errs *MultiError) Append(err error)
```

Append appends the provided error if it is not nil.

### func \(MultiError\) Error

```go
func (errs MultiError) Error() string
```

Error formats the contained errors as a bullet point list, preceded by the total number of errors. Note that this results in a multi\-line string.

### func \(MultiError\) MaybeUnwrap

```go
func (errs MultiError) MaybeUnwrap() error
```

MaybeUnwrap returns nil if len\(errs\) is 0. It returns the first and only contained error as error if len\(errs is 1\). In all other cases, it returns the MultiError directly. This is helpful for returning a MultiError in a way that only uses the MultiError if needed.

## type MultiTRegistry

MultiTRegistry is a TransactionalGatherer that joins gathered metrics from multiple transactional gatherers.

It is caller responsibility to ensure two registries have mutually exclusive metric families, no deduplication will happen.

```go
type MultiTRegistry struct {
    // contains filtered or unexported fields
}
```

### func NewMultiTRegistry

```go
func NewMultiTRegistry(tGatherers ...TransactionalGatherer) *MultiTRegistry
```

NewMultiTRegistry creates MultiTRegistry.

### func \(\*MultiTRegistry\) Gather

```go
func (r *MultiTRegistry) Gather() (mfs []*dto.MetricFamily, done func(), err error)
```

Gather implements TransactionalGatherer interface.

## type Observer

Observer is the interface that wraps the Observe method, which is used by Histogram and Summary to add observations.

```go
type Observer interface {
    Observe(float64)
}
```

## type ObserverFunc

The ObserverFunc type is an adapter to allow the use of ordinary functions as Observers. If f is a function with the appropriate signature, ObserverFunc\(f\) is an Observer that calls f.

This adapter is usually used in connection with the Timer type, and there are two general use cases:

The most common one is to use a Gauge as the Observer for a Timer. See the "Gauge" Timer example.

The more advanced use case is to create a function that dynamically decides which Observer to use for observing the duration. See the "Complex" Timer example.

```go
type ObserverFunc func(float64)
```

### func \(ObserverFunc\) Observe

```go
func (f ObserverFunc) Observe(value float64)
```

Observe calls f\(value\). It implements Observer.

## type ObserverVec

ObserverVec is an interface implemented by \`HistogramVec\` and \`SummaryVec\`.

```go
type ObserverVec interface {
    GetMetricWith(Labels) (Observer, error)
    GetMetricWithLabelValues(lvs ...string) (Observer, error)
    With(Labels) Observer
    WithLabelValues(...string) Observer
    CurryWith(Labels) (ObserverVec, error)
    MustCurryWith(Labels) ObserverVec

    Collector
}
```

## type Opts

Opts bundles the options for creating most Metric types. Each metric implementation XXX has its own XXXOpts type, but in most cases, it is just an alias of this type \(which might change when the requirement arises.\)

It is mandatory to set Name to a non\-empty string. All other fields are optional and can safely be left at their zero value, although it is strongly encouraged to set a Help string.

```go
type Opts struct {
    // Namespace, Subsystem, and Name are components of the fully-qualified
    // name of the Metric (created by joining these components with
    // "_"). Only Name is mandatory, the others merely help structuring the
    // name. Note that the fully-qualified name of the metric must be a
    // valid Prometheus metric name.
    Namespace string
    Subsystem string
    Name      string

    // Help provides information about this metric.
    //
    // Metrics with the same fully-qualified name must have the same Help
    // string.
    Help string

    // ConstLabels are used to attach fixed labels to this metric. Metrics
    // with the same fully-qualified name must have the same label names in
    // their ConstLabels.
    //
    // ConstLabels are only used rarely. In particular, do not use them to
    // attach the same labels to all your metrics. Those use cases are
    // better covered by target labels set by the scraping Prometheus
    // server, or by one specific metric (e.g. a build_info or a
    // machine_role metric). See also
    // https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels
    ConstLabels Labels
}
```

## type ProcessCollectorOpts

ProcessCollectorOpts defines the behavior of a process metrics collector created with NewProcessCollector.

```go
type ProcessCollectorOpts struct {
    // PidFn returns the PID of the process the collector collects metrics
    // for. It is called upon each collection. By default, the PID of the
    // current process is used, as determined on construction time by
    // calling os.Getpid().
    PidFn func() (int, error)
    // If non-empty, each of the collected metrics is prefixed by the
    // provided string and an underscore ("_").
    Namespace string
    // If true, any error encountered during collection is reported as an
    // invalid metric (see NewInvalidMetric). Otherwise, errors are ignored
    // and the collected metrics will be incomplete. (Possibly, no metrics
    // will be collected at all.) While that's usually not desired, it is
    // appropriate for the common "mix-in" of process metrics, where process
    // metrics are nice to have, but failing to collect them should not
    // disrupt the collection of the remaining metrics.
    ReportErrors bool
}
```

## type Registerer

Registerer is the interface for the part of a registry in charge of registering and unregistering. Users of custom registries should use Registerer as type for registration purposes \(rather than the Registry type directly\). In that way, they are free to use custom Registerer implementation \(e.g. for testing purposes\).

```go
type Registerer interface {
    // Register registers a new Collector to be included in metrics
    // collection. It returns an error if the descriptors provided by the
    // Collector are invalid or if they — in combination with descriptors of
    // already registered Collectors — do not fulfill the consistency and
    // uniqueness criteria described in the documentation of metric.Desc.
    //
    // If the provided Collector is equal to a Collector already registered
    // (which includes the case of re-registering the same Collector), the
    // returned error is an instance of AlreadyRegisteredError, which
    // contains the previously registered Collector.
    //
    // A Collector whose Describe method does not yield any Desc is treated
    // as unchecked. Registration will always succeed. No check for
    // re-registering (see previous paragraph) is performed. Thus, the
    // caller is responsible for not double-registering the same unchecked
    // Collector, and for providing a Collector that will not cause
    // inconsistent metrics on collection. (This would lead to scrape
    // errors.)
    Register(Collector) error
    // MustRegister works like Register but registers any number of
    // Collectors and panics upon the first registration that causes an
    // error.
    MustRegister(...Collector)
    // Unregister unregisters the Collector that equals the Collector passed
    // in as an argument.  (Two Collectors are considered equal if their
    // Describe method yields the same set of descriptors.) The function
    // returns whether a Collector was unregistered. Note that an unchecked
    // Collector cannot be unregistered (as its Describe method does not
    // yield any descriptor).
    //
    // Note that even after unregistering, it will not be possible to
    // register a new Collector that is inconsistent with the unregistered
    // Collector, e.g. a Collector collecting metrics with the same name but
    // a different help string. The rationale here is that the same registry
    // instance must only collect consistent metrics throughout its
    // lifetime.
    Unregister(Collector) bool
}
```

### func WrapRegistererWith

```go
func WrapRegistererWith(labels Labels, reg Registerer) Registerer
```

WrapRegistererWith returns a Registerer wrapping the provided Registerer. Collectors registered with the returned Registerer will be registered with the wrapped Registerer in a modified way. The modified Collector adds the provided Labels to all Metrics it collects \(as ConstLabels\). The Metrics collected by the unmodified Collector must not duplicate any of those labels. Wrapping a nil value is valid, resulting in a no\-op Registerer.

WrapRegistererWith provides a way to add fixed labels to a subset of Collectors. It should not be used to add fixed labels to all metrics exposed. See also https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels

Conflicts between Collectors registered through the original Registerer with Collectors registered through the wrapping Registerer will still be detected. Any AlreadyRegisteredError returned by the Register method of either Registerer will contain the ExistingCollector in the form it was provided to the respective registry.

The Collector example demonstrates a use of WrapRegistererWith.

### func WrapRegistererWithPrefix

```go
func WrapRegistererWithPrefix(prefix string, reg Registerer) Registerer
```

WrapRegistererWithPrefix returns a Registerer wrapping the provided Registerer. Collectors registered with the returned Registerer will be registered with the wrapped Registerer in a modified way. The modified Collector adds the provided prefix to the name of all Metrics it collects. Wrapping a nil value is valid, resulting in a no\-op Registerer.

WrapRegistererWithPrefix is useful to have one place to prefix all metrics of a sub\-system. To make this work, register metrics of the sub\-system with the wrapping Registerer returned by WrapRegistererWithPrefix. It is rarely useful to use the same prefix for all metrics exposed. In particular, do not prefix metric names that are standardized across applications, as that would break horizontal monitoring, for example the metrics provided by the Go collector \(see NewGoCollector\) and the process collector \(see NewProcessCollector\). \(In fact, those metrics are already prefixed with “go\_” or “process\_”, respectively.\)

Conflicts between Collectors registered through the original Registerer with Collectors registered through the wrapping Registerer will still be detected. Any AlreadyRegisteredError returned by the Register method of either Registerer will contain the ExistingCollector in the form it was provided to the respective registry.

## type Registry

Registry registers Prometheus collectors, collects their metrics, and gathers them into MetricFamilies for exposition. It implements Registerer, Gatherer, and Collector. The zero value is not usable. Create instances with NewRegistry or NewPedanticRegistry.

Registry implements Collector to allow it to be used for creating groups of metrics. See the Grouping example for how this can be done.

```go
type Registry struct {
    // contains filtered or unexported fields
}
```

### func NewPedanticRegistry

```go
func NewPedanticRegistry() *Registry
```

NewPedanticRegistry returns a registry that checks during collection if each collected Metric is consistent with its reported Desc, and if the Desc has actually been registered with the registry. Unchecked Collectors \(those whose Describe method does not yield any descriptors\) are excluded from the check.

Usually, a Registry will be happy as long as the union of all collected Metrics is consistent and valid even if some metrics are not consistent with their own Desc or a Desc provided by their registered Collector. Well\-behaved Collectors and Metrics will only provide consistent Descs. This Registry is useful to test the implementation of Collectors and Metrics.

### func NewRegistry

```go
func NewRegistry() *Registry
```

NewRegistry creates a new vanilla Registry without any Collectors pre\-registered.

### func \(\*Registry\) Collect

```go
func (r *Registry) Collect(ch chan<- Metric)
```

Collect implements Collector.

### func \(\*Registry\) Describe

```go
func (r *Registry) Describe(ch chan<- *Desc)
```

Describe implements Collector.

### func \(\*Registry\) Gather

```go
func (r *Registry) Gather() ([]*dto.MetricFamily, error)
```

Gather implements Gatherer.

### func \(\*Registry\) MustRegister

```go
func (r *Registry) MustRegister(cs ...Collector)
```

MustRegister implements Registerer.

### func \(\*Registry\) Register

```go
func (r *Registry) Register(c Collector) error
```

Register implements Registerer.

### func \(\*Registry\) Unregister

```go
func (r *Registry) Unregister(c Collector) bool
```

Unregister implements Registerer.

## type Summary

A Summary captures individual observations from an event or sample stream and summarizes them in a manner similar to traditional summary statistics: 1. sum of observations, 2. observation count, 3. rank estimations.

A typical use\-case is the observation of request latencies. By default, a Summary provides the median, the 90th and the 99th percentile of the latency as rank estimations. However, the default behavior will change in the upcoming v1.0.0 of the library. There will be no rank estimations at all by default. For a sane transition, it is recommended to set the desired rank estimations explicitly.

Note that the rank estimations cannot be aggregated in a meaningful way with the Prometheus query language \(i.e. you cannot average or add them\). If you need aggregatable quantiles \(e.g. you want the 99th percentile latency of all queries served across all instances of a service\), consider the Histogram metric type. See the Prometheus documentation for more details.

To create Summary instances, use NewSummary.

```go
type Summary interface {
    Metric
    Collector

    // Observe adds a single observation to the summary. Observations are
    // usually positive or zero. Negative observations are accepted but
    // prevent current versions of Prometheus from properly detecting
    // counter resets in the sum of observations. See
    // https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
    // for details.
    Observe(float64)
}
```

### func NewSummary

```go
func NewSummary(opts SummaryOpts) Summary
```

NewSummary creates a new Summary based on the provided SummaryOpts.

## type SummaryOpts

SummaryOpts bundles the options for creating a Summary metric. It is mandatory to set Name to a non\-empty string. While all other fields are optional and can safely be left at their zero value, it is recommended to set a help string and to explicitly set the Objectives field to the desired value as the default value will change in the upcoming v1.0.0 of the library.

```go
type SummaryOpts struct {
    // Namespace, Subsystem, and Name are components of the fully-qualified
    // name of the Summary (created by joining these components with
    // "_"). Only Name is mandatory, the others merely help structuring the
    // name. Note that the fully-qualified name of the Summary must be a
    // valid Prometheus metric name.
    Namespace string
    Subsystem string
    Name      string

    // Help provides information about this Summary.
    //
    // Metrics with the same fully-qualified name must have the same Help
    // string.
    Help string

    // ConstLabels are used to attach fixed labels to this metric. Metrics
    // with the same fully-qualified name must have the same label names in
    // their ConstLabels.
    //
    // Due to the way a Summary is represented in the Prometheus text format
    // and how it is handled by the Prometheus server internally, “quantile”
    // is an illegal label name. Construction of a Summary or SummaryVec
    // will panic if this label name is used in ConstLabels.
    //
    // ConstLabels are only used rarely. In particular, do not use them to
    // attach the same labels to all your metrics. Those use cases are
    // better covered by target labels set by the scraping Prometheus
    // server, or by one specific metric (e.g. a build_info or a
    // machine_role metric). See also
    // https://prometheus.io/docs/instrumenting/writing_exporters/#target-labels-not-static-scraped-labels
    ConstLabels Labels

    // Objectives defines the quantile rank estimates with their respective
    // absolute error. If Objectives[q] = e, then the value reported for q
    // will be the φ-quantile value for some φ between q-e and q+e.  The
    // default value is an empty map, resulting in a summary without
    // quantiles.
    Objectives map[float64]float64

    // MaxAge defines the duration for which an observation stays relevant
    // for the summary. Only applies to pre-calculated quantiles, does not
    // apply to _sum and _count. Must be positive. The default value is
    // DefMaxAge.
    MaxAge time.Duration

    // AgeBuckets is the number of buckets used to exclude observations that
    // are older than MaxAge from the summary. A higher number has a
    // resource penalty, so only increase it if the higher resolution is
    // really required. For very high observation rates, you might want to
    // reduce the number of age buckets. With only one age bucket, you will
    // effectively see a complete reset of the summary each time MaxAge has
    // passed. The default value is DefAgeBuckets.
    AgeBuckets uint32

    // BufCap defines the default sample stream buffer size.  The default
    // value of DefBufCap should suffice for most uses. If there is a need
    // to increase the value, a multiple of 500 is recommended (because that
    // is the internal buffer size of the underlying package
    // "github.com/bmizerany/perks/quantile").
    BufCap uint32
}
```

## type SummaryVec

SummaryVec is a Collector that bundles a set of Summaries that all share the same Desc, but have different values for their variable labels. This is used if you want to count the same thing partitioned by various dimensions \(e.g. HTTP request latencies, partitioned by status code and method\). Create instances with NewSummaryVec.

```go
type SummaryVec struct {
    *MetricVec
}
```

### func NewSummaryVec

```go
func NewSummaryVec(opts SummaryOpts, labelNames []string) *SummaryVec
```

NewSummaryVec creates a new SummaryVec based on the provided SummaryOpts and partitioned by the given label names.

Due to the way a Summary is represented in the Prometheus text format and how it is handled by the Prometheus server internally, “quantile” is an illegal label name. NewSummaryVec will panic if this label name is used.

### func \(\*SummaryVec\) CurryWith

```go
func (v *SummaryVec) CurryWith(labels Labels) (ObserverVec, error)
```

CurryWith returns a vector curried with the provided labels, i.e. the returned vector has those labels pre\-set for all labeled operations performed on it. The cardinality of the curried vector is reduced accordingly. The order of the remaining labels stays the same \(just with the curried labels taken out of the sequence – which is relevant for the \(GetMetric\)WithLabelValues methods\). It is possible to curry a curried vector, but only with labels not yet used for currying before.

The metrics contained in the SummaryVec are shared between the curried and uncurried vectors. They are just accessed differently. Curried and uncurried vectors behave identically in terms of collection. Only one must be registered with a given registry \(usually the uncurried version\). The Reset method deletes all metrics, even if called on a curried vector.

### func \(\*SummaryVec\) GetMetricWith

```go
func (v *SummaryVec) GetMetricWith(labels Labels) (Observer, error)
```

GetMetricWith returns the Summary for the given Labels map \(the label names must match those of the variable labels in Desc\). If that label map is accessed for the first time, a new Summary is created. Implications of creating a Summary without using it and keeping the Summary for later use are the same as for GetMetricWithLabelValues.

An error is returned if the number and names of the Labels are inconsistent with those of the variable labels in Desc \(minus any curried labels\).

This method is used for the same purpose as GetMetricWithLabelValues\(...string\). See there for pros and cons of the two methods.

### func \(\*SummaryVec\) GetMetricWithLabelValues

```go
func (v *SummaryVec) GetMetricWithLabelValues(lvs ...string) (Observer, error)
```

GetMetricWithLabelValues returns the Summary for the given slice of label values \(same order as the variable labels in Desc\). If that combination of label values is accessed for the first time, a new Summary is created.

It is possible to call this method without using the returned Summary to only create the new Summary but leave it at its starting value, a Summary without any observations.

Keeping the Summary for later use is possible \(and should be considered if performance is critical\), but keep in mind that Reset, DeleteLabelValues and Delete can be used to delete the Summary from the SummaryVec. In that case, the Summary will still exist, but it will not be exported anymore, even if a Summary with the same label values is created later. See also the CounterVec example.

An error is returned if the number of label values is not the same as the number of variable labels in Desc \(minus any curried labels\).

Note that for more than one label value, this method is prone to mistakes caused by an incorrect order of arguments. Consider GetMetricWith\(Labels\) as an alternative to avoid that type of mistake. For higher label numbers, the latter has a much more readable \(albeit more verbose\) syntax, but it comes with a performance overhead \(for creating and processing the Labels map\). See also the GaugeVec example.

### func \(\*SummaryVec\) MustCurryWith

```go
func (v *SummaryVec) MustCurryWith(labels Labels) ObserverVec
```

MustCurryWith works as CurryWith but panics where CurryWith would have returned an error.

### func \(\*SummaryVec\) With

```go
func (v *SummaryVec) With(labels Labels) Observer
```

With works as GetMetricWith, but panics where GetMetricWithLabels would have returned an error. Not returning an error allows shortcuts like

```
myVec.With(prometheus.Labels{"code": "404", "method": "GET"}).Observe(42.21)
```

### func \(\*SummaryVec\) WithLabelValues

```go
func (v *SummaryVec) WithLabelValues(lvs ...string) Observer
```

WithLabelValues works as GetMetricWithLabelValues, but panics where GetMetricWithLabelValues would have returned an error. Not returning an error allows shortcuts like

```
myVec.WithLabelValues("404", "GET").Observe(42.21)
```

## type Timer

Timer is a helper type to time functions. Use NewTimer to create new instances.

```go
type Timer struct {
    // contains filtered or unexported fields
}
```

### func NewTimer

```go
func NewTimer(o Observer) *Timer
```

NewTimer creates a new Timer. The provided Observer is used to observe a duration in seconds. Timer is usually used to time a function call in the following way:

```
func TimeMe() {
    timer := NewTimer(myHistogram)
    defer timer.ObserveDuration()
    // Do actual work.
}
```

### func \(\*Timer\) ObserveDuration

```go
func (t *Timer) ObserveDuration() time.Duration
```

ObserveDuration records the duration passed since the Timer was created with NewTimer. It calls the Observe method of the Observer provided during construction with the duration in seconds as an argument. The observed duration is also returned. ObserveDuration is usually called with a defer statement.

Note that this method is only guaranteed to never observe negative durations if used with Go1.9\+.

## type TransactionalGatherer

TransactionalGatherer represents transactional gatherer that can be triggered to notify gatherer that memory used by metric family is no longer used by a caller. This allows implementations with cache.

```go
type TransactionalGatherer interface {
    // Gather returns metrics in a lexicographically sorted slice
    // of uniquely named MetricFamily protobufs. Gather ensures that the
    // returned slice is valid and self-consistent so that it can be used
    // for valid exposition. As an exception to the strict consistency
    // requirements described for metric.Desc, Gather will tolerate
    // different sets of label names for metrics of the same metric family.
    //
    // Even if an error occurs, Gather attempts to gather as many metrics as
    // possible. Hence, if a non-nil error is returned, the returned
    // MetricFamily slice could be nil (in case of a fatal error that
    // prevented any meaningful metric collection) or contain a number of
    // MetricFamily protobufs, some of which might be incomplete, and some
    // might be missing altogether. The returned error (which might be a
    // MultiError) explains the details. Note that this is mostly useful for
    // debugging purposes. If the gathered protobufs are to be used for
    // exposition in actual monitoring, it is almost always better to not
    // expose an incomplete result and instead disregard the returned
    // MetricFamily protobufs in case the returned error is non-nil.
    //
    // Important: done is expected to be triggered (even if the error occurs!)
    // once caller does not need returned slice of dto.MetricFamily.
    Gather() (_ []*dto.MetricFamily, done func(), err error)
}
```

### func ToTransactionalGatherer

```go
func ToTransactionalGatherer(g Gatherer) TransactionalGatherer
```

ToTransactionalGatherer transforms Gatherer to transactional one with noop as done function.

## type UntypedFunc

UntypedFunc works like GaugeFunc but the collected metric is of type "Untyped". UntypedFunc is useful to mirror an external metric of unknown type.

To create UntypedFunc instances, use NewUntypedFunc.

```go
type UntypedFunc interface {
    Metric
    Collector
}
```

### func NewUntypedFunc

```go
func NewUntypedFunc(opts UntypedOpts, function func() float64) UntypedFunc
```

NewUntypedFunc creates a new UntypedFunc based on the provided UntypedOpts. The value reported is determined by calling the given function from within the Write method. Take into account that metric collection may happen concurrently. If that results in concurrent calls to Write, like in the case where an UntypedFunc is directly registered with Prometheus, the provided function must be concurrency\-safe.

## type UntypedOpts

UntypedOpts is an alias for Opts. See there for doc comments.

```go
type UntypedOpts Opts
```

## type ValueType

ValueType is an enumeration of metric types that represent a simple value.

```go
type ValueType int
```

### func \(ValueType\) ToDTO

```go
func (v ValueType) ToDTO() *dto.MetricType
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
