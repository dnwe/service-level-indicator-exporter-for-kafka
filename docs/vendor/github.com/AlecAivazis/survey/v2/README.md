<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# survey

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/AlecAivazis/survey/v2"
```

## Index

- [Variables](<#variables>)
- [func Ask(qs []*Question, response interface{}, opts ...AskOpt) error](<#func-ask>)
- [func AskOne(p Prompt, response interface{}, opts ...AskOpt) error](<#func-askone>)
- [func Required(val interface{}) error](<#func-required>)
- [func Title(ans interface{}) interface{}](<#func-title>)
- [func ToLower(ans interface{}) interface{}](<#func-tolower>)
- [type AskOpt](<#type-askopt>)
  - [func WithFilter(filter func(filter string, value string, index int) (include bool)) AskOpt](<#func-withfilter>)
  - [func WithHelpInput(r rune) AskOpt](<#func-withhelpinput>)
  - [func WithIcons(setIcons func(*IconSet)) AskOpt](<#func-withicons>)
  - [func WithKeepFilter(KeepFilter bool) AskOpt](<#func-withkeepfilter>)
  - [func WithPageSize(pageSize int) AskOpt](<#func-withpagesize>)
  - [func WithRemoveSelectAll() AskOpt](<#func-withremoveselectall>)
  - [func WithRemoveSelectNone() AskOpt](<#func-withremoveselectnone>)
  - [func WithShowCursor(ShowCursor bool) AskOpt](<#func-withshowcursor>)
  - [func WithStdio(in terminal.FileReader, out terminal.FileWriter, err io.Writer) AskOpt](<#func-withstdio>)
  - [func WithValidator(v Validator) AskOpt](<#func-withvalidator>)
- [type AskOptions](<#type-askoptions>)
- [type Confirm](<#type-confirm>)
  - [func (c *Confirm) Cleanup(config *PromptConfig, val interface{}) error](<#func-confirm-cleanup>)
  - [func (c *Confirm) Prompt(config *PromptConfig) (interface{}, error)](<#func-confirm-prompt>)
- [type ConfirmTemplateData](<#type-confirmtemplatedata>)
- [type Editor](<#type-editor>)
  - [func (e *Editor) Cleanup(config *PromptConfig, val interface{}) error](<#func-editor-cleanup>)
  - [func (e *Editor) Prompt(config *PromptConfig) (interface{}, error)](<#func-editor-prompt>)
  - [func (e *Editor) PromptAgain(config *PromptConfig, invalid interface{}, err error) (interface{}, error)](<#func-editor-promptagain>)
- [type EditorTemplateData](<#type-editortemplatedata>)
- [type ErrorTemplateData](<#type-errortemplatedata>)
- [type Icon](<#type-icon>)
- [type IconSet](<#type-iconset>)
- [type Input](<#type-input>)
  - [func (i *Input) Cleanup(config *PromptConfig, val interface{}) error](<#func-input-cleanup>)
  - [func (i *Input) Prompt(config *PromptConfig) (interface{}, error)](<#func-input-prompt>)
- [type InputTemplateData](<#type-inputtemplatedata>)
- [type IterableOpts](<#type-iterableopts>)
- [type MultiSelect](<#type-multiselect>)
  - [func (m *MultiSelect) Cleanup(config *PromptConfig, val interface{}) error](<#func-multiselect-cleanup>)
  - [func (m *MultiSelect) OnChange(key rune, config *PromptConfig)](<#func-multiselect-onchange>)
  - [func (m *MultiSelect) Prompt(config *PromptConfig) (interface{}, error)](<#func-multiselect-prompt>)
- [type MultiSelectTemplateData](<#type-multiselecttemplatedata>)
  - [func (m MultiSelectTemplateData) IterateOption(ix int, opt core.OptionAnswer) interface{}](<#func-multiselecttemplatedata-iterateoption>)
- [type Multiline](<#type-multiline>)
  - [func (i *Multiline) Cleanup(config *PromptConfig, val interface{}) error](<#func-multiline-cleanup>)
  - [func (i *Multiline) Prompt(config *PromptConfig) (interface{}, error)](<#func-multiline-prompt>)
- [type MultilineTemplateData](<#type-multilinetemplatedata>)
- [type OptionAnswer](<#type-optionanswer>)
- [type Password](<#type-password>)
  - [func (prompt *Password) Cleanup(config *PromptConfig, val interface{}) error](<#func-password-cleanup>)
  - [func (p *Password) Prompt(config *PromptConfig) (interface{}, error)](<#func-password-prompt>)
- [type PasswordTemplateData](<#type-passwordtemplatedata>)
- [type Prompt](<#type-prompt>)
- [type PromptAgainer](<#type-promptagainer>)
- [type PromptConfig](<#type-promptconfig>)
- [type Question](<#type-question>)
- [type Renderer](<#type-renderer>)
  - [func (r *Renderer) AppendRenderedText(text string)](<#func-renderer-appendrenderedtext>)
  - [func (r *Renderer) Error(config *PromptConfig, invalid error) error](<#func-renderer-error>)
  - [func (r *Renderer) NewCursor() *terminal.Cursor](<#func-renderer-newcursor>)
  - [func (r *Renderer) NewRuneReader() *terminal.RuneReader](<#func-renderer-newrunereader>)
  - [func (r *Renderer) OffsetCursor(offset int)](<#func-renderer-offsetcursor>)
  - [func (r *Renderer) Render(tmpl string, data interface{}) error](<#func-renderer-render>)
  - [func (r *Renderer) RenderWithCursorOffset(tmpl string, data IterableOpts, opts []core.OptionAnswer, idx int) error](<#func-renderer-renderwithcursoroffset>)
  - [func (r *Renderer) Stdio() terminal.Stdio](<#func-renderer-stdio>)
  - [func (r *Renderer) WithStdio(stdio terminal.Stdio)](<#func-renderer-withstdio>)
- [type Select](<#type-select>)
  - [func (s *Select) Cleanup(config *PromptConfig, val interface{}) error](<#func-select-cleanup>)
  - [func (s *Select) OnChange(key rune, config *PromptConfig) bool](<#func-select-onchange>)
  - [func (s *Select) Prompt(config *PromptConfig) (interface{}, error)](<#func-select-prompt>)
- [type SelectTemplateData](<#type-selecttemplatedata>)
  - [func (s SelectTemplateData) GetDescription(opt core.OptionAnswer) string](<#func-selecttemplatedata-getdescription>)
  - [func (s SelectTemplateData) IterateOption(ix int, opt core.OptionAnswer) interface{}](<#func-selecttemplatedata-iterateoption>)
- [type Transformer](<#type-transformer>)
  - [func ComposeTransformers(transformers ...Transformer) Transformer](<#func-composetransformers>)
  - [func TransformString(f func(s string) string) Transformer](<#func-transformstring>)
- [type Validator](<#type-validator>)
  - [func ComposeValidators(validators ...Validator) Validator](<#func-composevalidators>)
  - [func MaxItems(numberItems int) Validator](<#func-maxitems>)
  - [func MaxLength(length int) Validator](<#func-maxlength>)
  - [func MinItems(numberItems int) Validator](<#func-minitems>)
  - [func MinLength(length int) Validator](<#func-minlength>)


## Variables

Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format

```go
var ConfirmQuestionTemplate = `
{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color "reset"}}{{"\n"}}{{end}}
{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color "reset"}}
{{- color "default+hb"}}{{ .Message }} {{color "reset"}}
{{- if .Answer}}
  {{- color "cyan"}}{{.Answer}}{{color "reset"}}{{"\n"}}
{{- else }}
  {{- if and .Help (not .ShowHelp)}}{{color "cyan"}}[{{ .Config.HelpInput }} for help]{{color "reset"}} {{end}}
  {{- color "white"}}{{if .Default}}(Y/n) {{else}}(y/N) {{end}}{{color "reset"}}
{{- end}}`
```

Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format

```go
var EditorQuestionTemplate = `
{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color "reset"}}{{"\n"}}{{end}}
{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color "reset"}}
{{- color "default+hb"}}{{ .Message }} {{color "reset"}}
{{- if .ShowAnswer}}
  {{- color "cyan"}}{{.Answer}}{{color "reset"}}{{"\n"}}
{{- else }}
  {{- if and .Help (not .ShowHelp)}}{{color "cyan"}}[{{ .Config.HelpInput }} for help]{{color "reset"}} {{end}}
  {{- if and .Default (not .HideDefault)}}{{color "white"}}({{.Default}}) {{color "reset"}}{{end}}
  {{- color "cyan"}}[Enter to launch editor] {{color "reset"}}
{{- end}}`
```

```go
var ErrorTemplate = `{{color .Icon.Format }}{{ .Icon.Text }} Sorry, your reply was invalid: {{ .Error.Error }}{{color "reset"}}
`
```

Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format

```go
var InputQuestionTemplate = `
{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color "reset"}}{{"\n"}}{{end}}
{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color "reset"}}
{{- color "default+hb"}}{{ .Message }} {{color "reset"}}
{{- if .ShowAnswer}}
  {{- color "cyan"}}{{.Answer}}{{color "reset"}}{{"\n"}}
{{- else if .PageEntries -}}
  {{- .Answer}} [Use arrows to move, enter to select, type to continue]
  {{- "\n"}}
  {{- range $ix, $choice := .PageEntries}}
    {{- if eq $ix $.SelectedIndex }}{{color $.Config.Icons.SelectFocus.Format }}{{ $.Config.Icons.SelectFocus.Text }} {{else}}{{color "default"}}  {{end}}
    {{- $choice.Value}}
    {{- color "reset"}}{{"\n"}}
  {{- end}}
{{- else }}
  {{- if or (and .Help (not .ShowHelp)) .Suggest }}{{color "cyan"}}[
    {{- if and .Help (not .ShowHelp)}}{{ print .Config.HelpInput }} for help {{- if and .Suggest}}, {{end}}{{end -}}
    {{- if and .Suggest }}{{color "cyan"}}{{ print .Config.SuggestInput }} for suggestions{{end -}}
  ]{{color "reset"}} {{end}}
  {{- if .Default}}{{color "white"}}({{.Default}}) {{color "reset"}}{{end}}
{{- end}}`
```

```go
var MultiSelectQuestionTemplate = `
{{- define "option"}}
    {{- if eq .SelectedIndex .CurrentIndex }}{{color .Config.Icons.SelectFocus.Format }}{{ .Config.Icons.SelectFocus.Text }}{{color "reset"}}{{else}} {{end}}
    {{- if index .Checked .CurrentOpt.Index }}{{color .Config.Icons.MarkedOption.Format }} {{ .Config.Icons.MarkedOption.Text }} {{else}}{{color .Config.Icons.UnmarkedOption.Format }} {{ .Config.Icons.UnmarkedOption.Text }} {{end}}
    {{- color "reset"}}
    {{- " "}}{{- .CurrentOpt.Value}}
{{end}}
{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color "reset"}}{{"\n"}}{{end}}
{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color "reset"}}
{{- color "default+hb"}}{{ .Message }}{{ .FilterMessage }}{{color "reset"}}
{{- if .ShowAnswer}}{{color "cyan"}} {{.Answer}}{{color "reset"}}{{"\n"}}
{{- else }}
	{{- "  "}}{{- color "cyan"}}[Use arrows to move, space to select,{{- if not .Config.RemoveSelectAll }} <right> to all,{{end}}{{- if not .Config.RemoveSelectNone }} <left> to none,{{end}} type to filter{{- if and .Help (not .ShowHelp)}}, {{ .Config.HelpInput }} for more help{{end}}]{{color "reset"}}
  {{- "\n"}}
  {{- range $ix, $option := .PageEntries}}
    {{- template "option" $.IterateOption $ix $option}}
  {{- end}}
{{- end}}`
```

Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format

```go
var MultilineQuestionTemplate = `
{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color "reset"}}{{"\n"}}{{end}}
{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color "reset"}}
{{- color "default+hb"}}{{ .Message }} {{color "reset"}}
{{- if .ShowAnswer}}
  {{- "\n"}}{{color "cyan"}}{{.Answer}}{{color "reset"}}
  {{- if .Answer }}{{ "\n" }}{{ end }}
{{- else }}
  {{- if .Default}}{{color "white"}}({{.Default}}) {{color "reset"}}{{end}}
  {{- color "cyan"}}[Enter 2 empty lines to finish]{{color "reset"}}
{{- end}}`
```

PasswordQuestionTemplate is a template with color formatting. See Documentation: https://github.com/mgutz/ansi#style-format

```go
var PasswordQuestionTemplate = `
{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color "reset"}}{{"\n"}}{{end}}
{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color "reset"}}
{{- color "default+hb"}}{{ .Message }} {{color "reset"}}
{{- if and .Help (not .ShowHelp)}}{{color "cyan"}}[{{ .Config.HelpInput }} for help]{{color "reset"}} {{end}}`
```

```go
var SelectQuestionTemplate = `
{{- define "option"}}
    {{- if eq .SelectedIndex .CurrentIndex }}{{color .Config.Icons.SelectFocus.Format }}{{ .Config.Icons.SelectFocus.Text }} {{else}}{{color "default"}}  {{end}}
    {{- .CurrentOpt.Value}}{{ if ne ($.GetDescription .CurrentOpt) "" }} - {{color "cyan"}}{{ $.GetDescription .CurrentOpt }}{{end}}
    {{- color "reset"}}
{{end}}
{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color "reset"}}{{"\n"}}{{end}}
{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color "reset"}}
{{- color "default+hb"}}{{ .Message }}{{ .FilterMessage }}{{color "reset"}}
{{- if .ShowAnswer}}{{color "cyan"}} {{.Answer}}{{color "reset"}}{{"\n"}}
{{- else}}
  {{- "  "}}{{- color "cyan"}}[Use arrows to move, type to filter{{- if and .Help (not .ShowHelp)}}, {{ .Config.HelpInput }} for more help{{end}}]{{color "reset"}}
  {{- "\n"}}
  {{- range $ix, $option := .PageEntries}}
    {{- template "option" $.IterateOption $ix $option}}
  {{- end}}
{{- end}}`
```

## func Ask

```go
func Ask(qs []*Question, response interface{}, opts ...AskOpt) error
```

Ask performs the prompt loop, asking for validation when appropriate. The response type can be one of two options. If a struct is passed, the answer will be written to the field whose name matches the Name field on the corresponding question. Field types should be something that can be casted from the response type designated in the documentation. Note, a survey tag can also be used to identify a Otherwise, a map\[string\]interface\{\} can be passed, responses will be written to the key with the matching name. For example:

```
qs := []*survey.Question{
	{
		Name:     "name",
		Prompt:   &survey.Input{Message: "What is your name?"},
		Validate: survey.Required,
		Transform: survey.Title,
	},
}

answers := struct{ Name string }{}

err := survey.Ask(qs, &answers)
```

## func AskOne

```go
func AskOne(p Prompt, response interface{}, opts ...AskOpt) error
```

AskOne performs the prompt for a single prompt and asks for validation if required. Response types should be something that can be casted from the response type designated in the documentation. For example:

```
name := ""
prompt := &survey.Input{
	Message: "name",
}

survey.AskOne(prompt, &name)
```

## func Required

```go
func Required(val interface{}) error
```

Required does not allow an empty value

## func Title

```go
func Title(ans interface{}) interface{}
```

Title is a \`Transformer\`. It receives an answer value and returns a copy of the "ans" with all Unicode letters that begin words mapped to their title case.

Note that if "ans" is not a string then it will return a nil value, meaning that the above answer will not be affected by this call at all.

## func ToLower

```go
func ToLower(ans interface{}) interface{}
```

ToLower is a \`Transformer\`. It receives an answer value and returns a copy of the "ans" with all Unicode letters mapped to their lower case.

Note that if "ans" is not a string then it will return a nil value, meaning that the above answer will not be affected by this call at all.

## type AskOpt

AskOpt allows setting optional ask options.

```go
type AskOpt func(options *AskOptions) error
```

### func WithFilter

```go
func WithFilter(filter func(filter string, value string, index int) (include bool)) AskOpt
```

WithFilter specifies the default filter to use when asking questions.

### func WithHelpInput

```go
func WithHelpInput(r rune) AskOpt
```

WithHelpInput changes the character that prompts look for to give the user helpful information.

### func WithIcons

```go
func WithIcons(setIcons func(*IconSet)) AskOpt
```

WithIcons sets the icons that will be used when prompting the user

### func WithKeepFilter

```go
func WithKeepFilter(KeepFilter bool) AskOpt
```

WithKeepFilter sets the if the filter is kept after selections

### func WithPageSize

```go
func WithPageSize(pageSize int) AskOpt
```

WithPageSize sets the default page size used by prompts

### func WithRemoveSelectAll

```go
func WithRemoveSelectAll() AskOpt
```

WithRemoveSelectAll remove the select all option in Multiselect

### func WithRemoveSelectNone

```go
func WithRemoveSelectNone() AskOpt
```

WithRemoveSelectNone remove the select none/unselect all in Multiselect

### func WithShowCursor

```go
func WithShowCursor(ShowCursor bool) AskOpt
```

WithShowCursor sets the show cursor behavior when prompting the user

### func WithStdio

```go
func WithStdio(in terminal.FileReader, out terminal.FileWriter, err io.Writer) AskOpt
```

WithStdio specifies the standard input, output and error files survey interacts with. By default, these are os.Stdin, os.Stdout, and os.Stderr.

### func WithValidator

```go
func WithValidator(v Validator) AskOpt
```

WithValidator specifies a validator to use while prompting the user

## type AskOptions

AskOptions provides additional options on ask.

```go
type AskOptions struct {
    Stdio        terminal.Stdio
    Validators   []Validator
    PromptConfig PromptConfig
}
```

## type Confirm

Confirm is a regular text input that accept yes/no answers. Response type is a bool.

```go
type Confirm struct {
    Renderer
    Message string
    Default bool
    Help    string
}
```

### func \(\*Confirm\) Cleanup

```go
func (c *Confirm) Cleanup(config *PromptConfig, val interface{}) error
```

Cleanup overwrite the line with the finalized formatted version

### func \(\*Confirm\) Prompt

```go
func (c *Confirm) Prompt(config *PromptConfig) (interface{}, error)
```

Prompt prompts the user with a simple text field and expects a reply followed by a carriage return.

```
likesPie := false
prompt := &survey.Confirm{ Message: "What is your name?" }
survey.AskOne(prompt, &likesPie)
```

## type ConfirmTemplateData

data available to the templates when processing

```go
type ConfirmTemplateData struct {
    Confirm
    Answer   string
    ShowHelp bool
    Config   *PromptConfig
}
```

## type Editor

Editor launches an instance of the users preferred editor on a temporary file. The editor to use is determined by reading the $VISUAL or $EDITOR environment variables. If neither of those are present, notepad \(on Windows\) or vim \(others\) is used. The launch of the editor is triggered by the enter key. Since the response may be long, it will not be echoed as Input does, instead, it print \<Received\>. Response type is a string.

```
message := ""
prompt := &survey.Editor{ Message: "What is your commit message?" }
survey.AskOne(prompt, &message)
```

```go
type Editor struct {
    Renderer
    Message       string
    Default       string
    Help          string
    Editor        string
    HideDefault   bool
    AppendDefault bool
    FileName      string
}
```

### func \(\*Editor\) Cleanup

```go
func (e *Editor) Cleanup(config *PromptConfig, val interface{}) error
```

### func \(\*Editor\) Prompt

```go
func (e *Editor) Prompt(config *PromptConfig) (interface{}, error)
```

### func \(\*Editor\) PromptAgain

```go
func (e *Editor) PromptAgain(config *PromptConfig, invalid interface{}, err error) (interface{}, error)
```

## type EditorTemplateData

data available to the templates when processing

```go
type EditorTemplateData struct {
    Editor
    Answer     string
    ShowAnswer bool
    ShowHelp   bool
    Config     *PromptConfig
}
```

## type ErrorTemplateData

```go
type ErrorTemplateData struct {
    Error error
    Icon  Icon
}
```

## type Icon

Icon holds the text and format to show for a particular icon

```go
type Icon struct {
    Text   string
    Format string
}
```

## type IconSet

IconSet holds the icons to use for various prompts

```go
type IconSet struct {
    HelpInput      Icon
    Error          Icon
    Help           Icon
    Question       Icon
    MarkedOption   Icon
    UnmarkedOption Icon
    SelectFocus    Icon
}
```

## type Input

Input is a regular text input that prints each character the user types on the screen and accepts the input with the enter key. Response type is a string.

```
name := ""
prompt := &survey.Input{ Message: "What is your name?" }
survey.AskOne(prompt, &name)
```

```go
type Input struct {
    Renderer
    Message string
    Default string
    Help    string
    Suggest func(toComplete string) []string
    // contains filtered or unexported fields
}
```

### func \(\*Input\) Cleanup

```go
func (i *Input) Cleanup(config *PromptConfig, val interface{}) error
```

### func \(\*Input\) Prompt

```go
func (i *Input) Prompt(config *PromptConfig) (interface{}, error)
```

## type InputTemplateData

data available to the templates when processing

```go
type InputTemplateData struct {
    Input
    ShowAnswer    bool
    ShowHelp      bool
    Answer        string
    PageEntries   []core.OptionAnswer
    SelectedIndex int
    Config        *PromptConfig
}
```

## type IterableOpts

```go
type IterableOpts interface {
    IterateOption(int, core.OptionAnswer) interface{}
}
```

## type MultiSelect

MultiSelect is a prompt that presents a list of various options to the user for them to select using the arrow keys and enter. Response type is a slice of strings.

```
days := []string{}
prompt := &survey.MultiSelect{
	Message: "What days do you prefer:",
	Options: []string{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"},
}
survey.AskOne(prompt, &days)
```

```go
type MultiSelect struct {
    Renderer
    Message       string
    Options       []string
    Default       interface{}
    Help          string
    PageSize      int
    VimMode       bool
    FilterMessage string
    Filter        func(filter string, value string, index int) bool
    // contains filtered or unexported fields
}
```

### func \(\*MultiSelect\) Cleanup

```go
func (m *MultiSelect) Cleanup(config *PromptConfig, val interface{}) error
```

Cleanup removes the options section, and renders the ask like a normal question.

### func \(\*MultiSelect\) OnChange

```go
func (m *MultiSelect) OnChange(key rune, config *PromptConfig)
```

OnChange is called on every keypress.

### func \(\*MultiSelect\) Prompt

```go
func (m *MultiSelect) Prompt(config *PromptConfig) (interface{}, error)
```

## type MultiSelectTemplateData

data available to the templates when processing

```go
type MultiSelectTemplateData struct {
    MultiSelect
    Answer        string
    ShowAnswer    bool
    Checked       map[int]bool
    SelectedIndex int
    ShowHelp      bool
    PageEntries   []core.OptionAnswer
    Config        *PromptConfig

    // These fields are used when rendering an individual option
    CurrentOpt   core.OptionAnswer
    CurrentIndex int
}
```

### func \(MultiSelectTemplateData\) IterateOption

```go
func (m MultiSelectTemplateData) IterateOption(ix int, opt core.OptionAnswer) interface{}
```

IterateOption sets CurrentOpt and CurrentIndex appropriately so a multiselect option can be rendered individually

## type Multiline

```go
type Multiline struct {
    Renderer
    Message string
    Default string
    Help    string
}
```

### func \(\*Multiline\) Cleanup

```go
func (i *Multiline) Cleanup(config *PromptConfig, val interface{}) error
```

### func \(\*Multiline\) Prompt

```go
func (i *Multiline) Prompt(config *PromptConfig) (interface{}, error)
```

## type MultilineTemplateData

data available to the templates when processing

```go
type MultilineTemplateData struct {
    Multiline
    Answer     string
    ShowAnswer bool
    ShowHelp   bool
    Config     *PromptConfig
}
```

## type OptionAnswer

OptionAnswer is an ergonomic alias for core.OptionAnswer

```go
type OptionAnswer = core.OptionAnswer
```

## type Password

Password is like a normal Input but the text shows up as \*'s and there is no default. Response type is a string.

```
password := ""
prompt := &survey.Password{ Message: "Please type your password" }
survey.AskOne(prompt, &password)
```

```go
type Password struct {
    Renderer
    Message string
    Help    string
}
```

### func \(\*Password\) Cleanup

```go
func (prompt *Password) Cleanup(config *PromptConfig, val interface{}) error
```

Cleanup hides the string with a fixed number of characters.

### func \(\*Password\) Prompt

```go
func (p *Password) Prompt(config *PromptConfig) (interface{}, error)
```

## type PasswordTemplateData

```go
type PasswordTemplateData struct {
    Password
    ShowHelp bool
    Config   *PromptConfig
}
```

## type Prompt

Prompt is the primary interface for the objects that can take user input and return a response.

```go
type Prompt interface {
    Prompt(config *PromptConfig) (interface{}, error)
    Cleanup(*PromptConfig, interface{}) error
    Error(*PromptConfig, error) error
}
```

## type PromptAgainer

PromptAgainer Interface for Prompts that support prompting again after invalid input

```go
type PromptAgainer interface {
    PromptAgain(config *PromptConfig, invalid interface{}, err error) (interface{}, error)
}
```

## type PromptConfig

PromptConfig holds the global configuration for a prompt

```go
type PromptConfig struct {
    PageSize         int
    Icons            IconSet
    HelpInput        string
    SuggestInput     string
    Filter           func(filter string, option string, index int) bool
    KeepFilter       bool
    ShowCursor       bool
    RemoveSelectAll  bool
    RemoveSelectNone bool
}
```

## type Question

Question is the core data structure for a survey questionnaire.

```go
type Question struct {
    Name      string
    Prompt    Prompt
    Validate  Validator
    Transform Transformer
}
```

## type Renderer

```go
type Renderer struct {
    // contains filtered or unexported fields
}
```

### func \(\*Renderer\) AppendRenderedText

```go
func (r *Renderer) AppendRenderedText(text string)
```

AppendRenderedText appends text to the renderer's text buffer which is used to track of what has been printed. The buffer is used to calculate how many lines to erase before updating the prompt.

### func \(\*Renderer\) Error

```go
func (r *Renderer) Error(config *PromptConfig, invalid error) error
```

### func \(\*Renderer\) NewCursor

```go
func (r *Renderer) NewCursor() *terminal.Cursor
```

### func \(\*Renderer\) NewRuneReader

```go
func (r *Renderer) NewRuneReader() *terminal.RuneReader
```

### func \(\*Renderer\) OffsetCursor

```go
func (r *Renderer) OffsetCursor(offset int)
```

### func \(\*Renderer\) Render

```go
func (r *Renderer) Render(tmpl string, data interface{}) error
```

### func \(\*Renderer\) RenderWithCursorOffset

```go
func (r *Renderer) RenderWithCursorOffset(tmpl string, data IterableOpts, opts []core.OptionAnswer, idx int) error
```

### func \(\*Renderer\) Stdio

```go
func (r *Renderer) Stdio() terminal.Stdio
```

### func \(\*Renderer\) WithStdio

```go
func (r *Renderer) WithStdio(stdio terminal.Stdio)
```

## type Select

Select is a prompt that presents a list of various options to the user for them to select using the arrow keys and enter. Response type is a string.

```
color := ""
prompt := &survey.Select{
	Message: "Choose a color:",
	Options: []string{"red", "blue", "green"},
}
survey.AskOne(prompt, &color)
```

```go
type Select struct {
    Renderer
    Message       string
    Options       []string
    Default       interface{}
    Help          string
    PageSize      int
    VimMode       bool
    FilterMessage string
    Filter        func(filter string, value string, index int) bool
    Description   func(value string, index int) string
    // contains filtered or unexported fields
}
```

### func \(\*Select\) Cleanup

```go
func (s *Select) Cleanup(config *PromptConfig, val interface{}) error
```

### func \(\*Select\) OnChange

```go
func (s *Select) OnChange(key rune, config *PromptConfig) bool
```

OnChange is called on every keypress.

### func \(\*Select\) Prompt

```go
func (s *Select) Prompt(config *PromptConfig) (interface{}, error)
```

## type SelectTemplateData

SelectTemplateData is the data available to the templates when processing

```go
type SelectTemplateData struct {
    Select
    PageEntries   []core.OptionAnswer
    SelectedIndex int
    Answer        string
    ShowAnswer    bool
    ShowHelp      bool
    Description   func(value string, index int) string
    Config        *PromptConfig

    // These fields are used when rendering an individual option
    CurrentOpt   core.OptionAnswer
    CurrentIndex int
}
```

### func \(SelectTemplateData\) GetDescription

```go
func (s SelectTemplateData) GetDescription(opt core.OptionAnswer) string
```

### func \(SelectTemplateData\) IterateOption

```go
func (s SelectTemplateData) IterateOption(ix int, opt core.OptionAnswer) interface{}
```

IterateOption sets CurrentOpt and CurrentIndex appropriately so a select option can be rendered individually

## type Transformer

Transformer is a function passed to a Question after a user has provided a response. The function can be used to implement a custom logic that will result to return a different representation of the given answer.

Look \`TransformString\`, \`ToLower\` \`Title\` and \`ComposeTransformers\` for more.

```go
type Transformer func(ans interface{}) (newAns interface{})
```

### func ComposeTransformers

```go
func ComposeTransformers(transformers ...Transformer) Transformer
```

ComposeTransformers is a variadic function used to create one transformer from many.

### func TransformString

```go
func TransformString(f func(s string) string) Transformer
```

TransformString returns a \`Transformer\` based on the "f" function which accepts a string representation of the answer and returns a new one, transformed, answer. Take for example the functions inside the std \`strings\` package, they can be converted to a compatible \`Transformer\` by using this function, i.e: \`TransformString\(strings.Title\)\`, \`TransformString\(strings.ToUpper\)\`.

Note that \`TransformString\` is just a helper, \`Transformer\` can be used to transform any type of answer.

## type Validator

Validator is a function passed to a Question after a user has provided a response. If the function returns an error, then the user will be prompted again for another response.

```go
type Validator func(ans interface{}) error
```

### func ComposeValidators

```go
func ComposeValidators(validators ...Validator) Validator
```

ComposeValidators is a variadic function used to create one validator from many.

### func MaxItems

```go
func MaxItems(numberItems int) Validator
```

MaxItems requires that the list is no longer than the specified value

### func MaxLength

```go
func MaxLength(length int) Validator
```

MaxLength requires that the string is no longer than the specified value

### func MinItems

```go
func MinItems(numberItems int) Validator
```

MinItems requires that the list is longer or equal in length to the specified value

### func MinLength

```go
func MinLength(length int) Validator
```

MinLength requires that the string is longer or equal in length to the specified value



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
