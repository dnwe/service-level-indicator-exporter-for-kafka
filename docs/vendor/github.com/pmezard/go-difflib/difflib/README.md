<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# difflib

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/pmezard/go-difflib/difflib"
```

Package difflib is a partial port of Python difflib module.

It provides tools to compare sequences of strings and generate textual diffs.

The following class and functions have been ported:

\- SequenceMatcher

\- unified\_diff

\- context\_diff

Getting unified diffs was the main goal of the port. Keep in mind this code is mostly suitable to output text differences in a human friendly way, there are no guarantees generated diffs are consumable by patch\(1\).

## Index

- [func GetContextDiffString(diff ContextDiff) (string, error)](<#func-getcontextdiffstring>)
- [func GetUnifiedDiffString(diff UnifiedDiff) (string, error)](<#func-getunifieddiffstring>)
- [func SplitLines(s string) []string](<#func-splitlines>)
- [func WriteContextDiff(writer io.Writer, diff ContextDiff) error](<#func-writecontextdiff>)
- [func WriteUnifiedDiff(writer io.Writer, diff UnifiedDiff) error](<#func-writeunifieddiff>)
- [type ContextDiff](<#type-contextdiff>)
- [type Match](<#type-match>)
- [type OpCode](<#type-opcode>)
- [type SequenceMatcher](<#type-sequencematcher>)
  - [func NewMatcher(a, b []string) *SequenceMatcher](<#func-newmatcher>)
  - [func NewMatcherWithJunk(a, b []string, autoJunk bool, isJunk func(string) bool) *SequenceMatcher](<#func-newmatcherwithjunk>)
  - [func (m *SequenceMatcher) GetGroupedOpCodes(n int) [][]OpCode](<#func-sequencematcher-getgroupedopcodes>)
  - [func (m *SequenceMatcher) GetMatchingBlocks() []Match](<#func-sequencematcher-getmatchingblocks>)
  - [func (m *SequenceMatcher) GetOpCodes() []OpCode](<#func-sequencematcher-getopcodes>)
  - [func (m *SequenceMatcher) QuickRatio() float64](<#func-sequencematcher-quickratio>)
  - [func (m *SequenceMatcher) Ratio() float64](<#func-sequencematcher-ratio>)
  - [func (m *SequenceMatcher) RealQuickRatio() float64](<#func-sequencematcher-realquickratio>)
  - [func (m *SequenceMatcher) SetSeq1(a []string)](<#func-sequencematcher-setseq1>)
  - [func (m *SequenceMatcher) SetSeq2(b []string)](<#func-sequencematcher-setseq2>)
  - [func (m *SequenceMatcher) SetSeqs(a, b []string)](<#func-sequencematcher-setseqs>)
- [type UnifiedDiff](<#type-unifieddiff>)


## func GetContextDiffString

```go
func GetContextDiffString(diff ContextDiff) (string, error)
```

Like WriteContextDiff but returns the diff a string.

## func GetUnifiedDiffString

```go
func GetUnifiedDiffString(diff UnifiedDiff) (string, error)
```

Like WriteUnifiedDiff but returns the diff a string.

## func SplitLines

```go
func SplitLines(s string) []string
```

Split a string on "\\n" while preserving them. The output can be used as input for UnifiedDiff and ContextDiff structures.

## func WriteContextDiff

```go
func WriteContextDiff(writer io.Writer, diff ContextDiff) error
```

Compare two sequences of lines; generate the delta as a context diff.

Context diffs are a compact way of showing line changes and a few lines of context. The number of context lines is set by diff.Context which defaults to three.

By default, the diff control lines \(those with \*\*\* or \-\-\-\) are created with a trailing newline.

For inputs that do not have trailing newlines, set the diff.Eol argument to "" so that the output will be uniformly newline free.

The context diff format normally has a header for filenames and modification times.  Any or all of these may be specified using strings for diff.FromFile, diff.ToFile, diff.FromDate, diff.ToDate. The modification times are normally expressed in the ISO 8601 format. If not specified, the strings default to blanks.

## func WriteUnifiedDiff

```go
func WriteUnifiedDiff(writer io.Writer, diff UnifiedDiff) error
```

Compare two sequences of lines; generate the delta as a unified diff.

Unified diffs are a compact way of showing line changes and a few lines of context.  The number of context lines is set by 'n' which defaults to three.

By default, the diff control lines \(those with \-\-\-, \+\+\+, or @@\) are created with a trailing newline.  This is helpful so that inputs created from file.readlines\(\) result in diffs that are suitable for file.writelines\(\) since both the inputs and outputs have trailing newlines.

For inputs that do not have trailing newlines, set the lineterm argument to "" so that the output will be uniformly newline free.

The unidiff format normally has a header for filenames and modification times.  Any or all of these may be specified using strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'. The modification times are normally expressed in the ISO 8601 format.

## type ContextDiff

```go
type ContextDiff UnifiedDiff
```

## type Match

```go
type Match struct {
    A    int
    B    int
    Size int
}
```

## type OpCode

```go
type OpCode struct {
    Tag byte
    I1  int
    I2  int
    J1  int
    J2  int
}
```

## type SequenceMatcher

SequenceMatcher compares sequence of strings. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980's by Ratcliff and Obershelp under the hyperbolic name "gestalt pattern matching".  The basic idea is to find the longest contiguous matching subsequence that contains no "junk" elements \(R\-O doesn't address junk\).  The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence.  This does not yield minimal edit sequences, but does tend to yield matches that "look right" to people.

SequenceMatcher tries to compute a "human\-friendly diff" between two sequences.  Unlike e.g. UNIX\(tm\) diff, the fundamental notion is the longest \*contiguous\* & junk\-free matching subsequence.  That's what catches peoples' eyes.  The Windows\(tm\) windiff has another interesting notion, pairing up elements that appear uniquely in each sequence. That, and the method here, appear to yield more intuitive difference reports than does diff.  This method appears to be the least vulnerable to synching up on blocks of "junk lines", though \(like blank lines in ordinary text files, or maybe "\<P\>" lines in HTML files\).  That may be because this is the only method of the 3 that has a \*concept\* of "junk" \<wink\>.

Timing:  Basic R\-O is cubic time worst case and quadratic time expected case.  SequenceMatcher is quadratic time for the worst case and has expected\-case behavior dependent in a complicated way on how many elements the sequences have in common; best case time is linear.

```go
type SequenceMatcher struct {
    IsJunk func(string) bool
    // contains filtered or unexported fields
}
```

### func NewMatcher

```go
func NewMatcher(a, b []string) *SequenceMatcher
```

### func NewMatcherWithJunk

```go
func NewMatcherWithJunk(a, b []string, autoJunk bool, isJunk func(string) bool) *SequenceMatcher
```

### func \(\*SequenceMatcher\) GetGroupedOpCodes

```go
func (m *SequenceMatcher) GetGroupedOpCodes(n int) [][]OpCode
```

Isolate change clusters by eliminating ranges with no changes.

Return a generator of groups with up to n lines of context. Each group is in the same format as returned by GetOpCodes\(\).

### func \(\*SequenceMatcher\) GetMatchingBlocks

```go
func (m *SequenceMatcher) GetMatchingBlocks() []Match
```

Return list of triples describing matching subsequences.

Each triple is of the form \(i, j, n\), and means that a\[i:i\+n\] == b\[j:j\+n\].  The triples are monotonically increasing in i and in j. It's also guaranteed that if \(i, j, n\) and \(i', j', n'\) are adjacent triples in the list, and the second is not the last triple in the list, then i\+n \!= i' or j\+n \!= j'. IOW, adjacent triples never describe adjacent equal blocks.

The last triple is a dummy, \(len\(a\), len\(b\), 0\), and is the only triple with n==0.

### func \(\*SequenceMatcher\) GetOpCodes

```go
func (m *SequenceMatcher) GetOpCodes() []OpCode
```

Return list of 5\-tuples describing how to turn a into b.

Each tuple is of the form \(tag, i1, i2, j1, j2\).  The first tuple has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the tuple preceding it, and likewise for j1 == the previous j2.

The tags are characters, with these meanings:

'r' \(replace\):  a\[i1:i2\] should be replaced by b\[j1:j2\]

'd' \(delete\):   a\[i1:i2\] should be deleted, j1==j2 in this case.

'i' \(insert\):   b\[j1:j2\] should be inserted at a\[i1:i1\], i1==i2 in this case.

'e' \(equal\):    a\[i1:i2\] == b\[j1:j2\]

### func \(\*SequenceMatcher\) QuickRatio

```go
func (m *SequenceMatcher) QuickRatio() float64
```

Return an upper bound on ratio\(\) relatively quickly.

This isn't defined beyond that it is an upper bound on .Ratio\(\), and is faster to compute.

### func \(\*SequenceMatcher\) Ratio

```go
func (m *SequenceMatcher) Ratio() float64
```

Return a measure of the sequences' similarity \(float in \[0,1\]\).

Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0\*M / T. Note that this is 1 if the sequences are identical, and 0 if they have nothing in common.

.Ratio\(\) is expensive to compute if you haven't already computed .GetMatchingBlocks\(\) or .GetOpCodes\(\), in which case you may want to try .QuickRatio\(\) or .RealQuickRation\(\) first to get an upper bound.

### func \(\*SequenceMatcher\) RealQuickRatio

```go
func (m *SequenceMatcher) RealQuickRatio() float64
```

Return an upper bound on ratio\(\) very quickly.

This isn't defined beyond that it is an upper bound on .Ratio\(\), and is faster to compute than either .Ratio\(\) or .QuickRatio\(\).

### func \(\*SequenceMatcher\) SetSeq1

```go
func (m *SequenceMatcher) SetSeq1(a []string)
```

Set the first sequence to be compared. The second sequence to be compared is not changed.

SequenceMatcher computes and caches detailed information about the second sequence, so if you want to compare one sequence S against many sequences, use .SetSeq2\(s\) once and call .SetSeq1\(x\) repeatedly for each of the other sequences.

See also SetSeqs\(\) and SetSeq2\(\).

### func \(\*SequenceMatcher\) SetSeq2

```go
func (m *SequenceMatcher) SetSeq2(b []string)
```

Set the second sequence to be compared. The first sequence to be compared is not changed.

### func \(\*SequenceMatcher\) SetSeqs

```go
func (m *SequenceMatcher) SetSeqs(a, b []string)
```

Set two sequences to be compared.

## type UnifiedDiff

Unified diff parameters

```go
type UnifiedDiff struct {
    A        []string // First sequence lines
    FromFile string   // First file name
    FromDate string   // First file time
    B        []string // Second sequence lines
    ToFile   string   // Second file name
    ToDate   string   // Second file time
    Eol      string   // Headers end of line, defaults to LF
    Context  int      // Number of context lines
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
