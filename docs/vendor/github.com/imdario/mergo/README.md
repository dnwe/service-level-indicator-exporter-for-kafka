<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# mergo

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/imdario/mergo"
```

A helper to merge structs and maps in Golang. Useful for configuration default values, avoiding messy if\-statements.

Mergo merges same\-type structs and maps by setting default values in zero\-value fields. Mergo won't merge unexported \(private\) fields. It will do recursively any exported one. It also won't merge structs inside maps \(because they are not addressable using Go reflection\).

### Status

It is ready for production use. It is used in several projects by Docker, Google, The Linux Foundation, VMWare, Shopify, etc.

### Important note

Please keep in mind that a problematic PR broke 0.3.9. We reverted it in 0.3.10. We consider 0.3.10 as stable but not bug\-free. . Also, this version adds suppot for go modules.

Keep in mind that in 0.3.2, Mergo changed Merge\(\) and Map\(\) signatures to support transformers. We added an optional/variadic argument so that it won't break the existing code.

If you were using Mergo before April 6th, 2015, please check your project works as intended after updating your local copy with go get \-u github.com/imdario/mergo. I apologize for any issue caused by its previous behavior and any future bug that Mergo could cause in existing projects after the change \(release 0.2.0\).

### Install

Do your usual installation procedure:

```
go get github.com/imdario/mergo

// use in your .go code
import (
    "github.com/imdario/mergo"
)
```

### Usage

You can only merge same\-type structs with exported fields initialized as zero value of their type and same\-types maps. Mergo won't merge unexported \(private\) fields but will do recursively any exported one. It won't merge empty structs value as they are zero values too. Also, maps will be merged recursively except for structs inside maps \(because they are not addressable using Go reflection\).

```
if err := mergo.Merge(&dst, src); err != nil {
	// ...
}
```

Also, you can merge overwriting values using the transformer WithOverride.

```
if err := mergo.Merge(&dst, src, mergo.WithOverride); err != nil {
	// ...
}
```

Additionally, you can map a map\[string\]interface\{\} to a struct \(and otherwise, from struct to map\), following the same restrictions as in Merge\(\). Keys are capitalized to find each corresponding exported field.

```
if err := mergo.Map(&dst, srcMap); err != nil {
	// ...
}
```

Warning: if you map a struct to map, it won't do it recursively. Don't expect Mergo to map struct members of your struct as map\[string\]interface\{\}. They will be just assigned as values.

Here is a nice example:

```
package main

import (
	"fmt"
	"github.com/imdario/mergo"
)

type Foo struct {
	A string
	B int64
}

func main() {
	src := Foo{
		A: "one",
		B: 2,
	}
	dest := Foo{
		A: "two",
	}
	mergo.Merge(&dest, src)
	fmt.Println(dest)
	// Will print
	// {two 2}
}
```

### Transformers

Transformers allow to merge specific types differently than in the default behavior. In other words, now you can customize how some types are merged. For example, time.Time is a struct; it doesn't have zero value but IsZero can return true because it has fields with zero value. How can we merge a non\-zero time.Time?

```
package main

import (
	"fmt"
	"github.com/imdario/mergo"
		"reflect"
		"time"
)

type timeTransformer struct {
}

func (t timeTransformer) Transformer(typ reflect.Type) func(dst, src reflect.Value) error {
	if typ == reflect.TypeOf(time.Time{}) {
		return func(dst, src reflect.Value) error {
			if dst.CanSet() {
				isZero := dst.MethodByName("IsZero")
				result := isZero.Call([]reflect.Value{})
				if result[0].Bool() {
					dst.Set(src)
				}
			}
			return nil
		}
	}
	return nil
}

type Snapshot struct {
	Time time.Time
	// ...
}

func main() {
	src := Snapshot{time.Now()}
	dest := Snapshot{}
	mergo.Merge(&dest, src, mergo.WithTransformers(timeTransformer{}))
	fmt.Println(dest)
	// Will print
	// { 2018-01-12 01:15:00 +0000 UTC m=+0.000000001 }
}
```

### Contact me

If I can help you, you have an idea or you are using Mergo in your projects, don't hesitate to drop me a line \(or a pull request\): https://twitter.com/im_dario

### About

Written by Dario Castañé: https://da.rio.hn

### License

BSD 3\-Clause license, as Go language.

## Index

- [Variables](<#variables>)
- [func Map(dst, src interface{}, opts ...func(*Config)) error](<#func-map>)
- [func MapWithOverwrite(dst, src interface{}, opts ...func(*Config)) error](<#func-mapwithoverwrite>)
- [func Merge(dst, src interface{}, opts ...func(*Config)) error](<#func-merge>)
- [func MergeWithOverwrite(dst, src interface{}, opts ...func(*Config)) error](<#func-mergewithoverwrite>)
- [func WithAppendSlice(config *Config)](<#func-withappendslice>)
- [func WithOverride(config *Config)](<#func-withoverride>)
- [func WithOverrideEmptySlice(config *Config)](<#func-withoverrideemptyslice>)
- [func WithOverwriteWithEmptyValue(config *Config)](<#func-withoverwritewithemptyvalue>)
- [func WithSliceDeepCopy(config *Config)](<#func-withslicedeepcopy>)
- [func WithTransformers(transformers Transformers) func(*Config)](<#func-withtransformers>)
- [func WithTypeCheck(config *Config)](<#func-withtypecheck>)
- [type Config](<#type-config>)
- [type Transformers](<#type-transformers>)


## Variables

Errors reported by Mergo when it finds invalid arguments.

```go
var (
    ErrNilArguments                = errors.New("src and dst must not be nil")
    ErrDifferentArgumentsTypes     = errors.New("src and dst must be of same type")
    ErrNotSupported                = errors.New("only structs, maps, and slices are supported")
    ErrExpectedMapAsDestination    = errors.New("dst was expected to be a map")
    ErrExpectedStructAsDestination = errors.New("dst was expected to be a struct")
    ErrNonPointerAgument           = errors.New("dst must be a pointer")
)
```

## func Map

```go
func Map(dst, src interface{}, opts ...func(*Config)) error
```

Map sets fields' values in dst from src. src can be a map with string keys or a struct. dst must be the opposite: if src is a map, dst must be a valid pointer to struct. If src is a struct, dst must be map\[string\]interface\{\}. It won't merge unexported \(private\) fields and will do recursively any exported field. If dst is a map, keys will be src fields' names in lower camel case. Missing key in src that doesn't match a field in dst will be skipped. This doesn't apply if dst is a map. This is separated method from Merge because it is cleaner and it keeps sane semantics: merging equal types, mapping different \(restricted\) types.

## func MapWithOverwrite

```go
func MapWithOverwrite(dst, src interface{}, opts ...func(*Config)) error
```

MapWithOverwrite will do the same as Map except that non\-empty dst attributes will be overridden by non\-empty src attribute values. Deprecated: Use Map\(…\) with WithOverride

## func Merge

```go
func Merge(dst, src interface{}, opts ...func(*Config)) error
```

Merge will fill any empty for value type attributes on the dst struct using corresponding src attributes if they themselves are not empty. dst and src must be valid same\-type structs and dst must be a pointer to struct. It won't merge unexported \(private\) fields and will do recursively any exported field.

## func MergeWithOverwrite

```go
func MergeWithOverwrite(dst, src interface{}, opts ...func(*Config)) error
```

MergeWithOverwrite will do the same as Merge except that non\-empty dst attributes will be overridden by non\-empty src attribute values. Deprecated: use Merge\(…\) with WithOverride

## func WithAppendSlice

```go
func WithAppendSlice(config *Config)
```

WithAppendSlice will make merge append slices instead of overwriting it.

## func WithOverride

```go
func WithOverride(config *Config)
```

WithOverride will make merge override non\-empty dst attributes with non\-empty src attributes values.

## func WithOverrideEmptySlice

```go
func WithOverrideEmptySlice(config *Config)
```

WithOverrideEmptySlice will make merge override empty dst slice with empty src slice.

## func WithOverwriteWithEmptyValue

```go
func WithOverwriteWithEmptyValue(config *Config)
```

WithOverwriteWithEmptyValue will make merge override non empty dst attributes with empty src attributes values.

## func WithSliceDeepCopy

```go
func WithSliceDeepCopy(config *Config)
```

WithSliceDeepCopy will merge slice element one by one with Overwrite flag.

## func WithTransformers

```go
func WithTransformers(transformers Transformers) func(*Config)
```

WithTransformers adds transformers to merge, allowing to customize the merging of some types.

## func WithTypeCheck

```go
func WithTypeCheck(config *Config)
```

WithTypeCheck will make merge check types while overwriting it \(must be used with WithOverride\).

## type Config

```go
type Config struct {
    Overwrite    bool
    AppendSlice  bool
    TypeCheck    bool
    Transformers Transformers
    // contains filtered or unexported fields
}
```

## type Transformers

```go
type Transformers interface {
    Transformer(reflect.Type) func(dst, src reflect.Value) error
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
