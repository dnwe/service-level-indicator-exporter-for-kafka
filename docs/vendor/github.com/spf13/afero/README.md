<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# afero

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/spf13/afero"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func DirExists(fs Fs, path string) (bool, error)](<#func-direxists>)
- [func Exists(fs Fs, path string) (bool, error)](<#func-exists>)
- [func FileContainsAnyBytes(fs Fs, filename string, subslices [][]byte) (bool, error)](<#func-filecontainsanybytes>)
- [func FileContainsBytes(fs Fs, filename string, subslice []byte) (bool, error)](<#func-filecontainsbytes>)
- [func FullBaseFsPath(basePathFs *BasePathFs, relativePath string) string](<#func-fullbasefspath>)
- [func GetTempDir(fs Fs, subPath string) string](<#func-gettempdir>)
- [func Glob(fs Fs, pattern string) (matches []string, err error)](<#func-glob>)
- [func IsDir(fs Fs, path string) (bool, error)](<#func-isdir>)
- [func IsEmpty(fs Fs, path string) (bool, error)](<#func-isempty>)
- [func NeuterAccents(s string) string](<#func-neuteraccents>)
- [func ReadAll(r io.Reader) ([]byte, error)](<#func-readall>)
- [func ReadDir(fs Fs, dirname string) ([]os.FileInfo, error)](<#func-readdir>)
- [func ReadFile(fs Fs, filename string) ([]byte, error)](<#func-readfile>)
- [func SafeWriteReader(fs Fs, path string, r io.Reader) (err error)](<#func-safewritereader>)
- [func TempDir(fs Fs, dir, prefix string) (name string, err error)](<#func-tempdir>)
- [func UnicodeSanitize(s string) string](<#func-unicodesanitize>)
- [func Walk(fs Fs, root string, walkFn filepath.WalkFunc) error](<#func-walk>)
- [func WriteFile(fs Fs, filename string, data []byte, perm os.FileMode) error](<#func-writefile>)
- [func WriteReader(fs Fs, path string, r io.Reader) (err error)](<#func-writereader>)
- [type Afero](<#type-afero>)
  - [func (a Afero) DirExists(path string) (bool, error)](<#func-afero-direxists>)
  - [func (a Afero) Exists(path string) (bool, error)](<#func-afero-exists>)
  - [func (a Afero) FileContainsAnyBytes(filename string, subslices [][]byte) (bool, error)](<#func-afero-filecontainsanybytes>)
  - [func (a Afero) FileContainsBytes(filename string, subslice []byte) (bool, error)](<#func-afero-filecontainsbytes>)
  - [func (a Afero) GetTempDir(subPath string) string](<#func-afero-gettempdir>)
  - [func (a Afero) IsDir(path string) (bool, error)](<#func-afero-isdir>)
  - [func (a Afero) IsEmpty(path string) (bool, error)](<#func-afero-isempty>)
  - [func (a Afero) ReadDir(dirname string) ([]os.FileInfo, error)](<#func-afero-readdir>)
  - [func (a Afero) ReadFile(filename string) ([]byte, error)](<#func-afero-readfile>)
  - [func (a Afero) SafeWriteReader(path string, r io.Reader) (err error)](<#func-afero-safewritereader>)
  - [func (a Afero) TempDir(dir, prefix string) (name string, err error)](<#func-afero-tempdir>)
  - [func (a Afero) TempFile(dir, pattern string) (f File, err error)](<#func-afero-tempfile>)
  - [func (a Afero) Walk(root string, walkFn filepath.WalkFunc) error](<#func-afero-walk>)
  - [func (a Afero) WriteFile(filename string, data []byte, perm os.FileMode) error](<#func-afero-writefile>)
  - [func (a Afero) WriteReader(path string, r io.Reader) (err error)](<#func-afero-writereader>)
- [type BasePathFile](<#type-basepathfile>)
  - [func (f *BasePathFile) Name() string](<#func-basepathfile-name>)
  - [func (f *BasePathFile) ReadDir(n int) ([]fs.DirEntry, error)](<#func-basepathfile-readdir>)
- [type BasePathFs](<#type-basepathfs>)
  - [func (b *BasePathFs) Chmod(name string, mode os.FileMode) (err error)](<#func-basepathfs-chmod>)
  - [func (b *BasePathFs) Chown(name string, uid, gid int) (err error)](<#func-basepathfs-chown>)
  - [func (b *BasePathFs) Chtimes(name string, atime, mtime time.Time) (err error)](<#func-basepathfs-chtimes>)
  - [func (b *BasePathFs) Create(name string) (f File, err error)](<#func-basepathfs-create>)
  - [func (b *BasePathFs) LstatIfPossible(name string) (os.FileInfo, bool, error)](<#func-basepathfs-lstatifpossible>)
  - [func (b *BasePathFs) Mkdir(name string, mode os.FileMode) (err error)](<#func-basepathfs-mkdir>)
  - [func (b *BasePathFs) MkdirAll(name string, mode os.FileMode) (err error)](<#func-basepathfs-mkdirall>)
  - [func (b *BasePathFs) Name() string](<#func-basepathfs-name>)
  - [func (b *BasePathFs) Open(name string) (f File, err error)](<#func-basepathfs-open>)
  - [func (b *BasePathFs) OpenFile(name string, flag int, mode os.FileMode) (f File, err error)](<#func-basepathfs-openfile>)
  - [func (b *BasePathFs) ReadlinkIfPossible(name string) (string, error)](<#func-basepathfs-readlinkifpossible>)
  - [func (b *BasePathFs) RealPath(name string) (path string, err error)](<#func-basepathfs-realpath>)
  - [func (b *BasePathFs) Remove(name string) (err error)](<#func-basepathfs-remove>)
  - [func (b *BasePathFs) RemoveAll(name string) (err error)](<#func-basepathfs-removeall>)
  - [func (b *BasePathFs) Rename(oldname, newname string) (err error)](<#func-basepathfs-rename>)
  - [func (b *BasePathFs) Stat(name string) (fi os.FileInfo, err error)](<#func-basepathfs-stat>)
  - [func (b *BasePathFs) SymlinkIfPossible(oldname, newname string) error](<#func-basepathfs-symlinkifpossible>)
- [type CacheOnReadFs](<#type-cacheonreadfs>)
  - [func (u *CacheOnReadFs) Chmod(name string, mode os.FileMode) error](<#func-cacheonreadfs-chmod>)
  - [func (u *CacheOnReadFs) Chown(name string, uid, gid int) error](<#func-cacheonreadfs-chown>)
  - [func (u *CacheOnReadFs) Chtimes(name string, atime, mtime time.Time) error](<#func-cacheonreadfs-chtimes>)
  - [func (u *CacheOnReadFs) Create(name string) (File, error)](<#func-cacheonreadfs-create>)
  - [func (u *CacheOnReadFs) Mkdir(name string, perm os.FileMode) error](<#func-cacheonreadfs-mkdir>)
  - [func (u *CacheOnReadFs) MkdirAll(name string, perm os.FileMode) error](<#func-cacheonreadfs-mkdirall>)
  - [func (u *CacheOnReadFs) Name() string](<#func-cacheonreadfs-name>)
  - [func (u *CacheOnReadFs) Open(name string) (File, error)](<#func-cacheonreadfs-open>)
  - [func (u *CacheOnReadFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-cacheonreadfs-openfile>)
  - [func (u *CacheOnReadFs) Remove(name string) error](<#func-cacheonreadfs-remove>)
  - [func (u *CacheOnReadFs) RemoveAll(name string) error](<#func-cacheonreadfs-removeall>)
  - [func (u *CacheOnReadFs) Rename(oldname, newname string) error](<#func-cacheonreadfs-rename>)
  - [func (u *CacheOnReadFs) Stat(name string) (os.FileInfo, error)](<#func-cacheonreadfs-stat>)
- [type CopyOnWriteFs](<#type-copyonwritefs>)
  - [func (u *CopyOnWriteFs) Chmod(name string, mode os.FileMode) error](<#func-copyonwritefs-chmod>)
  - [func (u *CopyOnWriteFs) Chown(name string, uid, gid int) error](<#func-copyonwritefs-chown>)
  - [func (u *CopyOnWriteFs) Chtimes(name string, atime, mtime time.Time) error](<#func-copyonwritefs-chtimes>)
  - [func (u *CopyOnWriteFs) Create(name string) (File, error)](<#func-copyonwritefs-create>)
  - [func (u *CopyOnWriteFs) LstatIfPossible(name string) (os.FileInfo, bool, error)](<#func-copyonwritefs-lstatifpossible>)
  - [func (u *CopyOnWriteFs) Mkdir(name string, perm os.FileMode) error](<#func-copyonwritefs-mkdir>)
  - [func (u *CopyOnWriteFs) MkdirAll(name string, perm os.FileMode) error](<#func-copyonwritefs-mkdirall>)
  - [func (u *CopyOnWriteFs) Name() string](<#func-copyonwritefs-name>)
  - [func (u *CopyOnWriteFs) Open(name string) (File, error)](<#func-copyonwritefs-open>)
  - [func (u *CopyOnWriteFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-copyonwritefs-openfile>)
  - [func (u *CopyOnWriteFs) ReadlinkIfPossible(name string) (string, error)](<#func-copyonwritefs-readlinkifpossible>)
  - [func (u *CopyOnWriteFs) Remove(name string) error](<#func-copyonwritefs-remove>)
  - [func (u *CopyOnWriteFs) RemoveAll(name string) error](<#func-copyonwritefs-removeall>)
  - [func (u *CopyOnWriteFs) Rename(oldname, newname string) error](<#func-copyonwritefs-rename>)
  - [func (u *CopyOnWriteFs) Stat(name string) (os.FileInfo, error)](<#func-copyonwritefs-stat>)
  - [func (u *CopyOnWriteFs) SymlinkIfPossible(oldname, newname string) error](<#func-copyonwritefs-symlinkifpossible>)
- [type DirsMerger](<#type-dirsmerger>)
- [type File](<#type-file>)
  - [func TempFile(fs Fs, dir, pattern string) (f File, err error)](<#func-tempfile>)
- [type FromIOFS](<#type-fromiofs>)
  - [func (f FromIOFS) Chmod(name string, mode os.FileMode) error](<#func-fromiofs-chmod>)
  - [func (f FromIOFS) Chown(name string, uid, gid int) error](<#func-fromiofs-chown>)
  - [func (f FromIOFS) Chtimes(name string, atime time.Time, mtime time.Time) error](<#func-fromiofs-chtimes>)
  - [func (f FromIOFS) Create(name string) (File, error)](<#func-fromiofs-create>)
  - [func (f FromIOFS) Mkdir(name string, perm os.FileMode) error](<#func-fromiofs-mkdir>)
  - [func (f FromIOFS) MkdirAll(path string, perm os.FileMode) error](<#func-fromiofs-mkdirall>)
  - [func (f FromIOFS) Name() string](<#func-fromiofs-name>)
  - [func (f FromIOFS) Open(name string) (File, error)](<#func-fromiofs-open>)
  - [func (f FromIOFS) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-fromiofs-openfile>)
  - [func (f FromIOFS) Remove(name string) error](<#func-fromiofs-remove>)
  - [func (f FromIOFS) RemoveAll(path string) error](<#func-fromiofs-removeall>)
  - [func (f FromIOFS) Rename(oldname, newname string) error](<#func-fromiofs-rename>)
  - [func (f FromIOFS) Stat(name string) (os.FileInfo, error)](<#func-fromiofs-stat>)
- [type Fs](<#type-fs>)
  - [func NewBasePathFs(source Fs, path string) Fs](<#func-newbasepathfs>)
  - [func NewCacheOnReadFs(base Fs, layer Fs, cacheTime time.Duration) Fs](<#func-newcacheonreadfs>)
  - [func NewCopyOnWriteFs(base Fs, layer Fs) Fs](<#func-newcopyonwritefs>)
  - [func NewMemMapFs() Fs](<#func-newmemmapfs>)
  - [func NewOsFs() Fs](<#func-newosfs>)
  - [func NewReadOnlyFs(source Fs) Fs](<#func-newreadonlyfs>)
  - [func NewRegexpFs(source Fs, re *regexp.Regexp) Fs](<#func-newregexpfs>)
- [type HttpFs](<#type-httpfs>)
  - [func NewHttpFs(source Fs) *HttpFs](<#func-newhttpfs>)
  - [func (h HttpFs) Chmod(name string, mode os.FileMode) error](<#func-httpfs-chmod>)
  - [func (h HttpFs) Chown(name string, uid, gid int) error](<#func-httpfs-chown>)
  - [func (h HttpFs) Chtimes(name string, atime time.Time, mtime time.Time) error](<#func-httpfs-chtimes>)
  - [func (h HttpFs) Create(name string) (File, error)](<#func-httpfs-create>)
  - [func (h HttpFs) Dir(s string) *httpDir](<#func-httpfs-dir>)
  - [func (h HttpFs) Mkdir(name string, perm os.FileMode) error](<#func-httpfs-mkdir>)
  - [func (h HttpFs) MkdirAll(path string, perm os.FileMode) error](<#func-httpfs-mkdirall>)
  - [func (h HttpFs) Name() string](<#func-httpfs-name>)
  - [func (h HttpFs) Open(name string) (http.File, error)](<#func-httpfs-open>)
  - [func (h HttpFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-httpfs-openfile>)
  - [func (h HttpFs) Remove(name string) error](<#func-httpfs-remove>)
  - [func (h HttpFs) RemoveAll(path string) error](<#func-httpfs-removeall>)
  - [func (h HttpFs) Rename(oldname, newname string) error](<#func-httpfs-rename>)
  - [func (h HttpFs) Stat(name string) (os.FileInfo, error)](<#func-httpfs-stat>)
- [type IOFS](<#type-iofs>)
  - [func NewIOFS(fs Fs) IOFS](<#func-newiofs>)
  - [func (iofs IOFS) Glob(pattern string) ([]string, error)](<#func-iofs-glob>)
  - [func (iofs IOFS) Open(name string) (fs.File, error)](<#func-iofs-open>)
  - [func (iofs IOFS) ReadDir(name string) ([]fs.DirEntry, error)](<#func-iofs-readdir>)
  - [func (iofs IOFS) ReadFile(name string) ([]byte, error)](<#func-iofs-readfile>)
  - [func (iofs IOFS) Sub(dir string) (fs.FS, error)](<#func-iofs-sub>)
- [type LinkReader](<#type-linkreader>)
- [type Linker](<#type-linker>)
- [type Lstater](<#type-lstater>)
- [type MemMapFs](<#type-memmapfs>)
  - [func (m *MemMapFs) Chmod(name string, mode os.FileMode) error](<#func-memmapfs-chmod>)
  - [func (m *MemMapFs) Chown(name string, uid, gid int) error](<#func-memmapfs-chown>)
  - [func (m *MemMapFs) Chtimes(name string, atime time.Time, mtime time.Time) error](<#func-memmapfs-chtimes>)
  - [func (m *MemMapFs) Create(name string) (File, error)](<#func-memmapfs-create>)
  - [func (m *MemMapFs) List()](<#func-memmapfs-list>)
  - [func (m *MemMapFs) LstatIfPossible(name string) (os.FileInfo, bool, error)](<#func-memmapfs-lstatifpossible>)
  - [func (m *MemMapFs) Mkdir(name string, perm os.FileMode) error](<#func-memmapfs-mkdir>)
  - [func (m *MemMapFs) MkdirAll(path string, perm os.FileMode) error](<#func-memmapfs-mkdirall>)
  - [func (*MemMapFs) Name() string](<#func-memmapfs-name>)
  - [func (m *MemMapFs) Open(name string) (File, error)](<#func-memmapfs-open>)
  - [func (m *MemMapFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-memmapfs-openfile>)
  - [func (m *MemMapFs) Remove(name string) error](<#func-memmapfs-remove>)
  - [func (m *MemMapFs) RemoveAll(path string) error](<#func-memmapfs-removeall>)
  - [func (m *MemMapFs) Rename(oldname, newname string) error](<#func-memmapfs-rename>)
  - [func (m *MemMapFs) Stat(name string) (os.FileInfo, error)](<#func-memmapfs-stat>)
- [type OsFs](<#type-osfs>)
  - [func (OsFs) Chmod(name string, mode os.FileMode) error](<#func-osfs-chmod>)
  - [func (OsFs) Chown(name string, uid, gid int) error](<#func-osfs-chown>)
  - [func (OsFs) Chtimes(name string, atime time.Time, mtime time.Time) error](<#func-osfs-chtimes>)
  - [func (OsFs) Create(name string) (File, error)](<#func-osfs-create>)
  - [func (OsFs) LstatIfPossible(name string) (os.FileInfo, bool, error)](<#func-osfs-lstatifpossible>)
  - [func (OsFs) Mkdir(name string, perm os.FileMode) error](<#func-osfs-mkdir>)
  - [func (OsFs) MkdirAll(path string, perm os.FileMode) error](<#func-osfs-mkdirall>)
  - [func (OsFs) Name() string](<#func-osfs-name>)
  - [func (OsFs) Open(name string) (File, error)](<#func-osfs-open>)
  - [func (OsFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-osfs-openfile>)
  - [func (OsFs) ReadlinkIfPossible(name string) (string, error)](<#func-osfs-readlinkifpossible>)
  - [func (OsFs) Remove(name string) error](<#func-osfs-remove>)
  - [func (OsFs) RemoveAll(path string) error](<#func-osfs-removeall>)
  - [func (OsFs) Rename(oldname, newname string) error](<#func-osfs-rename>)
  - [func (OsFs) Stat(name string) (os.FileInfo, error)](<#func-osfs-stat>)
  - [func (OsFs) SymlinkIfPossible(oldname, newname string) error](<#func-osfs-symlinkifpossible>)
- [type ReadOnlyFs](<#type-readonlyfs>)
  - [func (r *ReadOnlyFs) Chmod(n string, m os.FileMode) error](<#func-readonlyfs-chmod>)
  - [func (r *ReadOnlyFs) Chown(n string, uid, gid int) error](<#func-readonlyfs-chown>)
  - [func (r *ReadOnlyFs) Chtimes(n string, a, m time.Time) error](<#func-readonlyfs-chtimes>)
  - [func (r *ReadOnlyFs) Create(n string) (File, error)](<#func-readonlyfs-create>)
  - [func (r *ReadOnlyFs) LstatIfPossible(name string) (os.FileInfo, bool, error)](<#func-readonlyfs-lstatifpossible>)
  - [func (r *ReadOnlyFs) Mkdir(n string, p os.FileMode) error](<#func-readonlyfs-mkdir>)
  - [func (r *ReadOnlyFs) MkdirAll(n string, p os.FileMode) error](<#func-readonlyfs-mkdirall>)
  - [func (r *ReadOnlyFs) Name() string](<#func-readonlyfs-name>)
  - [func (r *ReadOnlyFs) Open(n string) (File, error)](<#func-readonlyfs-open>)
  - [func (r *ReadOnlyFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-readonlyfs-openfile>)
  - [func (r *ReadOnlyFs) ReadDir(name string) ([]os.FileInfo, error)](<#func-readonlyfs-readdir>)
  - [func (r *ReadOnlyFs) ReadlinkIfPossible(name string) (string, error)](<#func-readonlyfs-readlinkifpossible>)
  - [func (r *ReadOnlyFs) Remove(n string) error](<#func-readonlyfs-remove>)
  - [func (r *ReadOnlyFs) RemoveAll(p string) error](<#func-readonlyfs-removeall>)
  - [func (r *ReadOnlyFs) Rename(o, n string) error](<#func-readonlyfs-rename>)
  - [func (r *ReadOnlyFs) Stat(name string) (os.FileInfo, error)](<#func-readonlyfs-stat>)
  - [func (r *ReadOnlyFs) SymlinkIfPossible(oldname, newname string) error](<#func-readonlyfs-symlinkifpossible>)
- [type RegexpFile](<#type-regexpfile>)
  - [func (f *RegexpFile) Close() error](<#func-regexpfile-close>)
  - [func (f *RegexpFile) Name() string](<#func-regexpfile-name>)
  - [func (f *RegexpFile) Read(s []byte) (int, error)](<#func-regexpfile-read>)
  - [func (f *RegexpFile) ReadAt(s []byte, o int64) (int, error)](<#func-regexpfile-readat>)
  - [func (f *RegexpFile) Readdir(c int) (fi []os.FileInfo, err error)](<#func-regexpfile-readdir>)
  - [func (f *RegexpFile) Readdirnames(c int) (n []string, err error)](<#func-regexpfile-readdirnames>)
  - [func (f *RegexpFile) Seek(o int64, w int) (int64, error)](<#func-regexpfile-seek>)
  - [func (f *RegexpFile) Stat() (os.FileInfo, error)](<#func-regexpfile-stat>)
  - [func (f *RegexpFile) Sync() error](<#func-regexpfile-sync>)
  - [func (f *RegexpFile) Truncate(s int64) error](<#func-regexpfile-truncate>)
  - [func (f *RegexpFile) Write(s []byte) (int, error)](<#func-regexpfile-write>)
  - [func (f *RegexpFile) WriteAt(s []byte, o int64) (int, error)](<#func-regexpfile-writeat>)
  - [func (f *RegexpFile) WriteString(s string) (int, error)](<#func-regexpfile-writestring>)
- [type RegexpFs](<#type-regexpfs>)
  - [func (r *RegexpFs) Chmod(name string, mode os.FileMode) error](<#func-regexpfs-chmod>)
  - [func (r *RegexpFs) Chown(name string, uid, gid int) error](<#func-regexpfs-chown>)
  - [func (r *RegexpFs) Chtimes(name string, a, m time.Time) error](<#func-regexpfs-chtimes>)
  - [func (r *RegexpFs) Create(name string) (File, error)](<#func-regexpfs-create>)
  - [func (r *RegexpFs) Mkdir(n string, p os.FileMode) error](<#func-regexpfs-mkdir>)
  - [func (r *RegexpFs) MkdirAll(n string, p os.FileMode) error](<#func-regexpfs-mkdirall>)
  - [func (r *RegexpFs) Name() string](<#func-regexpfs-name>)
  - [func (r *RegexpFs) Open(name string) (File, error)](<#func-regexpfs-open>)
  - [func (r *RegexpFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)](<#func-regexpfs-openfile>)
  - [func (r *RegexpFs) Remove(name string) error](<#func-regexpfs-remove>)
  - [func (r *RegexpFs) RemoveAll(p string) error](<#func-regexpfs-removeall>)
  - [func (r *RegexpFs) Rename(oldname, newname string) error](<#func-regexpfs-rename>)
  - [func (r *RegexpFs) Stat(name string) (os.FileInfo, error)](<#func-regexpfs-stat>)
- [type Symlinker](<#type-symlinker>)
- [type UnionFile](<#type-unionfile>)
  - [func (f *UnionFile) Close() error](<#func-unionfile-close>)
  - [func (f *UnionFile) Name() string](<#func-unionfile-name>)
  - [func (f *UnionFile) Read(s []byte) (int, error)](<#func-unionfile-read>)
  - [func (f *UnionFile) ReadAt(s []byte, o int64) (int, error)](<#func-unionfile-readat>)
  - [func (f *UnionFile) Readdir(c int) (ofi []os.FileInfo, err error)](<#func-unionfile-readdir>)
  - [func (f *UnionFile) Readdirnames(c int) ([]string, error)](<#func-unionfile-readdirnames>)
  - [func (f *UnionFile) Seek(o int64, w int) (pos int64, err error)](<#func-unionfile-seek>)
  - [func (f *UnionFile) Stat() (os.FileInfo, error)](<#func-unionfile-stat>)
  - [func (f *UnionFile) Sync() (err error)](<#func-unionfile-sync>)
  - [func (f *UnionFile) Truncate(s int64) (err error)](<#func-unionfile-truncate>)
  - [func (f *UnionFile) Write(s []byte) (n int, err error)](<#func-unionfile-write>)
  - [func (f *UnionFile) WriteAt(s []byte, o int64) (n int, err error)](<#func-unionfile-writeat>)
  - [func (f *UnionFile) WriteString(s string) (n int, err error)](<#func-unionfile-writestring>)


## Constants

```go
const BADFD = syscall.EBADF
```

Filepath separator defined by os.Separator.

```go
const FilePathSeparator = string(filepath.Separator)
```

## Variables

```go
var (
    ErrFileClosed        = errors.New("File is closed")
    ErrOutOfRange        = errors.New("out of range")
    ErrTooLarge          = errors.New("too large")
    ErrFileNotFound      = os.ErrNotExist
    ErrFileExists        = os.ErrExist
    ErrDestinationExists = os.ErrExist
)
```

ErrNoReadlink is the error that will be wrapped in an os.Path if a file system does not support the readlink operation either directly or through its delegated filesystem. As expressed by support for the LinkReader interface.

```go
var ErrNoReadlink = errors.New("readlink not supported")
```

ErrNoSymlink is the error that will be wrapped in an os.LinkError if a file system does not support Symlink's either directly or through its delegated filesystem. As expressed by support for the Linker interface.

```go
var ErrNoSymlink = errors.New("symlink not supported")
```

## func DirExists

```go
func DirExists(fs Fs, path string) (bool, error)
```

DirExists checks if a path exists and is a directory.

## func Exists

```go
func Exists(fs Fs, path string) (bool, error)
```

Check if a file or directory exists.

## func FileContainsAnyBytes

```go
func FileContainsAnyBytes(fs Fs, filename string, subslices [][]byte) (bool, error)
```

Check if a file contains any of the specified byte slices.

## func FileContainsBytes

```go
func FileContainsBytes(fs Fs, filename string, subslice []byte) (bool, error)
```

Check if a file contains a specified byte slice.

## func FullBaseFsPath

```go
func FullBaseFsPath(basePathFs *BasePathFs, relativePath string) string
```

## func GetTempDir

```go
func GetTempDir(fs Fs, subPath string) string
```

GetTempDir returns the default temp directory with trailing slash if subPath is not empty then it will be created recursively with mode 777 rwx rwx rwx

## func Glob

```go
func Glob(fs Fs, pattern string) (matches []string, err error)
```

Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/\*/bin/ed \(assuming the Separator is '/'\).

Glob ignores file system errors such as I/O errors reading directories. The only possible returned error is ErrBadPattern, when pattern is malformed.

This was adapted from \(http://golang.org/pkg/path/filepath\) and uses several built\-ins from that package.

## func IsDir

```go
func IsDir(fs Fs, path string) (bool, error)
```

IsDir checks if a given path is a directory.

## func IsEmpty

```go
func IsEmpty(fs Fs, path string) (bool, error)
```

IsEmpty checks if a given file or directory is empty.

## func NeuterAccents

```go
func NeuterAccents(s string) string
```

Transform characters with accents into plain forms.

## func ReadAll

```go
func ReadAll(r io.Reader) ([]byte, error)
```

ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.

## func ReadDir

```go
func ReadDir(fs Fs, dirname string) ([]os.FileInfo, error)
```

## func ReadFile

```go
func ReadFile(fs Fs, filename string) ([]byte, error)
```

## func SafeWriteReader

```go
func SafeWriteReader(fs Fs, path string, r io.Reader) (err error)
```

## func TempDir

```go
func TempDir(fs Fs, dir, prefix string) (name string, err error)
```

## func UnicodeSanitize

```go
func UnicodeSanitize(s string) string
```

Rewrite string to remove non\-standard path characters

## func Walk

```go
func Walk(fs Fs, root string, walkFn filepath.WalkFunc) error
```

## func WriteFile

```go
func WriteFile(fs Fs, filename string, data []byte, perm os.FileMode) error
```

## func WriteReader

```go
func WriteReader(fs Fs, path string, r io.Reader) (err error)
```

## type Afero

```go
type Afero struct {
    Fs
}
```

### func \(Afero\) DirExists

```go
func (a Afero) DirExists(path string) (bool, error)
```

### func \(Afero\) Exists

```go
func (a Afero) Exists(path string) (bool, error)
```

### func \(Afero\) FileContainsAnyBytes

```go
func (a Afero) FileContainsAnyBytes(filename string, subslices [][]byte) (bool, error)
```

### func \(Afero\) FileContainsBytes

```go
func (a Afero) FileContainsBytes(filename string, subslice []byte) (bool, error)
```

### func \(Afero\) GetTempDir

```go
func (a Afero) GetTempDir(subPath string) string
```

### func \(Afero\) IsDir

```go
func (a Afero) IsDir(path string) (bool, error)
```

### func \(Afero\) IsEmpty

```go
func (a Afero) IsEmpty(path string) (bool, error)
```

### func \(Afero\) ReadDir

```go
func (a Afero) ReadDir(dirname string) ([]os.FileInfo, error)
```

ReadDir reads the directory named by dirname and returns a list of sorted directory entries.

### func \(Afero\) ReadFile

```go
func (a Afero) ReadFile(filename string) ([]byte, error)
```

ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.

### func \(Afero\) SafeWriteReader

```go
func (a Afero) SafeWriteReader(path string, r io.Reader) (err error)
```

Same as WriteReader but checks to see if file/directory already exists.

### func \(Afero\) TempDir

```go
func (a Afero) TempDir(dir, prefix string) (name string, err error)
```

TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory.  If dir is the empty string, TempDir uses the default directory for temporary files \(see os.TempDir\). Multiple programs calling TempDir simultaneously will not choose the same directory.  It is the caller's responsibility to remove the directory when no longer needed.

### func \(Afero\) TempFile

```go
func (a Afero) TempFile(dir, pattern string) (f File, err error)
```

TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting \*os.File. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a "\*", the random string replaces the last "\*". If dir is the empty string, TempFile uses the default directory for temporary files \(see os.TempDir\). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name\(\) to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.

### func \(Afero\) Walk

```go
func (a Afero) Walk(root string, walkFn filepath.WalkFunc) error
```

### func \(Afero\) WriteFile

```go
func (a Afero) WriteFile(filename string, data []byte, perm os.FileMode) error
```

WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm; otherwise WriteFile truncates it before writing.

### func \(Afero\) WriteReader

```go
func (a Afero) WriteReader(path string, r io.Reader) (err error)
```

Takes a reader and a path and writes the content

## type BasePathFile

```go
type BasePathFile struct {
    File
    // contains filtered or unexported fields
}
```

### func \(\*BasePathFile\) Name

```go
func (f *BasePathFile) Name() string
```

### func \(\*BasePathFile\) ReadDir

```go
func (f *BasePathFile) ReadDir(n int) ([]fs.DirEntry, error)
```

## type BasePathFs

The BasePathFs restricts all operations to a given path within an Fs. The given file name to the operations on this Fs will be prepended with the base path before calling the base Fs. Any file name \(after filepath.Clean\(\)\) outside this base path will be treated as non existing file.

Note that it does not clean the error messages on return, so you may reveal the real path on errors.

```go
type BasePathFs struct {
    // contains filtered or unexported fields
}
```

### func \(\*BasePathFs\) Chmod

```go
func (b *BasePathFs) Chmod(name string, mode os.FileMode) (err error)
```

### func \(\*BasePathFs\) Chown

```go
func (b *BasePathFs) Chown(name string, uid, gid int) (err error)
```

### func \(\*BasePathFs\) Chtimes

```go
func (b *BasePathFs) Chtimes(name string, atime, mtime time.Time) (err error)
```

### func \(\*BasePathFs\) Create

```go
func (b *BasePathFs) Create(name string) (f File, err error)
```

### func \(\*BasePathFs\) LstatIfPossible

```go
func (b *BasePathFs) LstatIfPossible(name string) (os.FileInfo, bool, error)
```

### func \(\*BasePathFs\) Mkdir

```go
func (b *BasePathFs) Mkdir(name string, mode os.FileMode) (err error)
```

### func \(\*BasePathFs\) MkdirAll

```go
func (b *BasePathFs) MkdirAll(name string, mode os.FileMode) (err error)
```

### func \(\*BasePathFs\) Name

```go
func (b *BasePathFs) Name() string
```

### func \(\*BasePathFs\) Open

```go
func (b *BasePathFs) Open(name string) (f File, err error)
```

### func \(\*BasePathFs\) OpenFile

```go
func (b *BasePathFs) OpenFile(name string, flag int, mode os.FileMode) (f File, err error)
```

### func \(\*BasePathFs\) ReadlinkIfPossible

```go
func (b *BasePathFs) ReadlinkIfPossible(name string) (string, error)
```

### func \(\*BasePathFs\) RealPath

```go
func (b *BasePathFs) RealPath(name string) (path string, err error)
```

on a file outside the base path it returns the given file name and an error, else the given file with the base path prepended

### func \(\*BasePathFs\) Remove

```go
func (b *BasePathFs) Remove(name string) (err error)
```

### func \(\*BasePathFs\) RemoveAll

```go
func (b *BasePathFs) RemoveAll(name string) (err error)
```

### func \(\*BasePathFs\) Rename

```go
func (b *BasePathFs) Rename(oldname, newname string) (err error)
```

### func \(\*BasePathFs\) Stat

```go
func (b *BasePathFs) Stat(name string) (fi os.FileInfo, err error)
```

### func \(\*BasePathFs\) SymlinkIfPossible

```go
func (b *BasePathFs) SymlinkIfPossible(oldname, newname string) error
```

## type CacheOnReadFs

If the cache duration is 0, cache time will be unlimited, i.e. once a file is in the layer, the base will never be read again for this file.

For cache times greater than 0, the modification time of a file is checked. Note that a lot of file system implementations only allow a resolution of a second for timestamps... or as the godoc for os.Chtimes\(\) states: "The underlying filesystem may truncate or round the values to a less precise time unit."

This caching union will forward all write calls also to the base file system first. To prevent writing to the base Fs, wrap it in a read\-only filter \- Note: this will also make the overlay read\-only, for writing files in the overlay, use the overlay Fs directly, not via the union Fs.

```go
type CacheOnReadFs struct {
    // contains filtered or unexported fields
}
```

### func \(\*CacheOnReadFs\) Chmod

```go
func (u *CacheOnReadFs) Chmod(name string, mode os.FileMode) error
```

### func \(\*CacheOnReadFs\) Chown

```go
func (u *CacheOnReadFs) Chown(name string, uid, gid int) error
```

### func \(\*CacheOnReadFs\) Chtimes

```go
func (u *CacheOnReadFs) Chtimes(name string, atime, mtime time.Time) error
```

### func \(\*CacheOnReadFs\) Create

```go
func (u *CacheOnReadFs) Create(name string) (File, error)
```

### func \(\*CacheOnReadFs\) Mkdir

```go
func (u *CacheOnReadFs) Mkdir(name string, perm os.FileMode) error
```

### func \(\*CacheOnReadFs\) MkdirAll

```go
func (u *CacheOnReadFs) MkdirAll(name string, perm os.FileMode) error
```

### func \(\*CacheOnReadFs\) Name

```go
func (u *CacheOnReadFs) Name() string
```

### func \(\*CacheOnReadFs\) Open

```go
func (u *CacheOnReadFs) Open(name string) (File, error)
```

### func \(\*CacheOnReadFs\) OpenFile

```go
func (u *CacheOnReadFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(\*CacheOnReadFs\) Remove

```go
func (u *CacheOnReadFs) Remove(name string) error
```

### func \(\*CacheOnReadFs\) RemoveAll

```go
func (u *CacheOnReadFs) RemoveAll(name string) error
```

### func \(\*CacheOnReadFs\) Rename

```go
func (u *CacheOnReadFs) Rename(oldname, newname string) error
```

### func \(\*CacheOnReadFs\) Stat

```go
func (u *CacheOnReadFs) Stat(name string) (os.FileInfo, error)
```

## type CopyOnWriteFs

The CopyOnWriteFs is a union filesystem: a read only base file system with a possibly writeable layer on top. Changes to the file system will only be made in the overlay: Changing an existing file in the base layer which is not present in the overlay will copy the file to the overlay \("changing" includes also calls to e.g. Chtimes\(\), Chmod\(\) and Chown\(\)\).

Reading directories is currently only supported via Open\(\), not OpenFile\(\).

```go
type CopyOnWriteFs struct {
    // contains filtered or unexported fields
}
```

### func \(\*CopyOnWriteFs\) Chmod

```go
func (u *CopyOnWriteFs) Chmod(name string, mode os.FileMode) error
```

### func \(\*CopyOnWriteFs\) Chown

```go
func (u *CopyOnWriteFs) Chown(name string, uid, gid int) error
```

### func \(\*CopyOnWriteFs\) Chtimes

```go
func (u *CopyOnWriteFs) Chtimes(name string, atime, mtime time.Time) error
```

### func \(\*CopyOnWriteFs\) Create

```go
func (u *CopyOnWriteFs) Create(name string) (File, error)
```

### func \(\*CopyOnWriteFs\) LstatIfPossible

```go
func (u *CopyOnWriteFs) LstatIfPossible(name string) (os.FileInfo, bool, error)
```

### func \(\*CopyOnWriteFs\) Mkdir

```go
func (u *CopyOnWriteFs) Mkdir(name string, perm os.FileMode) error
```

### func \(\*CopyOnWriteFs\) MkdirAll

```go
func (u *CopyOnWriteFs) MkdirAll(name string, perm os.FileMode) error
```

### func \(\*CopyOnWriteFs\) Name

```go
func (u *CopyOnWriteFs) Name() string
```

### func \(\*CopyOnWriteFs\) Open

```go
func (u *CopyOnWriteFs) Open(name string) (File, error)
```

This function handles the 9 different possibilities caused by the union which are the intersection of the following... layer: doesn't exist, exists as a file, and exists as a directory base:  doesn't exist, exists as a file, and exists as a directory

### func \(\*CopyOnWriteFs\) OpenFile

```go
func (u *CopyOnWriteFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(\*CopyOnWriteFs\) ReadlinkIfPossible

```go
func (u *CopyOnWriteFs) ReadlinkIfPossible(name string) (string, error)
```

### func \(\*CopyOnWriteFs\) Remove

```go
func (u *CopyOnWriteFs) Remove(name string) error
```

Removing files present only in the base layer is not permitted. If a file is present in the base layer and the overlay, only the overlay will be removed.

### func \(\*CopyOnWriteFs\) RemoveAll

```go
func (u *CopyOnWriteFs) RemoveAll(name string) error
```

### func \(\*CopyOnWriteFs\) Rename

```go
func (u *CopyOnWriteFs) Rename(oldname, newname string) error
```

Renaming files present only in the base layer is not permitted

### func \(\*CopyOnWriteFs\) Stat

```go
func (u *CopyOnWriteFs) Stat(name string) (os.FileInfo, error)
```

### func \(\*CopyOnWriteFs\) SymlinkIfPossible

```go
func (u *CopyOnWriteFs) SymlinkIfPossible(oldname, newname string) error
```

## type DirsMerger

DirsMerger is how UnionFile weaves two directories together. It takes the FileInfo slices from the layer and the base and returns a single view.

```go
type DirsMerger func(lofi, bofi []os.FileInfo) ([]os.FileInfo, error)
```

## type File

File represents a file in the filesystem.

```go
type File interface {
    io.Closer
    io.Reader
    io.ReaderAt
    io.Seeker
    io.Writer
    io.WriterAt

    Name() string
    Readdir(count int) ([]os.FileInfo, error)
    Readdirnames(n int) ([]string, error)
    Stat() (os.FileInfo, error)
    Sync() error
    Truncate(size int64) error
    WriteString(s string) (ret int, err error)
}
```

### func TempFile

```go
func TempFile(fs Fs, dir, pattern string) (f File, err error)
```

## type FromIOFS

FromIOFS adopts io/fs.FS to use it as afero.Fs Note that io/fs.FS is read\-only so all mutating methods will return fs.PathError with fs.ErrPermission To store modifications you may use afero.CopyOnWriteFs

```go
type FromIOFS struct {
    fs.FS
}
```

### func \(FromIOFS\) Chmod

```go
func (f FromIOFS) Chmod(name string, mode os.FileMode) error
```

### func \(FromIOFS\) Chown

```go
func (f FromIOFS) Chown(name string, uid, gid int) error
```

### func \(FromIOFS\) Chtimes

```go
func (f FromIOFS) Chtimes(name string, atime time.Time, mtime time.Time) error
```

### func \(FromIOFS\) Create

```go
func (f FromIOFS) Create(name string) (File, error)
```

### func \(FromIOFS\) Mkdir

```go
func (f FromIOFS) Mkdir(name string, perm os.FileMode) error
```

### func \(FromIOFS\) MkdirAll

```go
func (f FromIOFS) MkdirAll(path string, perm os.FileMode) error
```

### func \(FromIOFS\) Name

```go
func (f FromIOFS) Name() string
```

### func \(FromIOFS\) Open

```go
func (f FromIOFS) Open(name string) (File, error)
```

### func \(FromIOFS\) OpenFile

```go
func (f FromIOFS) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(FromIOFS\) Remove

```go
func (f FromIOFS) Remove(name string) error
```

### func \(FromIOFS\) RemoveAll

```go
func (f FromIOFS) RemoveAll(path string) error
```

### func \(FromIOFS\) Rename

```go
func (f FromIOFS) Rename(oldname, newname string) error
```

### func \(FromIOFS\) Stat

```go
func (f FromIOFS) Stat(name string) (os.FileInfo, error)
```

## type Fs

Fs is the filesystem interface.

Any simulated or real filesystem should implement this interface.

```go
type Fs interface {
    // Create creates a file in the filesystem, returning the file and an
    // error, if any happens.
    Create(name string) (File, error)

    // Mkdir creates a directory in the filesystem, return an error if any
    // happens.
    Mkdir(name string, perm os.FileMode) error

    // MkdirAll creates a directory path and all parents that does not exist
    // yet.
    MkdirAll(path string, perm os.FileMode) error

    // Open opens a file, returning it or an error, if any happens.
    Open(name string) (File, error)

    // OpenFile opens a file using the given flags and the given mode.
    OpenFile(name string, flag int, perm os.FileMode) (File, error)

    // Remove removes a file identified by name, returning an error, if any
    // happens.
    Remove(name string) error

    // RemoveAll removes a directory path and any children it contains. It
    // does not fail if the path does not exist (return nil).
    RemoveAll(path string) error

    // Rename renames a file.
    Rename(oldname, newname string) error

    // Stat returns a FileInfo describing the named file, or an error, if any
    // happens.
    Stat(name string) (os.FileInfo, error)

    // The name of this FileSystem
    Name() string

    // Chmod changes the mode of the named file to mode.
    Chmod(name string, mode os.FileMode) error

    // Chown changes the uid and gid of the named file.
    Chown(name string, uid, gid int) error

    //Chtimes changes the access and modification times of the named file
    Chtimes(name string, atime time.Time, mtime time.Time) error
}
```

### func NewBasePathFs

```go
func NewBasePathFs(source Fs, path string) Fs
```

### func NewCacheOnReadFs

```go
func NewCacheOnReadFs(base Fs, layer Fs, cacheTime time.Duration) Fs
```

### func NewCopyOnWriteFs

```go
func NewCopyOnWriteFs(base Fs, layer Fs) Fs
```

### func NewMemMapFs

```go
func NewMemMapFs() Fs
```

### func NewOsFs

```go
func NewOsFs() Fs
```

### func NewReadOnlyFs

```go
func NewReadOnlyFs(source Fs) Fs
```

### func NewRegexpFs

```go
func NewRegexpFs(source Fs, re *regexp.Regexp) Fs
```

## type HttpFs

```go
type HttpFs struct {
    // contains filtered or unexported fields
}
```

### func NewHttpFs

```go
func NewHttpFs(source Fs) *HttpFs
```

### func \(HttpFs\) Chmod

```go
func (h HttpFs) Chmod(name string, mode os.FileMode) error
```

### func \(HttpFs\) Chown

```go
func (h HttpFs) Chown(name string, uid, gid int) error
```

### func \(HttpFs\) Chtimes

```go
func (h HttpFs) Chtimes(name string, atime time.Time, mtime time.Time) error
```

### func \(HttpFs\) Create

```go
func (h HttpFs) Create(name string) (File, error)
```

### func \(HttpFs\) Dir

```go
func (h HttpFs) Dir(s string) *httpDir
```

### func \(HttpFs\) Mkdir

```go
func (h HttpFs) Mkdir(name string, perm os.FileMode) error
```

### func \(HttpFs\) MkdirAll

```go
func (h HttpFs) MkdirAll(path string, perm os.FileMode) error
```

### func \(HttpFs\) Name

```go
func (h HttpFs) Name() string
```

### func \(HttpFs\) Open

```go
func (h HttpFs) Open(name string) (http.File, error)
```

### func \(HttpFs\) OpenFile

```go
func (h HttpFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(HttpFs\) Remove

```go
func (h HttpFs) Remove(name string) error
```

### func \(HttpFs\) RemoveAll

```go
func (h HttpFs) RemoveAll(path string) error
```

### func \(HttpFs\) Rename

```go
func (h HttpFs) Rename(oldname, newname string) error
```

### func \(HttpFs\) Stat

```go
func (h HttpFs) Stat(name string) (os.FileInfo, error)
```

## type IOFS

IOFS adopts afero.Fs to stdlib io/fs.FS

```go
type IOFS struct {
    Fs
}
```

### func NewIOFS

```go
func NewIOFS(fs Fs) IOFS
```

### func \(IOFS\) Glob

```go
func (iofs IOFS) Glob(pattern string) ([]string, error)
```

### func \(IOFS\) Open

```go
func (iofs IOFS) Open(name string) (fs.File, error)
```

### func \(IOFS\) ReadDir

```go
func (iofs IOFS) ReadDir(name string) ([]fs.DirEntry, error)
```

### func \(IOFS\) ReadFile

```go
func (iofs IOFS) ReadFile(name string) ([]byte, error)
```

### func \(IOFS\) Sub

```go
func (iofs IOFS) Sub(dir string) (fs.FS, error)
```

## type LinkReader

LinkReader is an optional interface in Afero. It is only implemented by the filesystems saying so.

```go
type LinkReader interface {
    ReadlinkIfPossible(name string) (string, error)
}
```

## type Linker

Linker is an optional interface in Afero. It is only implemented by the filesystems saying so. It will call Symlink if the filesystem itself is, or it delegates to, the os filesystem, or the filesystem otherwise supports Symlink's.

```go
type Linker interface {
    SymlinkIfPossible(oldname, newname string) error
}
```

## type Lstater

Lstater is an optional interface in Afero. It is only implemented by the filesystems saying so. It will call Lstat if the filesystem iself is, or it delegates to, the os filesystem. Else it will call Stat. In addtion to the FileInfo, it will return a boolean telling whether Lstat was called or not.

```go
type Lstater interface {
    LstatIfPossible(name string) (os.FileInfo, bool, error)
}
```

## type MemMapFs

```go
type MemMapFs struct {
    // contains filtered or unexported fields
}
```

### func \(\*MemMapFs\) Chmod

```go
func (m *MemMapFs) Chmod(name string, mode os.FileMode) error
```

### func \(\*MemMapFs\) Chown

```go
func (m *MemMapFs) Chown(name string, uid, gid int) error
```

### func \(\*MemMapFs\) Chtimes

```go
func (m *MemMapFs) Chtimes(name string, atime time.Time, mtime time.Time) error
```

### func \(\*MemMapFs\) Create

```go
func (m *MemMapFs) Create(name string) (File, error)
```

### func \(\*MemMapFs\) List

```go
func (m *MemMapFs) List()
```

### func \(\*MemMapFs\) LstatIfPossible

```go
func (m *MemMapFs) LstatIfPossible(name string) (os.FileInfo, bool, error)
```

### func \(\*MemMapFs\) Mkdir

```go
func (m *MemMapFs) Mkdir(name string, perm os.FileMode) error
```

### func \(\*MemMapFs\) MkdirAll

```go
func (m *MemMapFs) MkdirAll(path string, perm os.FileMode) error
```

### func \(\*MemMapFs\) Name

```go
func (*MemMapFs) Name() string
```

### func \(\*MemMapFs\) Open

```go
func (m *MemMapFs) Open(name string) (File, error)
```

### func \(\*MemMapFs\) OpenFile

```go
func (m *MemMapFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(\*MemMapFs\) Remove

```go
func (m *MemMapFs) Remove(name string) error
```

### func \(\*MemMapFs\) RemoveAll

```go
func (m *MemMapFs) RemoveAll(path string) error
```

### func \(\*MemMapFs\) Rename

```go
func (m *MemMapFs) Rename(oldname, newname string) error
```

### func \(\*MemMapFs\) Stat

```go
func (m *MemMapFs) Stat(name string) (os.FileInfo, error)
```

## type OsFs

OsFs is a Fs implementation that uses functions provided by the os package.

For details in any method, check the documentation of the os package \(http://golang.org/pkg/os/\).

```go
type OsFs struct{}
```

### func \(OsFs\) Chmod

```go
func (OsFs) Chmod(name string, mode os.FileMode) error
```

### func \(OsFs\) Chown

```go
func (OsFs) Chown(name string, uid, gid int) error
```

### func \(OsFs\) Chtimes

```go
func (OsFs) Chtimes(name string, atime time.Time, mtime time.Time) error
```

### func \(OsFs\) Create

```go
func (OsFs) Create(name string) (File, error)
```

### func \(OsFs\) LstatIfPossible

```go
func (OsFs) LstatIfPossible(name string) (os.FileInfo, bool, error)
```

### func \(OsFs\) Mkdir

```go
func (OsFs) Mkdir(name string, perm os.FileMode) error
```

### func \(OsFs\) MkdirAll

```go
func (OsFs) MkdirAll(path string, perm os.FileMode) error
```

### func \(OsFs\) Name

```go
func (OsFs) Name() string
```

### func \(OsFs\) Open

```go
func (OsFs) Open(name string) (File, error)
```

### func \(OsFs\) OpenFile

```go
func (OsFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(OsFs\) ReadlinkIfPossible

```go
func (OsFs) ReadlinkIfPossible(name string) (string, error)
```

### func \(OsFs\) Remove

```go
func (OsFs) Remove(name string) error
```

### func \(OsFs\) RemoveAll

```go
func (OsFs) RemoveAll(path string) error
```

### func \(OsFs\) Rename

```go
func (OsFs) Rename(oldname, newname string) error
```

### func \(OsFs\) Stat

```go
func (OsFs) Stat(name string) (os.FileInfo, error)
```

### func \(OsFs\) SymlinkIfPossible

```go
func (OsFs) SymlinkIfPossible(oldname, newname string) error
```

## type ReadOnlyFs

```go
type ReadOnlyFs struct {
    // contains filtered or unexported fields
}
```

### func \(\*ReadOnlyFs\) Chmod

```go
func (r *ReadOnlyFs) Chmod(n string, m os.FileMode) error
```

### func \(\*ReadOnlyFs\) Chown

```go
func (r *ReadOnlyFs) Chown(n string, uid, gid int) error
```

### func \(\*ReadOnlyFs\) Chtimes

```go
func (r *ReadOnlyFs) Chtimes(n string, a, m time.Time) error
```

### func \(\*ReadOnlyFs\) Create

```go
func (r *ReadOnlyFs) Create(n string) (File, error)
```

### func \(\*ReadOnlyFs\) LstatIfPossible

```go
func (r *ReadOnlyFs) LstatIfPossible(name string) (os.FileInfo, bool, error)
```

### func \(\*ReadOnlyFs\) Mkdir

```go
func (r *ReadOnlyFs) Mkdir(n string, p os.FileMode) error
```

### func \(\*ReadOnlyFs\) MkdirAll

```go
func (r *ReadOnlyFs) MkdirAll(n string, p os.FileMode) error
```

### func \(\*ReadOnlyFs\) Name

```go
func (r *ReadOnlyFs) Name() string
```

### func \(\*ReadOnlyFs\) Open

```go
func (r *ReadOnlyFs) Open(n string) (File, error)
```

### func \(\*ReadOnlyFs\) OpenFile

```go
func (r *ReadOnlyFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(\*ReadOnlyFs\) ReadDir

```go
func (r *ReadOnlyFs) ReadDir(name string) ([]os.FileInfo, error)
```

### func \(\*ReadOnlyFs\) ReadlinkIfPossible

```go
func (r *ReadOnlyFs) ReadlinkIfPossible(name string) (string, error)
```

### func \(\*ReadOnlyFs\) Remove

```go
func (r *ReadOnlyFs) Remove(n string) error
```

### func \(\*ReadOnlyFs\) RemoveAll

```go
func (r *ReadOnlyFs) RemoveAll(p string) error
```

### func \(\*ReadOnlyFs\) Rename

```go
func (r *ReadOnlyFs) Rename(o, n string) error
```

### func \(\*ReadOnlyFs\) Stat

```go
func (r *ReadOnlyFs) Stat(name string) (os.FileInfo, error)
```

### func \(\*ReadOnlyFs\) SymlinkIfPossible

```go
func (r *ReadOnlyFs) SymlinkIfPossible(oldname, newname string) error
```

## type RegexpFile

```go
type RegexpFile struct {
    // contains filtered or unexported fields
}
```

### func \(\*RegexpFile\) Close

```go
func (f *RegexpFile) Close() error
```

### func \(\*RegexpFile\) Name

```go
func (f *RegexpFile) Name() string
```

### func \(\*RegexpFile\) Read

```go
func (f *RegexpFile) Read(s []byte) (int, error)
```

### func \(\*RegexpFile\) ReadAt

```go
func (f *RegexpFile) ReadAt(s []byte, o int64) (int, error)
```

### func \(\*RegexpFile\) Readdir

```go
func (f *RegexpFile) Readdir(c int) (fi []os.FileInfo, err error)
```

### func \(\*RegexpFile\) Readdirnames

```go
func (f *RegexpFile) Readdirnames(c int) (n []string, err error)
```

### func \(\*RegexpFile\) Seek

```go
func (f *RegexpFile) Seek(o int64, w int) (int64, error)
```

### func \(\*RegexpFile\) Stat

```go
func (f *RegexpFile) Stat() (os.FileInfo, error)
```

### func \(\*RegexpFile\) Sync

```go
func (f *RegexpFile) Sync() error
```

### func \(\*RegexpFile\) Truncate

```go
func (f *RegexpFile) Truncate(s int64) error
```

### func \(\*RegexpFile\) Write

```go
func (f *RegexpFile) Write(s []byte) (int, error)
```

### func \(\*RegexpFile\) WriteAt

```go
func (f *RegexpFile) WriteAt(s []byte, o int64) (int, error)
```

### func \(\*RegexpFile\) WriteString

```go
func (f *RegexpFile) WriteString(s string) (int, error)
```

## type RegexpFs

The RegexpFs filters files \(not directories\) by regular expression. Only files matching the given regexp will be allowed, all others get a ENOENT error \( "No such file or directory"\).

```go
type RegexpFs struct {
    // contains filtered or unexported fields
}
```

### func \(\*RegexpFs\) Chmod

```go
func (r *RegexpFs) Chmod(name string, mode os.FileMode) error
```

### func \(\*RegexpFs\) Chown

```go
func (r *RegexpFs) Chown(name string, uid, gid int) error
```

### func \(\*RegexpFs\) Chtimes

```go
func (r *RegexpFs) Chtimes(name string, a, m time.Time) error
```

### func \(\*RegexpFs\) Create

```go
func (r *RegexpFs) Create(name string) (File, error)
```

### func \(\*RegexpFs\) Mkdir

```go
func (r *RegexpFs) Mkdir(n string, p os.FileMode) error
```

### func \(\*RegexpFs\) MkdirAll

```go
func (r *RegexpFs) MkdirAll(n string, p os.FileMode) error
```

### func \(\*RegexpFs\) Name

```go
func (r *RegexpFs) Name() string
```

### func \(\*RegexpFs\) Open

```go
func (r *RegexpFs) Open(name string) (File, error)
```

### func \(\*RegexpFs\) OpenFile

```go
func (r *RegexpFs) OpenFile(name string, flag int, perm os.FileMode) (File, error)
```

### func \(\*RegexpFs\) Remove

```go
func (r *RegexpFs) Remove(name string) error
```

### func \(\*RegexpFs\) RemoveAll

```go
func (r *RegexpFs) RemoveAll(p string) error
```

### func \(\*RegexpFs\) Rename

```go
func (r *RegexpFs) Rename(oldname, newname string) error
```

### func \(\*RegexpFs\) Stat

```go
func (r *RegexpFs) Stat(name string) (os.FileInfo, error)
```

## type Symlinker

Symlinker is an optional interface in Afero. It is only implemented by the filesystems saying so. It indicates support for 3 symlink related interfaces that implement the behaviors of the os methods: \- Lstat \- Symlink, and \- Readlink

```go
type Symlinker interface {
    Lstater
    Linker
    LinkReader
}
```

## type UnionFile

The UnionFile implements the afero.File interface and will be returned when reading a directory present at least in the overlay or opening a file for writing.

The calls to Readdir\(\) and Readdirnames\(\) merge the file os.FileInfo / names from the base and the overlay \- for files present in both layers, only those from the overlay will be used.

When opening files for writing \(Create\(\) / OpenFile\(\) with the right flags\) the operations will be done in both layers, starting with the overlay. A successful read in the overlay will move the cursor position in the base layer by the number of bytes read.

```go
type UnionFile struct {
    Base   File
    Layer  File
    Merger DirsMerger
    // contains filtered or unexported fields
}
```

### func \(\*UnionFile\) Close

```go
func (f *UnionFile) Close() error
```

### func \(\*UnionFile\) Name

```go
func (f *UnionFile) Name() string
```

### func \(\*UnionFile\) Read

```go
func (f *UnionFile) Read(s []byte) (int, error)
```

### func \(\*UnionFile\) ReadAt

```go
func (f *UnionFile) ReadAt(s []byte, o int64) (int, error)
```

### func \(\*UnionFile\) Readdir

```go
func (f *UnionFile) Readdir(c int) (ofi []os.FileInfo, err error)
```

Readdir will weave the two directories together and return a single view of the overlayed directories. At the end of the directory view, the error is io.EOF if c \> 0.

### func \(\*UnionFile\) Readdirnames

```go
func (f *UnionFile) Readdirnames(c int) ([]string, error)
```

### func \(\*UnionFile\) Seek

```go
func (f *UnionFile) Seek(o int64, w int) (pos int64, err error)
```

### func \(\*UnionFile\) Stat

```go
func (f *UnionFile) Stat() (os.FileInfo, error)
```

### func \(\*UnionFile\) Sync

```go
func (f *UnionFile) Sync() (err error)
```

### func \(\*UnionFile\) Truncate

```go
func (f *UnionFile) Truncate(s int64) (err error)
```

### func \(\*UnionFile\) Write

```go
func (f *UnionFile) Write(s []byte) (n int, err error)
```

### func \(\*UnionFile\) WriteAt

```go
func (f *UnionFile) WriteAt(s []byte, o int64) (n int, err error)
```

### func \(\*UnionFile\) WriteString

```go
func (f *UnionFile) WriteString(s string) (n int, err error)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
