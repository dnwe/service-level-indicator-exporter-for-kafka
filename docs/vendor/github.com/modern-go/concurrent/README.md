<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# concurrent

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/modern-go/concurrent"
```

## Index

- [Variables](<#variables>)
- [type Executor](<#type-executor>)
- [type Map](<#type-map>)
  - [func NewMap() *Map](<#func-newmap>)
- [type UnboundedExecutor](<#type-unboundedexecutor>)
  - [func NewUnboundedExecutor() *UnboundedExecutor](<#func-newunboundedexecutor>)
  - [func (executor *UnboundedExecutor) Go(handler func(ctx context.Context))](<#func-unboundedexecutor-go>)
  - [func (executor *UnboundedExecutor) Stop()](<#func-unboundedexecutor-stop>)
  - [func (executor *UnboundedExecutor) StopAndWait(ctx context.Context)](<#func-unboundedexecutor-stopandwait>)
  - [func (executor *UnboundedExecutor) StopAndWaitForever()](<#func-unboundedexecutor-stopandwaitforever>)


## Variables

ErrorLogger is used to print out error, can be set to writer other than stderr

```go
var ErrorLogger = log.New(os.Stderr, "", 0)
```

GlobalUnboundedExecutor has the life cycle of the program itself any goroutine want to be shutdown before main exit can be started from this executor GlobalUnboundedExecutor expects the main function to call stop it does not magically knows the main function exits

```go
var GlobalUnboundedExecutor = NewUnboundedExecutor()
```

HandlePanic logs goroutine panic by default

```go
var HandlePanic = func(recovered interface{}, funcName string) {
    ErrorLogger.Println(fmt.Sprintf("%s panic: %v", funcName, recovered))
    ErrorLogger.Println(string(debug.Stack()))
}
```

InfoLogger is used to print informational message, default to off

```go
var InfoLogger = log.New(ioutil.Discard, "", 0)
```

## type Executor

Executor replace go keyword to start a new goroutine the goroutine should cancel itself if the context passed in has been cancelled the goroutine started by the executor, is owned by the executor we can cancel all executors owned by the executor just by stop the executor itself however Executor interface does not Stop method, the one starting and owning executor should use the concrete type of executor, instead of this interface.

```go
type Executor interface {
    // Go starts a new goroutine controlled by the context
    Go(handler func(ctx context.Context))
}
```

## type Map

Map is a wrapper for sync.Map introduced in go1.9

```go
type Map struct {
    sync.Map
}
```

### func NewMap

```go
func NewMap() *Map
```

NewMap creates a thread safe Map

## type UnboundedExecutor

UnboundedExecutor is a executor without limits on counts of alive goroutines it tracks the goroutine started by it, and can cancel them when shutdown

```go
type UnboundedExecutor struct {
    HandlePanic func(recovered interface{}, funcName string)
    // contains filtered or unexported fields
}
```

### func NewUnboundedExecutor

```go
func NewUnboundedExecutor() *UnboundedExecutor
```

NewUnboundedExecutor creates a new UnboundedExecutor, UnboundedExecutor can not be created by &UnboundedExecutor\{\} HandlePanic can be set with a callback to override global HandlePanic

### func \(\*UnboundedExecutor\) Go

```go
func (executor *UnboundedExecutor) Go(handler func(ctx context.Context))
```

Go starts a new goroutine and tracks its lifecycle. Panic will be recovered and logged automatically, except for StopSignal

### func \(\*UnboundedExecutor\) Stop

```go
func (executor *UnboundedExecutor) Stop()
```

Stop cancel all goroutines started by this executor without wait

### func \(\*UnboundedExecutor\) StopAndWait

```go
func (executor *UnboundedExecutor) StopAndWait(ctx context.Context)
```

StopAndWait cancel all goroutines started by this executor and wait. Wait can be cancelled by the context passed in.

### func \(\*UnboundedExecutor\) StopAndWaitForever

```go
func (executor *UnboundedExecutor) StopAndWaitForever()
```

StopAndWaitForever cancel all goroutines started by this executor and wait until all goroutines exited



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
