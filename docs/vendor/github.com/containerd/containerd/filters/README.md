<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# filters

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/containerd/containerd/filters"
```

Package filters defines a syntax and parser that can be used for the filtration of items across the containerd API. The core is built on the concept of protobuf field paths, with quoting.  Several operators allow the user to flexibly select items based on field presence, equality, inequality and regular expressions. Flexible adaptors support working with any type.

The syntax is fairly familiar, if you've used container ecosystem projects.  At the core, we base it on the concept of protobuf field paths, augmenting with the ability to quote portions of the field path to match arbitrary labels. These "selectors" come in the following syntax:

\`\`\` \<fieldpath\>\[\<operator\>\<value\>\] \`\`\`

A basic example is as follows:

\`\`\` name==foo \`\`\`

This would match all objects that have a field \`name\` with the value \`foo\`. If we only want to test if the field is present, we can omit the operator. This is most useful for matching labels in containerd. The following will match objects that have the field "labels" and have the label "foo" defined:

\`\`\` labels.foo \`\`\`

We also allow for quoting of parts of the field path to allow matching of arbitrary items:

\`\`\` labels."very complex label"==something \`\`\`

We also define \`\!=\` and \`\~=\` as operators. The \`\!=\` will match all objects that don't match the value for a field and \`\~=\` will compile the target value as a regular expression and match the field value against that.

Selectors can be combined using a comma, such that the resulting selector will require all selectors are matched for the object to match. The following example will match objects that are named \`foo\` and have the label \`bar\`:

\`\`\` name==foo,labels.bar \`\`\`

## Index

- [type AdapterFunc](<#type-adapterfunc>)
  - [func (fn AdapterFunc) Field(fieldpath []string) (string, bool)](<#func-adapterfunc-field>)
- [type Adaptor](<#type-adaptor>)
- [type All](<#type-all>)
  - [func (m All) Match(adaptor Adaptor) bool](<#func-all-match>)
- [type Any](<#type-any>)
  - [func (m Any) Match(adaptor Adaptor) bool](<#func-any-match>)
- [type Filter](<#type-filter>)
  - [func Parse(s string) (Filter, error)](<#func-parse>)
  - [func ParseAll(ss ...string) (Filter, error)](<#func-parseall>)
- [type FilterFunc](<#type-filterfunc>)
  - [func (fn FilterFunc) Match(adaptor Adaptor) bool](<#func-filterfunc-match>)


## type AdapterFunc

AdapterFunc allows implementation specific matching of fieldpaths

```go
type AdapterFunc func(fieldpath []string) (string, bool)
```

### func \(AdapterFunc\) Field

```go
func (fn AdapterFunc) Field(fieldpath []string) (string, bool)
```

Field returns the field name and true if it exists

## type Adaptor

Adaptor specifies the mapping of fieldpaths to a type. For the given field path, the value and whether it is present should be returned. The mapping of the fieldpath to a field is deferred to the adaptor implementation, but should generally follow protobuf field path/mask semantics.

```go
type Adaptor interface {
    Field(fieldpath []string) (value string, present bool)
}
```

## type All

All allows multiple filters to be matched against the object

```go
type All []Filter
```

### func \(All\) Match

```go
func (m All) Match(adaptor Adaptor) bool
```

Match only returns true if all filters match the object

## type Any

Any allows multiple filters to be matched against the object

```go
type Any []Filter
```

### func \(Any\) Match

```go
func (m Any) Match(adaptor Adaptor) bool
```

Match returns true if any of the provided filters are true

## type Filter

Filter matches specific resources based the provided filter

```go
type Filter interface {
    Match(adaptor Adaptor) bool
}
```

### func Parse

```go
func Parse(s string) (Filter, error)
```

Parse the strings into a filter that may be used with an adaptor.

The filter is made up of zero or more selectors.

The format is a comma separated list of expressions, in the form of \`\<fieldpath\>\<op\>\<value\>\`, known as selectors. All selectors must match the target object for the filter to be true.

We define the operators "==" for equality, "\!=" for not equal and "\~=" for a regular expression. If the operator and value are not present, the matcher will test for the presence of a value, as defined by the target object.

The formal grammar is as follows:

selectors := selector \("," selector\)\* selector  := fieldpath \(operator value\) fieldpath := field \('.' field\)\* field     := quoted | \[A\-Za\-z\] \[A\-Za\-z0\-9\_\]\+ operator  := "==" | "\!=" | "\~=" value     := quoted | \[^\\s,\]\+ quoted    := \<go string syntax\>

### func ParseAll

```go
func ParseAll(ss ...string) (Filter, error)
```

ParseAll parses each filter in ss and returns a filter that will return true if any filter matches the expression.

If no filters are provided, the filter will match anything.

## type FilterFunc

FilterFunc is a function that handles matching with an adaptor

```go
type FilterFunc func(Adaptor) bool
```

Always is a filter that always returns true for any type of object

```go
var Always FilterFunc = func(adaptor Adaptor) bool {
    return true
}
```

### func \(FilterFunc\) Match

```go
func (fn FilterFunc) Match(adaptor Adaptor) bool
```

Match matches the FilterFunc returning true if the object matches the filter



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
