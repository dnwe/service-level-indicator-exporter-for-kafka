<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# changelist

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/theupdateframework/notary/client/changelist"
```

## Index

- [Constants](<#constants>)
- [type Change](<#type-change>)
- [type ChangeIterator](<#type-changeiterator>)
- [type Changelist](<#type-changelist>)
  - [func NewMemChangelist() Changelist](<#func-newmemchangelist>)
- [type FileChangeListIterator](<#type-filechangelistiterator>)
  - [func (m *FileChangeListIterator) HasNext() bool](<#func-filechangelistiterator-hasnext>)
  - [func (m *FileChangeListIterator) Next() (item Change, err error)](<#func-filechangelistiterator-next>)
- [type FileChangelist](<#type-filechangelist>)
  - [func NewFileChangelist(dir string) (*FileChangelist, error)](<#func-newfilechangelist>)
  - [func (cl FileChangelist) Add(c Change) error](<#func-filechangelist-add>)
  - [func (cl FileChangelist) Clear(archive string) error](<#func-filechangelist-clear>)
  - [func (cl FileChangelist) Close() error](<#func-filechangelist-close>)
  - [func (cl FileChangelist) List() []Change](<#func-filechangelist-list>)
  - [func (cl FileChangelist) Location() string](<#func-filechangelist-location>)
  - [func (cl FileChangelist) NewIterator() (ChangeIterator, error)](<#func-filechangelist-newiterator>)
  - [func (cl FileChangelist) Remove(idxs []int) error](<#func-filechangelist-remove>)
- [type IteratorBoundsError](<#type-iteratorboundserror>)
  - [func (e IteratorBoundsError) Error() string](<#func-iteratorboundserror-error>)
- [type MemChangeListIterator](<#type-memchangelistiterator>)
  - [func (m *MemChangeListIterator) HasNext() bool](<#func-memchangelistiterator-hasnext>)
  - [func (m *MemChangeListIterator) Next() (item Change, err error)](<#func-memchangelistiterator-next>)
- [type TUFChange](<#type-tufchange>)
  - [func NewTUFChange(action string, role data.RoleName, changeType, changePath string, content []byte) *TUFChange](<#func-newtufchange>)
  - [func (c TUFChange) Action() string](<#func-tufchange-action>)
  - [func (c TUFChange) Content() []byte](<#func-tufchange-content>)
  - [func (c TUFChange) Path() string](<#func-tufchange-path>)
  - [func (c TUFChange) Scope() data.RoleName](<#func-tufchange-scope>)
  - [func (c TUFChange) Type() string](<#func-tufchange-type>)
- [type TUFDelegation](<#type-tufdelegation>)
  - [func (td TUFDelegation) ToNewRole(scope data.RoleName) (*data.Role, error)](<#func-tufdelegation-tonewrole>)
- [type TUFRootData](<#type-tufrootdata>)


## Constants

Scopes for TUFChanges are simply the TUF roles. Unfortunately because of targets delegations, we can only cover the base roles.

```go
const (
    ScopeRoot    = "root"
    ScopeTargets = "targets"
)
```

Types for TUFChanges are namespaced by the Role they are relevant for. The Root and Targets roles are the only ones for which user action can cause a change, as all changes in Snapshot and Timestamp are programmatically generated base on Root and Targets changes.

```go
const (
    TypeBaseRole          = "role"
    TypeTargetsTarget     = "target"
    TypeTargetsDelegation = "delegation"
    TypeWitness           = "witness"
)
```

```go
const (
    // ActionCreate represents a Create action
    ActionCreate = "create"
    // ActionUpdate represents an Update action
    ActionUpdate = "update"
    // ActionDelete represents a Delete action
    ActionDelete = "delete"
)
```

## type Change

Change is the interface for a TUF Change

```go
type Change interface {
    // "create","update", or "delete"
    Action() string

    // Where the change should be made.
    // For TUF this will be the role
    Scope() data.RoleName

    // The content type being affected.
    // For TUF this will be "target", or "delegation".
    // If the type is "delegation", the Scope will be
    // used to determine if a root role is being updated
    // or a target delegation.
    Type() string

    // Path indicates the entry within a role to be affected by the
    // change. For targets, this is simply the target's path,
    // for delegations it's the delegated role name.
    Path() string

    // Serialized content that the interpreter of a changelist
    // can use to apply the change.
    // For TUF this will be the serialized JSON that needs
    // to be inserted or merged. In the case of a "delete"
    // action, it will be nil.
    Content() []byte
}
```

## type ChangeIterator

ChangeIterator is the interface for iterating across collections of TUF Change items

```go
type ChangeIterator interface {
    Next() (Change, error)
    HasNext() bool
}
```

## type Changelist

Changelist is the interface for all TUF change lists

```go
type Changelist interface {
    // List returns the ordered list of changes
    // currently stored
    List() []Change

    // Add change appends the provided change to
    // the list of changes
    Add(Change) error

    // Clear empties the current change list.
    // Archive may be provided as a directory path
    // to save a copy of the changelist in that location
    Clear(archive string) error

    // Remove deletes the changes corresponding with the indices given
    Remove(idxs []int) error

    // Close synchronizes any pending writes to the underlying
    // storage and closes the file/connection
    Close() error

    // NewIterator returns an iterator for walking through the list
    // of changes currently stored
    NewIterator() (ChangeIterator, error)

    // Location returns the place the changelist is stores
    Location() string
}
```

### func NewMemChangelist

```go
func NewMemChangelist() Changelist
```

NewMemChangelist instantiates a new in\-memory changelist

## type FileChangeListIterator

FileChangeListIterator is a concrete instance of ChangeIterator

```go
type FileChangeListIterator struct {
    // contains filtered or unexported fields
}
```

### func \(\*FileChangeListIterator\) HasNext

```go
func (m *FileChangeListIterator) HasNext() bool
```

HasNext indicates whether iterator is exhausted

### func \(\*FileChangeListIterator\) Next

```go
func (m *FileChangeListIterator) Next() (item Change, err error)
```

Next returns the next Change in the FileChangeList

## type FileChangelist

FileChangelist stores all the changes as files

```go
type FileChangelist struct {
    // contains filtered or unexported fields
}
```

### func NewFileChangelist

```go
func NewFileChangelist(dir string) (*FileChangelist, error)
```

NewFileChangelist is a convenience method for returning FileChangeLists

### func \(FileChangelist\) Add

```go
func (cl FileChangelist) Add(c Change) error
```

Add adds a change to the file change list

### func \(FileChangelist\) Clear

```go
func (cl FileChangelist) Clear(archive string) error
```

Clear clears the change list N.B. archiving not currently implemented

### func \(FileChangelist\) Close

```go
func (cl FileChangelist) Close() error
```

Close is a no\-op

### func \(FileChangelist\) List

```go
func (cl FileChangelist) List() []Change
```

List returns a list of sorted changes

### func \(FileChangelist\) Location

```go
func (cl FileChangelist) Location() string
```

Location returns the file path to the changelist

### func \(FileChangelist\) NewIterator

```go
func (cl FileChangelist) NewIterator() (ChangeIterator, error)
```

NewIterator creates an iterator from FileChangelist

### func \(FileChangelist\) Remove

```go
func (cl FileChangelist) Remove(idxs []int) error
```

Remove deletes the changes found at the given indices

## type IteratorBoundsError

IteratorBoundsError is an Error type used by Next\(\)

```go
type IteratorBoundsError int
```

### func \(IteratorBoundsError\) Error

```go
func (e IteratorBoundsError) Error() string
```

Error implements the Error interface

## type MemChangeListIterator

MemChangeListIterator is a concrete instance of ChangeIterator

```go
type MemChangeListIterator struct {
    // contains filtered or unexported fields
}
```

### func \(\*MemChangeListIterator\) HasNext

```go
func (m *MemChangeListIterator) HasNext() bool
```

HasNext indicates whether the iterator is exhausted

### func \(\*MemChangeListIterator\) Next

```go
func (m *MemChangeListIterator) Next() (item Change, err error)
```

Next returns the next Change

## type TUFChange

TUFChange represents a change to a TUF repo

```go
type TUFChange struct {
    // Abbreviated because Go doesn't permit a field and method of the same name
    Actn       string        `json:"action"`
    Role       data.RoleName `json:"role"`
    ChangeType string        `json:"type"`
    ChangePath string        `json:"path"`
    Data       []byte        `json:"data"`
}
```

### func NewTUFChange

```go
func NewTUFChange(action string, role data.RoleName, changeType, changePath string, content []byte) *TUFChange
```

NewTUFChange initializes a TUFChange object

### func \(TUFChange\) Action

```go
func (c TUFChange) Action() string
```

Action return c.Actn

### func \(TUFChange\) Content

```go
func (c TUFChange) Content() []byte
```

Content returns c.Data

### func \(TUFChange\) Path

```go
func (c TUFChange) Path() string
```

Path return c.ChangePath

### func \(TUFChange\) Scope

```go
func (c TUFChange) Scope() data.RoleName
```

Scope returns c.Role

### func \(TUFChange\) Type

```go
func (c TUFChange) Type() string
```

Type returns c.ChangeType

## type TUFDelegation

TUFDelegation represents a modification to a target delegation this includes creating a delegations. This format is used to avoid unexpected race conditions between humans modifying the same delegation

```go
type TUFDelegation struct {
    NewName       data.RoleName `json:"new_name,omitempty"`
    NewThreshold  int           `json:"threshold,omitempty"`
    AddKeys       data.KeyList  `json:"add_keys,omitempty"`
    RemoveKeys    []string      `json:"remove_keys,omitempty"`
    AddPaths      []string      `json:"add_paths,omitempty"`
    RemovePaths   []string      `json:"remove_paths,omitempty"`
    ClearAllPaths bool          `json:"clear_paths,omitempty"`
}
```

### func \(TUFDelegation\) ToNewRole

```go
func (td TUFDelegation) ToNewRole(scope data.RoleName) (*data.Role, error)
```

ToNewRole creates a fresh role object from the TUFDelegation data

## type TUFRootData

TUFRootData represents a modification of the keys associated with a role that appears in the root.json

```go
type TUFRootData struct {
    Keys     data.KeyList  `json:"keys"`
    RoleName data.RoleName `json:"role"`
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
