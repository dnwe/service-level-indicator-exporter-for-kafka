<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# tuf

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/theupdateframework/notary/tuf"
```

Package tuf defines the core TUF logic around manipulating a repo.

## Index

- [Variables](<#variables>)
- [type ConsistentInfo](<#type-consistentinfo>)
  - [func (c ConsistentInfo) ChecksumKnown() bool](<#func-consistentinfo-checksumknown>)
  - [func (c ConsistentInfo) ConsistentName() string](<#func-consistentinfo-consistentname>)
  - [func (c ConsistentInfo) Length() int64](<#func-consistentinfo-length>)
- [type ErrInvalidBuilderInput](<#type-errinvalidbuilderinput>)
  - [func (e ErrInvalidBuilderInput) Error() string](<#func-errinvalidbuilderinput-error>)
- [type ErrLocalRootExpired](<#type-errlocalrootexpired>)
  - [func (e ErrLocalRootExpired) Error() string](<#func-errlocalrootexpired-error>)
- [type ErrMetaExpired](<#type-errmetaexpired>)
  - [func (e ErrMetaExpired) Error() string](<#func-errmetaexpired-error>)
- [type ErrNotLoaded](<#type-errnotloaded>)
  - [func (err ErrNotLoaded) Error() string](<#func-errnotloaded-error>)
- [type ErrSigVerifyFail](<#type-errsigverifyfail>)
  - [func (e ErrSigVerifyFail) Error() string](<#func-errsigverifyfail-error>)
- [type Repo](<#type-repo>)
  - [func NewRepo(cryptoService signed.CryptoService) *Repo](<#func-newrepo>)
  - [func (tr *Repo) AddBaseKeys(role data.RoleName, keys ...data.PublicKey) error](<#func-repo-addbasekeys>)
  - [func (tr *Repo) AddTargets(role data.RoleName, targets data.Files) (data.Files, error)](<#func-repo-addtargets>)
  - [func (tr *Repo) DeleteDelegation(roleName data.RoleName) error](<#func-repo-deletedelegation>)
  - [func (tr *Repo) GetAllLoadedRoles() []*data.Role](<#func-repo-getallloadedroles>)
  - [func (tr *Repo) GetBaseRole(name data.RoleName) (data.BaseRole, error)](<#func-repo-getbaserole>)
  - [func (tr *Repo) GetDelegationRole(name data.RoleName) (data.DelegationRole, error)](<#func-repo-getdelegationrole>)
  - [func (tr *Repo) InitRoot(root, timestamp, snapshot, targets data.BaseRole, consistent bool) error](<#func-repo-initroot>)
  - [func (tr *Repo) InitSnapshot() error](<#func-repo-initsnapshot>)
  - [func (tr *Repo) InitTargets(role data.RoleName) (*data.SignedTargets, error)](<#func-repo-inittargets>)
  - [func (tr *Repo) InitTimestamp() error](<#func-repo-inittimestamp>)
  - [func (tr *Repo) PurgeDelegationKeys(role data.RoleName, removeKeys []string) error](<#func-repo-purgedelegationkeys>)
  - [func (tr *Repo) RemoveBaseKeys(role data.RoleName, keyIDs ...string) error](<#func-repo-removebasekeys>)
  - [func (tr *Repo) RemoveTargets(role data.RoleName, targets ...string) error](<#func-repo-removetargets>)
  - [func (tr *Repo) ReplaceBaseKeys(role data.RoleName, keys ...data.PublicKey) error](<#func-repo-replacebasekeys>)
  - [func (tr *Repo) SignRoot(expires time.Time, extraSigningKeys data.KeyList) (*data.Signed, error)](<#func-repo-signroot>)
  - [func (tr *Repo) SignSnapshot(expires time.Time) (*data.Signed, error)](<#func-repo-signsnapshot>)
  - [func (tr *Repo) SignTargets(role data.RoleName, expires time.Time) (*data.Signed, error)](<#func-repo-signtargets>)
  - [func (tr *Repo) SignTimestamp(expires time.Time) (*data.Signed, error)](<#func-repo-signtimestamp>)
  - [func (tr Repo) TargetDelegations(role data.RoleName, path string) []*data.Role](<#func-repo-targetdelegations>)
  - [func (tr Repo) TargetMeta(role data.RoleName, path string) *data.FileMeta](<#func-repo-targetmeta>)
  - [func (tr *Repo) UpdateDelegationKeys(roleName data.RoleName, addKeys data.KeyList, removeKeys []string, newThreshold int) error](<#func-repo-updatedelegationkeys>)
  - [func (tr *Repo) UpdateDelegationPaths(roleName data.RoleName, addPaths, removePaths []string, clearPaths bool) error](<#func-repo-updatedelegationpaths>)
  - [func (tr *Repo) UpdateSnapshot(role data.RoleName, s *data.Signed) error](<#func-repo-updatesnapshot>)
  - [func (tr *Repo) UpdateTimestamp(s *data.Signed) error](<#func-repo-updatetimestamp>)
  - [func (tr *Repo) VerifyCanSign(roleName data.RoleName) error](<#func-repo-verifycansign>)
  - [func (tr *Repo) WalkTargets(targetPath string, rolePath data.RoleName, visitTargets walkVisitorFunc, skipRoles ...data.RoleName) error](<#func-repo-walktargets>)
- [type RepoBuilder](<#type-repobuilder>)
  - [func NewBuilderFromRepo(gun data.GUN, repo *Repo, trustpin trustpinning.TrustPinConfig) RepoBuilder](<#func-newbuilderfromrepo>)
  - [func NewRepoBuilder(gun data.GUN, cs signed.CryptoService, trustpin trustpinning.TrustPinConfig) RepoBuilder](<#func-newrepobuilder>)
- [type StopWalk](<#type-stopwalk>)


## Variables

ErrBuildDone is returned when any functions are called on RepoBuilder, and it is already finished building

```go
var ErrBuildDone = fmt.Errorf(
    "the builder has finished building and cannot accept any more input or produce any more output")
```

## type ConsistentInfo

ConsistentInfo is the consistent name and size of a role, or just the name of the role and a \-1 if no file metadata for the role is known

```go
type ConsistentInfo struct {
    RoleName data.RoleName
    // contains filtered or unexported fields
}
```

### func \(ConsistentInfo\) ChecksumKnown

```go
func (c ConsistentInfo) ChecksumKnown() bool
```

ChecksumKnown determines whether or not we know enough to provide a size and consistent name

### func \(ConsistentInfo\) ConsistentName

```go
func (c ConsistentInfo) ConsistentName() string
```

ConsistentName returns the consistent name \(rolename.sha256\) for the role given this consistent information

### func \(ConsistentInfo\) Length

```go
func (c ConsistentInfo) Length() int64
```

Length returns the expected length of the role as per this consistent information \- if no checksum information is known, the size is \-1.

## type ErrInvalidBuilderInput

ErrInvalidBuilderInput is returned when RepoBuilder.Load is called with the wrong type of metadata for the state that it's in

```go
type ErrInvalidBuilderInput struct {
    // contains filtered or unexported fields
}
```

### func \(ErrInvalidBuilderInput\) Error

```go
func (e ErrInvalidBuilderInput) Error() string
```

## type ErrLocalRootExpired

ErrLocalRootExpired \- the local root file is out of date

```go
type ErrLocalRootExpired struct{}
```

### func \(ErrLocalRootExpired\) Error

```go
func (e ErrLocalRootExpired) Error() string
```

## type ErrMetaExpired

ErrMetaExpired \- metadata file has expired

```go
type ErrMetaExpired struct{}
```

### func \(ErrMetaExpired\) Error

```go
func (e ErrMetaExpired) Error() string
```

## type ErrNotLoaded

ErrNotLoaded \- attempted to access data that has not been loaded into the repo. This means specifically that the relevant JSON file has not been loaded.

```go
type ErrNotLoaded struct {
    Role data.RoleName
}
```

### func \(ErrNotLoaded\) Error

```go
func (err ErrNotLoaded) Error() string
```

## type ErrSigVerifyFail

ErrSigVerifyFail \- signature verification failed

```go
type ErrSigVerifyFail struct{}
```

### func \(ErrSigVerifyFail\) Error

```go
func (e ErrSigVerifyFail) Error() string
```

## type Repo

Repo is an in memory representation of the TUF Repo. It operates at the data.Signed level, accepting and producing data.Signed objects. Users of a Repo are responsible for fetching raw JSON and using the Set\* functions to populate the Repo instance.

```go
type Repo struct {
    Root      *data.SignedRoot
    Targets   map[data.RoleName]*data.SignedTargets
    Snapshot  *data.SignedSnapshot
    Timestamp *data.SignedTimestamp
    // contains filtered or unexported fields
}
```

### func NewRepo

```go
func NewRepo(cryptoService signed.CryptoService) *Repo
```

NewRepo initializes a Repo instance with a CryptoService. If the Repo will only be used for reading, the CryptoService can be nil.

### func \(\*Repo\) AddBaseKeys

```go
func (tr *Repo) AddBaseKeys(role data.RoleName, keys ...data.PublicKey) error
```

AddBaseKeys is used to add keys to the role in root.json

### func \(\*Repo\) AddTargets

```go
func (tr *Repo) AddTargets(role data.RoleName, targets data.Files) (data.Files, error)
```

AddTargets will attempt to add the given targets specifically to the directed role. If the metadata for the role doesn't exist yet, AddTargets will create one.

### func \(\*Repo\) DeleteDelegation

```go
func (tr *Repo) DeleteDelegation(roleName data.RoleName) error
```

DeleteDelegation removes a delegated targets role from its parent targets object. It also deletes the delegation from the snapshot. DeleteDelegation will only make use of the role Name field.

### func \(\*Repo\) GetAllLoadedRoles

```go
func (tr *Repo) GetAllLoadedRoles() []*data.Role
```

GetAllLoadedRoles returns a list of all role entries loaded in this TUF repo, could be empty

### func \(\*Repo\) GetBaseRole

```go
func (tr *Repo) GetBaseRole(name data.RoleName) (data.BaseRole, error)
```

GetBaseRole gets a base role from this repo's metadata

### func \(\*Repo\) GetDelegationRole

```go
func (tr *Repo) GetDelegationRole(name data.RoleName) (data.DelegationRole, error)
```

GetDelegationRole gets a delegation role from this repo's metadata, walking from the targets role down to the delegation itself

### func \(\*Repo\) InitRoot

```go
func (tr *Repo) InitRoot(root, timestamp, snapshot, targets data.BaseRole, consistent bool) error
```

InitRoot initializes an empty root file with the 4 core roles passed to the method, and the consistent flag.

### func \(\*Repo\) InitSnapshot

```go
func (tr *Repo) InitSnapshot() error
```

InitSnapshot initializes a snapshot based on the current root and targets

### func \(\*Repo\) InitTargets

```go
func (tr *Repo) InitTargets(role data.RoleName) (*data.SignedTargets, error)
```

InitTargets initializes an empty targets, and returns the new empty target

### func \(\*Repo\) InitTimestamp

```go
func (tr *Repo) InitTimestamp() error
```

InitTimestamp initializes a timestamp based on the current snapshot

### func \(\*Repo\) PurgeDelegationKeys

```go
func (tr *Repo) PurgeDelegationKeys(role data.RoleName, removeKeys []string) error
```

PurgeDelegationKeys removes the provided canonical key IDs from all delegations present in the subtree rooted at role. The role argument must be provided in a wildcard format, i.e. targets/\* would remove the key from all delegations in the repo

### func \(\*Repo\) RemoveBaseKeys

```go
func (tr *Repo) RemoveBaseKeys(role data.RoleName, keyIDs ...string) error
```

RemoveBaseKeys is used to remove keys from the roles in root.json

### func \(\*Repo\) RemoveTargets

```go
func (tr *Repo) RemoveTargets(role data.RoleName, targets ...string) error
```

RemoveTargets removes the given target \(paths\) from the given target role \(delegation\)

### func \(\*Repo\) ReplaceBaseKeys

```go
func (tr *Repo) ReplaceBaseKeys(role data.RoleName, keys ...data.PublicKey) error
```

ReplaceBaseKeys is used to replace all keys for the given role with the new keys

### func \(\*Repo\) SignRoot

```go
func (tr *Repo) SignRoot(expires time.Time, extraSigningKeys data.KeyList) (*data.Signed, error)
```

SignRoot signs the root, using all keys from the "root" role \(i.e. currently trusted\) as well as available keys used to sign the previous version, if the public part is carried in tr.Root.Keys and the private key is available \(i.e. probably previously trusted keys, to allow rollover\).  If there are any errors, attempt to put root back to the way it was \(so version won't be incremented, for instance\). Extra signing keys can be added to support older clients

### func \(\*Repo\) SignSnapshot

```go
func (tr *Repo) SignSnapshot(expires time.Time) (*data.Signed, error)
```

SignSnapshot updates the snapshot based on the current targets and root then signs it

### func \(\*Repo\) SignTargets

```go
func (tr *Repo) SignTargets(role data.RoleName, expires time.Time) (*data.Signed, error)
```

SignTargets signs the targets file for the given top level or delegated targets role

### func \(\*Repo\) SignTimestamp

```go
func (tr *Repo) SignTimestamp(expires time.Time) (*data.Signed, error)
```

SignTimestamp updates the timestamp based on the current snapshot then signs it

### func \(Repo\) TargetDelegations

```go
func (tr Repo) TargetDelegations(role data.RoleName, path string) []*data.Role
```

TargetDelegations returns a slice of Roles that are valid publishers for the target path provided.

### func \(Repo\) TargetMeta

```go
func (tr Repo) TargetMeta(role data.RoleName, path string) *data.FileMeta
```

TargetMeta returns the FileMeta entry for the given path in the targets file associated with the given role. This may be nil if the target isn't found in the targets file.

### func \(\*Repo\) UpdateDelegationKeys

```go
func (tr *Repo) UpdateDelegationKeys(roleName data.RoleName, addKeys data.KeyList, removeKeys []string, newThreshold int) error
```

UpdateDelegationKeys updates the appropriate delegations, either adding a new delegation or updating an existing one. If keys are provided, the IDs will be added to the role \(if they do not exist there already\), and the keys will be added to the targets file.

### func \(\*Repo\) UpdateDelegationPaths

```go
func (tr *Repo) UpdateDelegationPaths(roleName data.RoleName, addPaths, removePaths []string, clearPaths bool) error
```

UpdateDelegationPaths updates the appropriate delegation's paths. It is not allowed to create a new delegation.

### func \(\*Repo\) UpdateSnapshot

```go
func (tr *Repo) UpdateSnapshot(role data.RoleName, s *data.Signed) error
```

UpdateSnapshot updates the FileMeta for the given role based on the Signed object

### func \(\*Repo\) UpdateTimestamp

```go
func (tr *Repo) UpdateTimestamp(s *data.Signed) error
```

UpdateTimestamp updates the snapshot meta in the timestamp based on the Signed object

### func \(\*Repo\) VerifyCanSign

```go
func (tr *Repo) VerifyCanSign(roleName data.RoleName) error
```

VerifyCanSign returns nil if the role exists and we have at least one signing key for the role, false otherwise.  This does not check that we have enough signing keys to meet the threshold, since we want to support the use case of multiple signers for a role.  It returns an error if the role doesn't exist or if there are no signing keys.

### func \(\*Repo\) WalkTargets

```go
func (tr *Repo) WalkTargets(targetPath string, rolePath data.RoleName, visitTargets walkVisitorFunc, skipRoles ...data.RoleName) error
```

WalkTargets will apply the specified visitor function to iteratively walk the targets/delegation metadata tree, until receiving a StopWalk.  The walk starts from the base "targets" role, and searches for the correct targetPath and/or rolePath to call the visitor function on.  Any roles passed into skipRoles will be excluded from the walk, as well as roles in those subtrees

## type RepoBuilder

RepoBuilder is an interface for an object which builds a tuf.Repo

```go
type RepoBuilder interface {
    Load(roleName data.RoleName, content []byte, minVersion int, allowExpired bool) error
    LoadRootForUpdate(content []byte, minVersion int, isFinal bool) error
    GenerateSnapshot(prev *data.SignedSnapshot) ([]byte, int, error)
    GenerateTimestamp(prev *data.SignedTimestamp) ([]byte, int, error)
    Finish() (*Repo, *Repo, error)
    BootstrapNewBuilder() RepoBuilder
    BootstrapNewBuilderWithNewTrustpin(trustpin trustpinning.TrustPinConfig) RepoBuilder

    // informative functions
    IsLoaded(roleName data.RoleName) bool
    GetLoadedVersion(roleName data.RoleName) int
    GetConsistentInfo(roleName data.RoleName) ConsistentInfo
}
```

### func NewBuilderFromRepo

```go
func NewBuilderFromRepo(gun data.GUN, repo *Repo, trustpin trustpinning.TrustPinConfig) RepoBuilder
```

NewBuilderFromRepo allows us to bootstrap a builder given existing repo data. YOU PROBABLY SHOULDN'T BE USING THIS OUTSIDE OF TESTING CODE\!\!\!

### func NewRepoBuilder

```go
func NewRepoBuilder(gun data.GUN, cs signed.CryptoService, trustpin trustpinning.TrustPinConfig) RepoBuilder
```

NewRepoBuilder is the only way to get a pre\-built RepoBuilder

## type StopWalk

StopWalk \- used by visitor functions to signal WalkTargets to stop walking

```go
type StopWalk struct{}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
