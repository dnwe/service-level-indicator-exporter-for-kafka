<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# signed

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/theupdateframework/notary/tuf/signed"
```

## Index

- [Variables](<#variables>)
- [func IsExpired(t time.Time) bool](<#func-isexpired>)
- [func Sign(service CryptoService, s *data.Signed, signingKeys []data.PublicKey, minSignatures int, otherWhitelistedKeys []data.PublicKey) error](<#func-sign>)
- [func VerifyExpiry(s *data.SignedCommon, role data.RoleName) error](<#func-verifyexpiry>)
- [func VerifyPublicKeyMatchesPrivateKey(privKey data.PrivateKey, pubKey data.PublicKey) error](<#func-verifypublickeymatchesprivatekey>)
- [func VerifySignature(msg []byte, sig *data.Signature, pk data.PublicKey) error](<#func-verifysignature>)
- [func VerifySignatures(s *data.Signed, roleData data.BaseRole) error](<#func-verifysignatures>)
- [func VerifyVersion(s *data.SignedCommon, minVersion int) error](<#func-verifyversion>)
- [type CryptoService](<#type-cryptoservice>)
- [type ECDSAVerifier](<#type-ecdsaverifier>)
  - [func (v ECDSAVerifier) Verify(key data.PublicKey, sig []byte, msg []byte) error](<#func-ecdsaverifier-verify>)
- [type Ed25519](<#type-ed25519>)
  - [func NewEd25519() *Ed25519](<#func-newed25519>)
  - [func (e *Ed25519) AddKey(role data.RoleName, gun data.GUN, k data.PrivateKey) error](<#func-ed25519-addkey>)
  - [func (e *Ed25519) Create(role data.RoleName, gun data.GUN, algorithm string) (data.PublicKey, error)](<#func-ed25519-create>)
  - [func (e *Ed25519) GetKey(keyID string) data.PublicKey](<#func-ed25519-getkey>)
  - [func (e *Ed25519) GetPrivateKey(keyID string) (data.PrivateKey, data.RoleName, error)](<#func-ed25519-getprivatekey>)
  - [func (e *Ed25519) ListAllKeys() map[string]data.RoleName](<#func-ed25519-listallkeys>)
  - [func (e *Ed25519) ListKeys(role data.RoleName) []string](<#func-ed25519-listkeys>)
  - [func (e *Ed25519) PublicKeys(keyIDs ...string) (map[string]data.PublicKey, error)](<#func-ed25519-publickeys>)
  - [func (e *Ed25519) RemoveKey(keyID string) error](<#func-ed25519-removekey>)
- [type Ed25519Verifier](<#type-ed25519verifier>)
  - [func (v Ed25519Verifier) Verify(key data.PublicKey, sig []byte, msg []byte) error](<#func-ed25519verifier-verify>)
- [type ErrExpired](<#type-errexpired>)
  - [func (e ErrExpired) Error() string](<#func-errexpired-error>)
- [type ErrInsufficientSignatures](<#type-errinsufficientsignatures>)
  - [func (e ErrInsufficientSignatures) Error() string](<#func-errinsufficientsignatures-error>)
- [type ErrInvalidKeyID](<#type-errinvalidkeyid>)
  - [func (e ErrInvalidKeyID) Error() string](<#func-errinvalidkeyid-error>)
- [type ErrInvalidKeyLength](<#type-errinvalidkeylength>)
  - [func (e ErrInvalidKeyLength) Error() string](<#func-errinvalidkeylength-error>)
- [type ErrInvalidKeyType](<#type-errinvalidkeytype>)
  - [func (e ErrInvalidKeyType) Error() string](<#func-errinvalidkeytype-error>)
- [type ErrLowVersion](<#type-errlowversion>)
  - [func (e ErrLowVersion) Error() string](<#func-errlowversion-error>)
- [type ErrNoKeys](<#type-errnokeys>)
  - [func (e ErrNoKeys) Error() string](<#func-errnokeys-error>)
- [type ErrRoleThreshold](<#type-errrolethreshold>)
  - [func (e ErrRoleThreshold) Error() string](<#func-errrolethreshold-error>)
- [type KeyService](<#type-keyservice>)
- [type RSAPKCS1v15Verifier](<#type-rsapkcs1v15verifier>)
  - [func (v RSAPKCS1v15Verifier) Verify(key data.PublicKey, sig []byte, msg []byte) error](<#func-rsapkcs1v15verifier-verify>)
- [type RSAPSSVerifier](<#type-rsapssverifier>)
  - [func (v RSAPSSVerifier) Verify(key data.PublicKey, sig []byte, msg []byte) error](<#func-rsapssverifier-verify>)
- [type RSAPyCryptoVerifier](<#type-rsapycryptoverifier>)
  - [func (v RSAPyCryptoVerifier) Verify(key data.PublicKey, sig []byte, msg []byte) error](<#func-rsapycryptoverifier-verify>)
- [type Verifier](<#type-verifier>)


## Variables

Various basic signing errors

```go
var (
    ErrNoSignatures = errors.New("tuf: data has no signatures")
    ErrInvalid      = errors.New("tuf: signature verification failed")
    ErrWrongType    = errors.New("tuf: meta file has wrong type")
)
```

Verifiers serves as a map of all verifiers available on the system and can be injected into a verificationService. For testing and configuration purposes, it will not be used by default.

```go
var Verifiers = map[data.SigAlgorithm]Verifier{
    data.RSAPSSSignature:      RSAPSSVerifier{},
    data.RSAPKCS1v15Signature: RSAPKCS1v15Verifier{},
    data.PyCryptoSignature:    RSAPyCryptoVerifier{},
    data.ECDSASignature:       ECDSAVerifier{},
    data.EDDSASignature:       Ed25519Verifier{},
}
```

## func IsExpired

```go
func IsExpired(t time.Time) bool
```

IsExpired checks if the given time passed before the present time

## func Sign

```go
func Sign(service CryptoService, s *data.Signed, signingKeys []data.PublicKey, minSignatures int, otherWhitelistedKeys []data.PublicKey) error
```

Sign takes a data.Signed and a cryptoservice containing private keys, calculates and adds at least minSignature signatures using signingKeys the data.Signed.  It will also clean up any signatures that are not in produced by either a signingKey or an otherWhitelistedKey. Note that in most cases, otherWhitelistedKeys should probably be null. They are for keys you don't want to sign with, but you also don't want to remove existing signatures by those keys.  For instance, if you want to call Sign multiple times with different sets of signing keys without undoing removing signatures produced by the previous call to Sign.

## func VerifyExpiry

```go
func VerifyExpiry(s *data.SignedCommon, role data.RoleName) error
```

VerifyExpiry returns ErrExpired if the metadata is expired

## func VerifyPublicKeyMatchesPrivateKey

```go
func VerifyPublicKeyMatchesPrivateKey(privKey data.PrivateKey, pubKey data.PublicKey) error
```

VerifyPublicKeyMatchesPrivateKey checks if the private key and the public keys forms valid key pairs. Supports both x509 certificate PublicKeys and non\-certificate PublicKeys

## func VerifySignature

```go
func VerifySignature(msg []byte, sig *data.Signature, pk data.PublicKey) error
```

VerifySignature checks a single signature and public key against a payload If the signature is verified, the signature's is valid field will actually be mutated to be equal to the boolean true

## func VerifySignatures

```go
func VerifySignatures(s *data.Signed, roleData data.BaseRole) error
```

VerifySignatures checks the we have sufficient valid signatures for the given role

## func VerifyVersion

```go
func VerifyVersion(s *data.SignedCommon, minVersion int) error
```

VerifyVersion returns ErrLowVersion if the metadata version is lower than the min version

## type CryptoService

CryptoService is deprecated and all instances of its use should be replaced with KeyService

```go
type CryptoService interface {
    KeyService
}
```

## type ECDSAVerifier

ECDSAVerifier checks ECDSA signatures, decoding the keyType appropriately

```go
type ECDSAVerifier struct{}
```

### func \(ECDSAVerifier\) Verify

```go
func (v ECDSAVerifier) Verify(key data.PublicKey, sig []byte, msg []byte) error
```

Verify does the actual check.

## type Ed25519

Ed25519 implements a simple in memory cryptosystem for ED25519 keys

```go
type Ed25519 struct {
    // contains filtered or unexported fields
}
```

### func NewEd25519

```go
func NewEd25519() *Ed25519
```

NewEd25519 initializes a new empty Ed25519 CryptoService that operates entirely in memory

### func \(\*Ed25519\) AddKey

```go
func (e *Ed25519) AddKey(role data.RoleName, gun data.GUN, k data.PrivateKey) error
```

AddKey allows you to add a private key

### func \(\*Ed25519\) Create

```go
func (e *Ed25519) Create(role data.RoleName, gun data.GUN, algorithm string) (data.PublicKey, error)
```

Create generates a new key and returns the public part

### func \(\*Ed25519\) GetKey

```go
func (e *Ed25519) GetKey(keyID string) data.PublicKey
```

GetKey returns a single public key based on the ID

### func \(\*Ed25519\) GetPrivateKey

```go
func (e *Ed25519) GetPrivateKey(keyID string) (data.PrivateKey, data.RoleName, error)
```

GetPrivateKey returns a single private key and role if present, based on the ID

### func \(\*Ed25519\) ListAllKeys

```go
func (e *Ed25519) ListAllKeys() map[string]data.RoleName
```

ListAllKeys returns the map of keys IDs to role

### func \(\*Ed25519\) ListKeys

```go
func (e *Ed25519) ListKeys(role data.RoleName) []string
```

ListKeys returns the list of keys IDs for the role

### func \(\*Ed25519\) PublicKeys

```go
func (e *Ed25519) PublicKeys(keyIDs ...string) (map[string]data.PublicKey, error)
```

PublicKeys returns a map of public keys for the ids provided, when those IDs are found in the store.

### func \(\*Ed25519\) RemoveKey

```go
func (e *Ed25519) RemoveKey(keyID string) error
```

RemoveKey deletes a key from the signer

## type Ed25519Verifier

Ed25519Verifier used to verify Ed25519 signatures

```go
type Ed25519Verifier struct{}
```

### func \(Ed25519Verifier\) Verify

```go
func (v Ed25519Verifier) Verify(key data.PublicKey, sig []byte, msg []byte) error
```

Verify checks that an ed25519 signature is valid

## type ErrExpired

ErrExpired indicates a piece of metadata has expired

```go
type ErrExpired struct {
    Role    data.RoleName
    Expired string
}
```

### func \(ErrExpired\) Error

```go
func (e ErrExpired) Error() string
```

## type ErrInsufficientSignatures

ErrInsufficientSignatures \- can not create enough signatures on a piece of metadata

```go
type ErrInsufficientSignatures struct {
    FoundKeys     int
    NeededKeys    int
    MissingKeyIDs []string
}
```

### func \(ErrInsufficientSignatures\) Error

```go
func (e ErrInsufficientSignatures) Error() string
```

## type ErrInvalidKeyID

ErrInvalidKeyID indicates the specified key ID was incorrect for its associated data

```go
type ErrInvalidKeyID struct{}
```

### func \(ErrInvalidKeyID\) Error

```go
func (e ErrInvalidKeyID) Error() string
```

## type ErrInvalidKeyLength

ErrInvalidKeyLength indicates that while we may support the cipher, the provided key length is not specifically supported, i.e. we support RSA, but not 1024 bit keys

```go
type ErrInvalidKeyLength struct {
    // contains filtered or unexported fields
}
```

### func \(ErrInvalidKeyLength\) Error

```go
func (e ErrInvalidKeyLength) Error() string
```

## type ErrInvalidKeyType

ErrInvalidKeyType indicates the types for the key and signature it's associated with are mismatched. Probably a sign of malicious behaviour

```go
type ErrInvalidKeyType struct{}
```

### func \(ErrInvalidKeyType\) Error

```go
func (e ErrInvalidKeyType) Error() string
```

## type ErrLowVersion

ErrLowVersion indicates the piece of metadata has a version number lower than a version number we're already seen for this role

```go
type ErrLowVersion struct {
    Actual  int
    Current int
}
```

### func \(ErrLowVersion\) Error

```go
func (e ErrLowVersion) Error() string
```

## type ErrNoKeys

ErrNoKeys indicates no signing keys were found when trying to sign

```go
type ErrNoKeys struct {
    KeyIDs []string
}
```

### func \(ErrNoKeys\) Error

```go
func (e ErrNoKeys) Error() string
```

## type ErrRoleThreshold

ErrRoleThreshold indicates we did not validate enough signatures to meet the threshold

```go
type ErrRoleThreshold struct {
    Msg string
}
```

### func \(ErrRoleThreshold\) Error

```go
func (e ErrRoleThreshold) Error() string
```

## type KeyService

KeyService provides management of keys locally. It will never accept or provide private keys. Communication between the KeyService and a SigningService happen behind the Create function.

```go
type KeyService interface {
    // Create issues a new key pair and is responsible for loading
    // the private key into the appropriate signing service.
    Create(role data.RoleName, gun data.GUN, algorithm string) (data.PublicKey, error)

    // AddKey adds a private key to the specified role and gun
    AddKey(role data.RoleName, gun data.GUN, key data.PrivateKey) error

    // GetKey retrieves the public key if present, otherwise it returns nil
    GetKey(keyID string) data.PublicKey

    // GetPrivateKey retrieves the private key and role if present and retrievable,
    // otherwise it returns nil and an error
    GetPrivateKey(keyID string) (data.PrivateKey, data.RoleName, error)

    // RemoveKey deletes the specified key, and returns an error only if the key
    // removal fails. If the key doesn't exist, no error should be returned.
    RemoveKey(keyID string) error

    // ListKeys returns a list of key IDs for the role, or an empty list or
    // nil if there are no keys.
    ListKeys(role data.RoleName) []string

    // ListAllKeys returns a map of all available signing key IDs to role, or
    // an empty map or nil if there are no keys.
    ListAllKeys() map[string]data.RoleName
}
```

## type RSAPKCS1v15Verifier

RSAPKCS1v15Verifier checks RSA PKCS1v15 signatures

```go
type RSAPKCS1v15Verifier struct{}
```

### func \(RSAPKCS1v15Verifier\) Verify

```go
func (v RSAPKCS1v15Verifier) Verify(key data.PublicKey, sig []byte, msg []byte) error
```

Verify does the actual verification

## type RSAPSSVerifier

RSAPSSVerifier checks RSASSA\-PSS signatures

```go
type RSAPSSVerifier struct{}
```

### func \(RSAPSSVerifier\) Verify

```go
func (v RSAPSSVerifier) Verify(key data.PublicKey, sig []byte, msg []byte) error
```

Verify does the actual check.

## type RSAPyCryptoVerifier

RSAPyCryptoVerifier checks RSASSA\-PSS signatures

```go
type RSAPyCryptoVerifier struct{}
```

### func \(RSAPyCryptoVerifier\) Verify

```go
func (v RSAPyCryptoVerifier) Verify(key data.PublicKey, sig []byte, msg []byte) error
```

Verify does the actual check. N.B. We have not been able to make this work in a way that is compatible with PyCrypto.

## type Verifier

Verifier defines an interface for verifying signatures. An implementer of this interface should verify signatures for one and only one signing scheme.

```go
type Verifier interface {
    Verify(key data.PublicKey, sig []byte, msg []byte) error
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
