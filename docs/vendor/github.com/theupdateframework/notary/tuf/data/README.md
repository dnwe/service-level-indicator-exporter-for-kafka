<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# data

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/theupdateframework/notary/tuf/data"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func CheckHashes(payload []byte, name string, hashes Hashes) error](<#func-checkhashes>)
- [func CheckValidHashStructures(hashes Hashes) error](<#func-checkvalidhashstructures>)
- [func CompareMultiHashes(hashes1, hashes2 Hashes) error](<#func-comparemultihashes>)
- [func DefaultExpires(role RoleName) time.Time](<#func-defaultexpires>)
- [func IsBaseRole(role RoleName) bool](<#func-isbaserole>)
- [func IsDelegation(role RoleName) bool](<#func-isdelegation>)
- [func IsValidSnapshotStructure(s Snapshot) error](<#func-isvalidsnapshotstructure>)
- [func IsValidTimestampStructure(t Timestamp) error](<#func-isvalidtimestampstructure>)
- [func IsWildDelegation(role RoleName) bool](<#func-iswilddelegation>)
- [func MetadataRoleMapToStringMap(roles map[RoleName][]byte) map[string][]byte](<#func-metadatarolemaptostringmap>)
- [func RestrictDelegationPathPrefixes(parentPaths, delegationPaths []string) []string](<#func-restrictdelegationpathprefixes>)
- [func RolesListToStringList(roles []RoleName) []string](<#func-roleslisttostringlist>)
- [func SetDefaultExpiryTimes(times map[RoleName]time.Duration)](<#func-setdefaultexpirytimes>)
- [func ValidRole(name RoleName) bool](<#func-validrole>)
- [func ValidTUFType(typ string, role RoleName) bool](<#func-validtuftype>)
- [type BaseRole](<#type-baserole>)
  - [func NewBaseRole(name RoleName, threshold int, keys ...PublicKey) BaseRole](<#func-newbaserole>)
  - [func (b BaseRole) Equals(o BaseRole) bool](<#func-baserole-equals>)
  - [func (b BaseRole) ListKeyIDs() []string](<#func-baserole-listkeyids>)
  - [func (b BaseRole) ListKeys() KeyList](<#func-baserole-listkeys>)
- [type DelegationRole](<#type-delegationrole>)
  - [func (d DelegationRole) CheckPaths(path string) bool](<#func-delegationrole-checkpaths>)
  - [func (d DelegationRole) IsParentOf(child DelegationRole) bool](<#func-delegationrole-isparentof>)
  - [func (d DelegationRole) Restrict(child DelegationRole) (DelegationRole, error)](<#func-delegationrole-restrict>)
- [type Delegations](<#type-delegations>)
  - [func NewDelegations() *Delegations](<#func-newdelegations>)
- [type ECDSAPrivateKey](<#type-ecdsaprivatekey>)
  - [func NewECDSAPrivateKey(public PublicKey, private []byte) (*ECDSAPrivateKey, error)](<#func-newecdsaprivatekey>)
  - [func (k ECDSAPrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)](<#func-ecdsaprivatekey-sign>)
  - [func (k ECDSAPrivateKey) SignatureAlgorithm() SigAlgorithm](<#func-ecdsaprivatekey-signaturealgorithm>)
- [type ECDSAPublicKey](<#type-ecdsapublickey>)
  - [func NewECDSAPublicKey(public []byte) *ECDSAPublicKey](<#func-newecdsapublickey>)
- [type ECDSAx509PublicKey](<#type-ecdsax509publickey>)
  - [func NewECDSAx509PublicKey(public []byte) *ECDSAx509PublicKey](<#func-newecdsax509publickey>)
- [type ED25519PrivateKey](<#type-ed25519privatekey>)
  - [func NewED25519PrivateKey(public ED25519PublicKey, private []byte) (*ED25519PrivateKey, error)](<#func-newed25519privatekey>)
  - [func (k ED25519PrivateKey) CryptoSigner() crypto.Signer](<#func-ed25519privatekey-cryptosigner>)
  - [func (k ED25519PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)](<#func-ed25519privatekey-sign>)
  - [func (k ED25519PrivateKey) SignatureAlgorithm() SigAlgorithm](<#func-ed25519privatekey-signaturealgorithm>)
- [type ED25519PublicKey](<#type-ed25519publickey>)
  - [func NewED25519PublicKey(public []byte) *ED25519PublicKey](<#func-newed25519publickey>)
- [type ErrCertExpired](<#type-errcertexpired>)
  - [func (e ErrCertExpired) Error() string](<#func-errcertexpired-error>)
- [type ErrInvalidChecksum](<#type-errinvalidchecksum>)
  - [func (e ErrInvalidChecksum) Error() string](<#func-errinvalidchecksum-error>)
- [type ErrInvalidMetadata](<#type-errinvalidmetadata>)
  - [func (e ErrInvalidMetadata) Error() string](<#func-errinvalidmetadata-error>)
- [type ErrInvalidRole](<#type-errinvalidrole>)
  - [func (e ErrInvalidRole) Error() string](<#func-errinvalidrole-error>)
- [type ErrMismatchedChecksum](<#type-errmismatchedchecksum>)
  - [func (e ErrMismatchedChecksum) Error() string](<#func-errmismatchedchecksum-error>)
- [type ErrMissingMeta](<#type-errmissingmeta>)
  - [func (e ErrMissingMeta) Error() string](<#func-errmissingmeta-error>)
- [type ErrNoSuchRole](<#type-errnosuchrole>)
  - [func (e ErrNoSuchRole) Error() string](<#func-errnosuchrole-error>)
- [type FileMeta](<#type-filemeta>)
  - [func NewFileMeta(r io.Reader, hashAlgorithms ...string) (FileMeta, error)](<#func-newfilemeta>)
  - [func (f FileMeta) Equals(o FileMeta) bool](<#func-filemeta-equals>)
- [type Files](<#type-files>)
- [type GUN](<#type-gun>)
  - [func (g GUN) String() string](<#func-gun-string>)
- [type Hashes](<#type-hashes>)
- [type KeyList](<#type-keylist>)
  - [func (ks KeyList) IDs() []string](<#func-keylist-ids>)
  - [func (ks *KeyList) UnmarshalJSON(data []byte) error](<#func-keylist-unmarshaljson>)
- [type KeyPair](<#type-keypair>)
- [type Keys](<#type-keys>)
  - [func (ks *Keys) UnmarshalJSON(data []byte) error](<#func-keys-unmarshaljson>)
- [type PrivateKey](<#type-privatekey>)
  - [func NewPrivateKey(pubKey PublicKey, private []byte) (PrivateKey, error)](<#func-newprivatekey>)
  - [func UnmarshalPrivateKey(data []byte) (PrivateKey, error)](<#func-unmarshalprivatekey>)
- [type PublicKey](<#type-publickey>)
  - [func NewPublicKey(alg string, public []byte) PublicKey](<#func-newpublickey>)
  - [func PublicKeyFromPrivate(pk PrivateKey) PublicKey](<#func-publickeyfromprivate>)
  - [func UnmarshalPublicKey(data []byte) (PublicKey, error)](<#func-unmarshalpublickey>)
- [type RSAPrivateKey](<#type-rsaprivatekey>)
  - [func NewRSAPrivateKey(public PublicKey, private []byte) (*RSAPrivateKey, error)](<#func-newrsaprivatekey>)
  - [func (k RSAPrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)](<#func-rsaprivatekey-sign>)
  - [func (k RSAPrivateKey) SignatureAlgorithm() SigAlgorithm](<#func-rsaprivatekey-signaturealgorithm>)
- [type RSAPublicKey](<#type-rsapublickey>)
  - [func NewRSAPublicKey(public []byte) *RSAPublicKey](<#func-newrsapublickey>)
- [type RSAx509PublicKey](<#type-rsax509publickey>)
  - [func NewRSAx509PublicKey(public []byte) *RSAx509PublicKey](<#func-newrsax509publickey>)
- [type Role](<#type-role>)
  - [func NewRole(name RoleName, threshold int, keyIDs, paths []string) (*Role, error)](<#func-newrole>)
  - [func (r *Role) AddKeys(ids []string)](<#func-role-addkeys>)
  - [func (r *Role) AddPaths(paths []string) error](<#func-role-addpaths>)
  - [func (r Role) CheckPaths(path string) bool](<#func-role-checkpaths>)
  - [func (r *Role) RemoveKeys(ids []string)](<#func-role-removekeys>)
  - [func (r *Role) RemovePaths(paths []string)](<#func-role-removepaths>)
- [type RoleName](<#type-rolename>)
  - [func NewRoleList(roles []string) []RoleName](<#func-newrolelist>)
  - [func (r RoleName) Parent() RoleName](<#func-rolename-parent>)
  - [func (r RoleName) String() string](<#func-rolename-string>)
- [type Root](<#type-root>)
- [type RootRole](<#type-rootrole>)
- [type SigAlgorithm](<#type-sigalgorithm>)
  - [func (k SigAlgorithm) String() string](<#func-sigalgorithm-string>)
- [type Signature](<#type-signature>)
  - [func (s *Signature) UnmarshalJSON(data []byte) error](<#func-signature-unmarshaljson>)
- [type Signed](<#type-signed>)
- [type SignedCommon](<#type-signedcommon>)
- [type SignedMeta](<#type-signedmeta>)
- [type SignedRoot](<#type-signedroot>)
  - [func NewRoot(keys map[string]PublicKey, roles map[RoleName]*RootRole, consistent bool) (*SignedRoot, error)](<#func-newroot>)
  - [func RootFromSigned(s *Signed) (*SignedRoot, error)](<#func-rootfromsigned>)
  - [func (r SignedRoot) BuildBaseRole(roleName RoleName) (BaseRole, error)](<#func-signedroot-buildbaserole>)
  - [func (r SignedRoot) MarshalJSON() ([]byte, error)](<#func-signedroot-marshaljson>)
  - [func (r SignedRoot) ToSigned() (*Signed, error)](<#func-signedroot-tosigned>)
- [type SignedSnapshot](<#type-signedsnapshot>)
  - [func NewSnapshot(root *Signed, targets *Signed) (*SignedSnapshot, error)](<#func-newsnapshot>)
  - [func SnapshotFromSigned(s *Signed) (*SignedSnapshot, error)](<#func-snapshotfromsigned>)
  - [func (sp *SignedSnapshot) AddMeta(role RoleName, meta FileMeta)](<#func-signedsnapshot-addmeta>)
  - [func (sp *SignedSnapshot) DeleteMeta(role RoleName)](<#func-signedsnapshot-deletemeta>)
  - [func (sp *SignedSnapshot) GetMeta(role RoleName) (*FileMeta, error)](<#func-signedsnapshot-getmeta>)
  - [func (sp *SignedSnapshot) MarshalJSON() ([]byte, error)](<#func-signedsnapshot-marshaljson>)
  - [func (sp *SignedSnapshot) ToSigned() (*Signed, error)](<#func-signedsnapshot-tosigned>)
- [type SignedTargets](<#type-signedtargets>)
  - [func NewTargets() *SignedTargets](<#func-newtargets>)
  - [func TargetsFromSigned(s *Signed, roleName RoleName) (*SignedTargets, error)](<#func-targetsfromsigned>)
  - [func (t *SignedTargets) AddDelegation(role *Role, keys []*PublicKey) error](<#func-signedtargets-adddelegation>)
  - [func (t *SignedTargets) AddTarget(path string, meta FileMeta)](<#func-signedtargets-addtarget>)
  - [func (t *SignedTargets) BuildDelegationRole(roleName RoleName) (DelegationRole, error)](<#func-signedtargets-builddelegationrole>)
  - [func (t SignedTargets) GetMeta(path string) *FileMeta](<#func-signedtargets-getmeta>)
  - [func (t SignedTargets) GetValidDelegations(parent DelegationRole) []DelegationRole](<#func-signedtargets-getvaliddelegations>)
  - [func (t *SignedTargets) MarshalJSON() ([]byte, error)](<#func-signedtargets-marshaljson>)
  - [func (t *SignedTargets) ToSigned() (*Signed, error)](<#func-signedtargets-tosigned>)
- [type SignedTimestamp](<#type-signedtimestamp>)
  - [func NewTimestamp(snapshot *Signed) (*SignedTimestamp, error)](<#func-newtimestamp>)
  - [func TimestampFromSigned(s *Signed) (*SignedTimestamp, error)](<#func-timestampfromsigned>)
  - [func (ts *SignedTimestamp) GetSnapshot() (*FileMeta, error)](<#func-signedtimestamp-getsnapshot>)
  - [func (ts *SignedTimestamp) MarshalJSON() ([]byte, error)](<#func-signedtimestamp-marshaljson>)
  - [func (ts *SignedTimestamp) ToSigned() (*Signed, error)](<#func-signedtimestamp-tosigned>)
- [type Snapshot](<#type-snapshot>)
- [type TUFKey](<#type-tufkey>)
  - [func (k TUFKey) Algorithm() string](<#func-tufkey-algorithm>)
  - [func (k *TUFKey) ID() string](<#func-tufkey-id>)
  - [func (k TUFKey) Public() []byte](<#func-tufkey-public>)
- [type Targets](<#type-targets>)
- [type Timestamp](<#type-timestamp>)
- [type UnknownPrivateKey](<#type-unknownprivatekey>)
  - [func (k UnknownPrivateKey) CryptoSigner() crypto.Signer](<#func-unknownprivatekey-cryptosigner>)
  - [func (k UnknownPrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)](<#func-unknownprivatekey-sign>)
  - [func (k UnknownPrivateKey) SignatureAlgorithm() SigAlgorithm](<#func-unknownprivatekey-signaturealgorithm>)
- [type UnknownPublicKey](<#type-unknownpublickey>)


## Constants

Key types

```go
const (
    ED25519Key   = "ed25519"
    RSAKey       = "rsa"
    RSAx509Key   = "rsa-x509"
    ECDSAKey     = "ecdsa"
    ECDSAx509Key = "ecdsa-x509"
)
```

## Variables

BaseRoles is an easy to iterate list of the top level roles.

```go
var BaseRoles = []RoleName{
    CanonicalRootRole,
    CanonicalTargetsRole,
    CanonicalSnapshotRole,
    CanonicalTimestampRole,
}
```

NotaryDefaultExpiries is the construct used to configure the default expiry times of the various role files.

```go
var NotaryDefaultExpiries = map[RoleName]time.Duration{
    CanonicalRootRole:      notary.NotaryRootExpiry,
    CanonicalTargetsRole:   notary.NotaryTargetsExpiry,
    CanonicalSnapshotRole:  notary.NotarySnapshotExpiry,
    CanonicalTimestampRole: notary.NotaryTimestampExpiry,
}
```

NotaryDefaultHashes contains the default supported hash algorithms.

```go
var NotaryDefaultHashes = []string{notary.SHA256, notary.SHA512}
```

TUFTypes is the set of metadata types

```go
var TUFTypes = map[RoleName]string{
    CanonicalRootRole:      "Root",
    CanonicalTargetsRole:   "Targets",
    CanonicalSnapshotRole:  "Snapshot",
    CanonicalTimestampRole: "Timestamp",
}
```

## func CheckHashes

```go
func CheckHashes(payload []byte, name string, hashes Hashes) error
```

CheckHashes verifies all the checksums specified by the "hashes" of the payload.

## func CheckValidHashStructures

```go
func CheckValidHashStructures(hashes Hashes) error
```

CheckValidHashStructures returns an error, or nil, depending on whether the content of the hashes is valid or not.

## func CompareMultiHashes

```go
func CompareMultiHashes(hashes1, hashes2 Hashes) error
```

CompareMultiHashes verifies that the two Hashes passed in can represent the same data. This means that both maps must have at least one key defined for which they map, and no conflicts. Note that we check the intersection of map keys, which adds support for non\-default hash algorithms in notary

## func DefaultExpires

```go
func DefaultExpires(role RoleName) time.Time
```

DefaultExpires gets the default expiry time for the given role

## func IsBaseRole

```go
func IsBaseRole(role RoleName) bool
```

IsBaseRole checks if the role is a base role

## func IsDelegation

```go
func IsDelegation(role RoleName) bool
```

IsDelegation checks if the role is a delegation or a root role

## func IsValidSnapshotStructure

```go
func IsValidSnapshotStructure(s Snapshot) error
```

IsValidSnapshotStructure returns an error, or nil, depending on whether the content of the struct is valid for snapshot metadata.  This does not check signatures or expiry, just that the metadata content is valid.

## func IsValidTimestampStructure

```go
func IsValidTimestampStructure(t Timestamp) error
```

IsValidTimestampStructure returns an error, or nil, depending on whether the content of the struct is valid for timestamp metadata.  This does not check signatures or expiry, just that the metadata content is valid.

## func IsWildDelegation

```go
func IsWildDelegation(role RoleName) bool
```

IsWildDelegation determines if a role represents a valid wildcard delegation path, i.e. targets/\*, targets/foo/\*. The wildcard may only appear as the final part of the delegation and must be a whole segment, i.e. targets/foo\* is not a valid wildcard delegation.

## func MetadataRoleMapToStringMap

```go
func MetadataRoleMapToStringMap(roles map[RoleName][]byte) map[string][]byte
```

MetadataRoleMapToStringMap generates a map string of bytes from a map RoleName of bytes

## func RestrictDelegationPathPrefixes

```go
func RestrictDelegationPathPrefixes(parentPaths, delegationPaths []string) []string
```

RestrictDelegationPathPrefixes returns the list of valid delegationPaths that are prefixed by parentPaths

## func RolesListToStringList

```go
func RolesListToStringList(roles []RoleName) []string
```

RolesListToStringList generates an array of string objects from a slice of roles

## func SetDefaultExpiryTimes

```go
func SetDefaultExpiryTimes(times map[RoleName]time.Duration)
```

SetDefaultExpiryTimes allows one to change the default expiries.

## func ValidRole

```go
func ValidRole(name RoleName) bool
```

ValidRole only determines the name is semantically correct. For target delegated roles, it does NOT check the appropriate parent roles exist.

## func ValidTUFType

```go
func ValidTUFType(typ string, role RoleName) bool
```

ValidTUFType checks if the given type is valid for the role

## type BaseRole

BaseRole is an internal representation of a root/targets/snapshot/timestamp role, with its public keys included

```go
type BaseRole struct {
    Keys      map[string]PublicKey
    Name      RoleName
    Threshold int
}
```

### func NewBaseRole

```go
func NewBaseRole(name RoleName, threshold int, keys ...PublicKey) BaseRole
```

NewBaseRole creates a new BaseRole object with the provided parameters

### func \(BaseRole\) Equals

```go
func (b BaseRole) Equals(o BaseRole) bool
```

Equals returns whether this BaseRole equals another BaseRole

### func \(BaseRole\) ListKeyIDs

```go
func (b BaseRole) ListKeyIDs() []string
```

ListKeyIDs retrieves the list of key IDs valid for this role

### func \(BaseRole\) ListKeys

```go
func (b BaseRole) ListKeys() KeyList
```

ListKeys retrieves the public keys valid for this role

## type DelegationRole

DelegationRole is an internal representation of a delegation role, with its public keys included

```go
type DelegationRole struct {
    BaseRole
    Paths []string
}
```

### func \(DelegationRole\) CheckPaths

```go
func (d DelegationRole) CheckPaths(path string) bool
```

CheckPaths checks if a given path is valid for the role

### func \(DelegationRole\) IsParentOf

```go
func (d DelegationRole) IsParentOf(child DelegationRole) bool
```

IsParentOf returns whether the passed in delegation role is the direct child of this role, determined by delegation name. Ex: targets/a is a direct parent of targets/a/b, but targets/a is not a direct parent of targets/a/b/c

### func \(DelegationRole\) Restrict

```go
func (d DelegationRole) Restrict(child DelegationRole) (DelegationRole, error)
```

Restrict restricts the paths and path hash prefixes for the passed in delegation role, returning a copy of the role with validated paths as if it was a direct child

## type Delegations

Delegations holds a tier of targets delegations

```go
type Delegations struct {
    Keys  Keys    `json:"keys"`
    Roles []*Role `json:"roles"`
}
```

### func NewDelegations

```go
func NewDelegations() *Delegations
```

NewDelegations initializes an empty Delegations object

## type ECDSAPrivateKey

ECDSAPrivateKey represents a private ECDSA key

```go
type ECDSAPrivateKey struct {
    PublicKey
    // contains filtered or unexported fields
}
```

### func NewECDSAPrivateKey

```go
func NewECDSAPrivateKey(public PublicKey, private []byte) (*ECDSAPrivateKey, error)
```

NewECDSAPrivateKey initializes a new ECDSA private key

### func \(ECDSAPrivateKey\) Sign

```go
func (k ECDSAPrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)
```

Sign creates an ecdsa signature

### func \(ECDSAPrivateKey\) SignatureAlgorithm

```go
func (k ECDSAPrivateKey) SignatureAlgorithm() SigAlgorithm
```

SignatureAlgorithm returns the SigAlgorithm for a ECDSAPrivateKey

## type ECDSAPublicKey

ECDSAPublicKey represents an ECDSA key using a raw serialization of the public key

```go
type ECDSAPublicKey struct {
    TUFKey
}
```

### func NewECDSAPublicKey

```go
func NewECDSAPublicKey(public []byte) *ECDSAPublicKey
```

NewECDSAPublicKey initializes a new public key with the ECDSAKey type

## type ECDSAx509PublicKey

ECDSAx509PublicKey represents an ECDSA key using an x509 cert as the serialized format of the public key

```go
type ECDSAx509PublicKey struct {
    TUFKey
}
```

### func NewECDSAx509PublicKey

```go
func NewECDSAx509PublicKey(public []byte) *ECDSAx509PublicKey
```

NewECDSAx509PublicKey initializes a new public key with the ECDSAx509Key type

## type ED25519PrivateKey

ED25519PrivateKey represents a private ED25519 key

```go
type ED25519PrivateKey struct {
    ED25519PublicKey
    // contains filtered or unexported fields
}
```

### func NewED25519PrivateKey

```go
func NewED25519PrivateKey(public ED25519PublicKey, private []byte) (*ED25519PrivateKey, error)
```

NewED25519PrivateKey initialized a new ED25519 private key

### func \(ED25519PrivateKey\) CryptoSigner

```go
func (k ED25519PrivateKey) CryptoSigner() crypto.Signer
```

CryptoSigner returns the ED25519PrivateKey which already implements crypto.Signer

### func \(ED25519PrivateKey\) Sign

```go
func (k ED25519PrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)
```

Sign creates an ed25519 signature

### func \(ED25519PrivateKey\) SignatureAlgorithm

```go
func (k ED25519PrivateKey) SignatureAlgorithm() SigAlgorithm
```

SignatureAlgorithm returns the SigAlgorithm for a ED25519PrivateKey

## type ED25519PublicKey

ED25519PublicKey represents an ED25519 key using a raw serialization of the public key

```go
type ED25519PublicKey struct {
    TUFKey
}
```

### func NewED25519PublicKey

```go
func NewED25519PublicKey(public []byte) *ED25519PublicKey
```

NewED25519PublicKey initializes a new public key with the ED25519Key type

## type ErrCertExpired

ErrCertExpired is the error to be returned when a certificate has expired

```go
type ErrCertExpired struct {
    CN string
}
```

### func \(ErrCertExpired\) Error

```go
func (e ErrCertExpired) Error() string
```

## type ErrInvalidChecksum

ErrInvalidChecksum is the error to be returned when checksum is invalid

```go
type ErrInvalidChecksum struct {
    // contains filtered or unexported fields
}
```

### func \(ErrInvalidChecksum\) Error

```go
func (e ErrInvalidChecksum) Error() string
```

## type ErrInvalidMetadata

ErrInvalidMetadata is the error to be returned when metadata is invalid

```go
type ErrInvalidMetadata struct {
    // contains filtered or unexported fields
}
```

### func \(ErrInvalidMetadata\) Error

```go
func (e ErrInvalidMetadata) Error() string
```

## type ErrInvalidRole

ErrInvalidRole represents an error regarding a role. Typically something like a role for which sone of the public keys were not found in the TUF repo.

```go
type ErrInvalidRole struct {
    Role   RoleName
    Reason string
}
```

### func \(ErrInvalidRole\) Error

```go
func (e ErrInvalidRole) Error() string
```

## type ErrMismatchedChecksum

ErrMismatchedChecksum is the error to be returned when checksum is mismatched

```go
type ErrMismatchedChecksum struct {
    // contains filtered or unexported fields
}
```

### func \(ErrMismatchedChecksum\) Error

```go
func (e ErrMismatchedChecksum) Error() string
```

## type ErrMissingMeta

ErrMissingMeta \- couldn't find the FileMeta object for the given Role, or the FileMeta object contained no supported checksums

```go
type ErrMissingMeta struct {
    Role string
}
```

### func \(ErrMissingMeta\) Error

```go
func (e ErrMissingMeta) Error() string
```

## type ErrNoSuchRole

ErrNoSuchRole indicates the roles doesn't exist

```go
type ErrNoSuchRole struct {
    Role RoleName
}
```

### func \(ErrNoSuchRole\) Error

```go
func (e ErrNoSuchRole) Error() string
```

## type FileMeta

FileMeta contains the size and hashes for a metadata or target file. Custom data can be optionally added.

```go
type FileMeta struct {
    Length int64            `json:"length"`
    Hashes Hashes           `json:"hashes"`
    Custom *json.RawMessage `json:"custom,omitempty"`
}
```

### func NewFileMeta

```go
func NewFileMeta(r io.Reader, hashAlgorithms ...string) (FileMeta, error)
```

NewFileMeta generates a FileMeta object from the reader, using the hash algorithms provided

### func \(FileMeta\) Equals

```go
func (f FileMeta) Equals(o FileMeta) bool
```

Equals returns true if the other FileMeta object is equivalent to this one

## type Files

Files is the map of paths to file meta container in targets and delegations metadata files

```go
type Files map[string]FileMeta
```

## type GUN

GUN is a Globally Unique Name. It is used to identify trust collections. An example usage of this is for container image repositories. For example: myregistry.io/myuser/myimage

```go
type GUN string
```

### func \(GUN\) String

```go
func (g GUN) String() string
```

## type Hashes

Hashes is the map of hash type to digest created for each metadata and target file

```go
type Hashes map[string][]byte
```

## type KeyList

KeyList represents a list of keys

```go
type KeyList []PublicKey
```

### func \(KeyList\) IDs

```go
func (ks KeyList) IDs() []string
```

IDs generates a list of the hex encoded key IDs in the KeyList

### func \(\*KeyList\) UnmarshalJSON

```go
func (ks *KeyList) UnmarshalJSON(data []byte) error
```

UnmarshalJSON implements the json.Unmarshaller interface

## type KeyPair

KeyPair holds the public and private key bytes

```go
type KeyPair struct {
    Public  []byte `json:"public"`
    Private []byte `json:"private"`
}
```

## type Keys

Keys represents a map of key ID to PublicKey object. It's necessary to allow us to unmarshal into an interface via the json.Unmarshaller interface

```go
type Keys map[string]PublicKey
```

### func \(\*Keys\) UnmarshalJSON

```go
func (ks *Keys) UnmarshalJSON(data []byte) error
```

UnmarshalJSON implements the json.Unmarshaller interface

## type PrivateKey

PrivateKey adds the ability to access the private key

```go
type PrivateKey interface {
    PublicKey
    Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)
    Private() []byte
    CryptoSigner() crypto.Signer
    SignatureAlgorithm() SigAlgorithm
}
```

### func NewPrivateKey

```go
func NewPrivateKey(pubKey PublicKey, private []byte) (PrivateKey, error)
```

NewPrivateKey creates a new, correctly typed PrivateKey, using the UnknownPrivateKey catchall for unsupported ciphers

### func UnmarshalPrivateKey

```go
func UnmarshalPrivateKey(data []byte) (PrivateKey, error)
```

UnmarshalPrivateKey is used to parse individual private keys in JSON

## type PublicKey

PublicKey is the necessary interface for public keys

```go
type PublicKey interface {
    ID() string
    Algorithm() string
    Public() []byte
}
```

### func NewPublicKey

```go
func NewPublicKey(alg string, public []byte) PublicKey
```

NewPublicKey creates a new, correctly typed PublicKey, using the UnknownPublicKey catchall for unsupported ciphers

### func PublicKeyFromPrivate

```go
func PublicKeyFromPrivate(pk PrivateKey) PublicKey
```

PublicKeyFromPrivate returns a new TUFKey based on a private key, with the private key bytes guaranteed to be nil.

### func UnmarshalPublicKey

```go
func UnmarshalPublicKey(data []byte) (PublicKey, error)
```

UnmarshalPublicKey is used to parse individual public keys in JSON

## type RSAPrivateKey

RSAPrivateKey represents a private RSA key

```go
type RSAPrivateKey struct {
    PublicKey
    // contains filtered or unexported fields
}
```

### func NewRSAPrivateKey

```go
func NewRSAPrivateKey(public PublicKey, private []byte) (*RSAPrivateKey, error)
```

NewRSAPrivateKey initialized a new RSA private key

### func \(RSAPrivateKey\) Sign

```go
func (k RSAPrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)
```

Sign creates an rsa signature

### func \(RSAPrivateKey\) SignatureAlgorithm

```go
func (k RSAPrivateKey) SignatureAlgorithm() SigAlgorithm
```

SignatureAlgorithm returns the SigAlgorithm for a RSAPrivateKey

## type RSAPublicKey

RSAPublicKey represents an RSA key using a raw serialization of the public key

```go
type RSAPublicKey struct {
    TUFKey
}
```

### func NewRSAPublicKey

```go
func NewRSAPublicKey(public []byte) *RSAPublicKey
```

NewRSAPublicKey initializes a new public key with the RSA type

## type RSAx509PublicKey

RSAx509PublicKey represents an RSA key using an x509 cert as the serialized format of the public key

```go
type RSAx509PublicKey struct {
    TUFKey
}
```

### func NewRSAx509PublicKey

```go
func NewRSAx509PublicKey(public []byte) *RSAx509PublicKey
```

NewRSAx509PublicKey initializes a new public key with the RSAx509Key type

## type Role

Role is a more verbose role as they appear in targets delegations Eventually should only be used for immediately before and after serialization/deserialization

```go
type Role struct {
    RootRole
    Name  RoleName `json:"name"`
    Paths []string `json:"paths,omitempty"`
}
```

### func NewRole

```go
func NewRole(name RoleName, threshold int, keyIDs, paths []string) (*Role, error)
```

NewRole creates a new Role object from the given parameters

### func \(\*Role\) AddKeys

```go
func (r *Role) AddKeys(ids []string)
```

AddKeys merges the ids into the current list of role key ids

### func \(\*Role\) AddPaths

```go
func (r *Role) AddPaths(paths []string) error
```

AddPaths merges the paths into the current list of role paths

### func \(Role\) CheckPaths

```go
func (r Role) CheckPaths(path string) bool
```

CheckPaths checks if a given path is valid for the role

### func \(\*Role\) RemoveKeys

```go
func (r *Role) RemoveKeys(ids []string)
```

RemoveKeys removes the ids from the current list of key ids

### func \(\*Role\) RemovePaths

```go
func (r *Role) RemovePaths(paths []string)
```

RemovePaths removes the paths from the current list of role paths

## type RoleName

RoleName type for specifying role

```go
type RoleName string
```

Canonical base role names

```go
var (
    CanonicalRootRole      RoleName = "root"
    CanonicalTargetsRole   RoleName = "targets"
    CanonicalSnapshotRole  RoleName = "snapshot"
    CanonicalTimestampRole RoleName = "timestamp"
)
```

### func NewRoleList

```go
func NewRoleList(roles []string) []RoleName
```

NewRoleList generates an array of RoleName objects from a slice of strings

### func \(RoleName\) Parent

```go
func (r RoleName) Parent() RoleName
```

Parent provides the parent path role from the provided child role

### func \(RoleName\) String

```go
func (r RoleName) String() string
```

## type Root

Root is the Signed component of a root.json

```go
type Root struct {
    SignedCommon
    Keys               Keys                   `json:"keys"`
    Roles              map[RoleName]*RootRole `json:"roles"`
    ConsistentSnapshot bool                   `json:"consistent_snapshot"`
}
```

## type RootRole

RootRole is a cut down role as it appears in the root.json Eventually should only be used for immediately before and after serialization/deserialization

```go
type RootRole struct {
    KeyIDs    []string `json:"keyids"`
    Threshold int      `json:"threshold"`
}
```

## type SigAlgorithm

SigAlgorithm for types of signatures

```go
type SigAlgorithm string
```

Signature types

```go
const (
    EDDSASignature       SigAlgorithm = "eddsa"
    RSAPSSSignature      SigAlgorithm = "rsapss"
    RSAPKCS1v15Signature SigAlgorithm = "rsapkcs1v15"
    ECDSASignature       SigAlgorithm = "ecdsa"
    PyCryptoSignature    SigAlgorithm = "pycrypto-pkcs#1 pss"
)
```

### func \(SigAlgorithm\) String

```go
func (k SigAlgorithm) String() string
```

## type Signature

Signature is a signature on a piece of metadata

```go
type Signature struct {
    KeyID     string       `json:"keyid"`
    Method    SigAlgorithm `json:"method"`
    Signature []byte       `json:"sig"`
    IsValid   bool         `json:"-"`
}
```

### func \(\*Signature\) UnmarshalJSON

```go
func (s *Signature) UnmarshalJSON(data []byte) error
```

UnmarshalJSON does a custom unmarshalling of the signature JSON

## type Signed

Signed is the high level, partially deserialized metadata object used to verify signatures before fully unpacking, or to add signatures before fully packing

```go
type Signed struct {
    Signed     *json.RawMessage `json:"signed"`
    Signatures []Signature      `json:"signatures"`
}
```

## type SignedCommon

SignedCommon contains the fields common to the Signed component of all TUF metadata files

```go
type SignedCommon struct {
    Type    string    `json:"_type"`
    Expires time.Time `json:"expires"`
    Version int       `json:"version"`
}
```

## type SignedMeta

SignedMeta is used in server validation where we only need signatures and common fields

```go
type SignedMeta struct {
    Signed     SignedCommon `json:"signed"`
    Signatures []Signature  `json:"signatures"`
}
```

## type SignedRoot

SignedRoot is a fully unpacked root.json

```go
type SignedRoot struct {
    Signatures []Signature
    Signed     Root
    Dirty      bool
}
```

### func NewRoot

```go
func NewRoot(keys map[string]PublicKey, roles map[RoleName]*RootRole, consistent bool) (*SignedRoot, error)
```

NewRoot initializes a new SignedRoot with a set of keys, roles, and the consistent flag

### func RootFromSigned

```go
func RootFromSigned(s *Signed) (*SignedRoot, error)
```

RootFromSigned fully unpacks a Signed object into a SignedRoot and ensures that it is a valid SignedRoot

### func \(SignedRoot\) BuildBaseRole

```go
func (r SignedRoot) BuildBaseRole(roleName RoleName) (BaseRole, error)
```

BuildBaseRole returns a copy of a BaseRole using the information in this SignedRoot for the specified role name. Will error for invalid role name or key metadata within this SignedRoot

### func \(SignedRoot\) MarshalJSON

```go
func (r SignedRoot) MarshalJSON() ([]byte, error)
```

MarshalJSON returns the serialized form of SignedRoot as bytes

### func \(SignedRoot\) ToSigned

```go
func (r SignedRoot) ToSigned() (*Signed, error)
```

ToSigned partially serializes a SignedRoot for further signing

## type SignedSnapshot

SignedSnapshot is a fully unpacked snapshot.json

```go
type SignedSnapshot struct {
    Signatures []Signature
    Signed     Snapshot
    Dirty      bool
}
```

### func NewSnapshot

```go
func NewSnapshot(root *Signed, targets *Signed) (*SignedSnapshot, error)
```

NewSnapshot initializes a SignedSnapshot with a given top level root and targets objects

### func SnapshotFromSigned

```go
func SnapshotFromSigned(s *Signed) (*SignedSnapshot, error)
```

SnapshotFromSigned fully unpacks a Signed object into a SignedSnapshot

### func \(\*SignedSnapshot\) AddMeta

```go
func (sp *SignedSnapshot) AddMeta(role RoleName, meta FileMeta)
```

AddMeta updates a role in the snapshot with new meta

### func \(\*SignedSnapshot\) DeleteMeta

```go
func (sp *SignedSnapshot) DeleteMeta(role RoleName)
```

DeleteMeta removes a role from the snapshot. If the role doesn't exist in the snapshot, it's a noop.

### func \(\*SignedSnapshot\) GetMeta

```go
func (sp *SignedSnapshot) GetMeta(role RoleName) (*FileMeta, error)
```

GetMeta gets the metadata for a particular role, returning an error if it's not found

### func \(\*SignedSnapshot\) MarshalJSON

```go
func (sp *SignedSnapshot) MarshalJSON() ([]byte, error)
```

MarshalJSON returns the serialized form of SignedSnapshot as bytes

### func \(\*SignedSnapshot\) ToSigned

```go
func (sp *SignedSnapshot) ToSigned() (*Signed, error)
```

ToSigned partially serializes a SignedSnapshot for further signing

## type SignedTargets

SignedTargets is a fully unpacked targets.json, or target delegation json file

```go
type SignedTargets struct {
    Signatures []Signature
    Signed     Targets
    Dirty      bool
}
```

### func NewTargets

```go
func NewTargets() *SignedTargets
```

NewTargets initializes a new empty SignedTargets object

### func TargetsFromSigned

```go
func TargetsFromSigned(s *Signed, roleName RoleName) (*SignedTargets, error)
```

TargetsFromSigned fully unpacks a Signed object into a SignedTargets, given a role name \(so it can validate the SignedTargets object\)

### func \(\*SignedTargets\) AddDelegation

```go
func (t *SignedTargets) AddDelegation(role *Role, keys []*PublicKey) error
```

AddDelegation will add a new delegated role with the given keys, ensuring the keys either already exist, or are added to the map of delegation keys

### func \(\*SignedTargets\) AddTarget

```go
func (t *SignedTargets) AddTarget(path string, meta FileMeta)
```

AddTarget adds or updates the meta for the given path

### func \(\*SignedTargets\) BuildDelegationRole

```go
func (t *SignedTargets) BuildDelegationRole(roleName RoleName) (DelegationRole, error)
```

BuildDelegationRole returns a copy of a DelegationRole using the information in this SignedTargets for the specified role name. Will error for invalid role name or key metadata within this SignedTargets.  Path data is not validated.

### func \(SignedTargets\) GetMeta

```go
func (t SignedTargets) GetMeta(path string) *FileMeta
```

GetMeta attempts to find the targets entry for the path. It will return nil in the case of the target not being found.

### func \(SignedTargets\) GetValidDelegations

```go
func (t SignedTargets) GetValidDelegations(parent DelegationRole) []DelegationRole
```

GetValidDelegations filters the delegation roles specified in the signed targets, and only returns roles that are direct children and restricts their paths

### func \(\*SignedTargets\) MarshalJSON

```go
func (t *SignedTargets) MarshalJSON() ([]byte, error)
```

MarshalJSON returns the serialized form of SignedTargets as bytes

### func \(\*SignedTargets\) ToSigned

```go
func (t *SignedTargets) ToSigned() (*Signed, error)
```

ToSigned partially serializes a SignedTargets for further signing

## type SignedTimestamp

SignedTimestamp is a fully unpacked timestamp.json

```go
type SignedTimestamp struct {
    Signatures []Signature
    Signed     Timestamp
    Dirty      bool
}
```

### func NewTimestamp

```go
func NewTimestamp(snapshot *Signed) (*SignedTimestamp, error)
```

NewTimestamp initializes a timestamp with an existing snapshot

### func TimestampFromSigned

```go
func TimestampFromSigned(s *Signed) (*SignedTimestamp, error)
```

TimestampFromSigned parsed a Signed object into a fully unpacked SignedTimestamp

### func \(\*SignedTimestamp\) GetSnapshot

```go
func (ts *SignedTimestamp) GetSnapshot() (*FileMeta, error)
```

GetSnapshot gets the expected snapshot metadata hashes in the timestamp metadata, or nil if it doesn't exist

### func \(\*SignedTimestamp\) MarshalJSON

```go
func (ts *SignedTimestamp) MarshalJSON() ([]byte, error)
```

MarshalJSON returns the serialized form of SignedTimestamp as bytes

### func \(\*SignedTimestamp\) ToSigned

```go
func (ts *SignedTimestamp) ToSigned() (*Signed, error)
```

ToSigned partially serializes a SignedTimestamp such that it can be signed

## type Snapshot

Snapshot is the Signed component of a snapshot.json

```go
type Snapshot struct {
    SignedCommon
    Meta Files `json:"meta"`
}
```

## type TUFKey

TUFKey is the structure used for both public and private keys in TUF. Normally it would make sense to use a different structures for public and private keys, but that would change the key ID algorithm \(since the canonical JSON would be different\). This structure should normally be accessed through the PublicKey or PrivateKey interfaces.

```go
type TUFKey struct {
    Type  string  `json:"keytype"`
    Value KeyPair `json:"keyval"`
    // contains filtered or unexported fields
}
```

### func \(TUFKey\) Algorithm

```go
func (k TUFKey) Algorithm() string
```

Algorithm returns the algorithm of the key

### func \(\*TUFKey\) ID

```go
func (k *TUFKey) ID() string
```

ID efficiently generates if necessary, and caches the ID of the key

### func \(TUFKey\) Public

```go
func (k TUFKey) Public() []byte
```

Public returns the public bytes

## type Targets

Targets is the Signed components of a targets.json or delegation json file

```go
type Targets struct {
    SignedCommon
    Targets     Files       `json:"targets"`
    Delegations Delegations `json:"delegations,omitempty"`
}
```

## type Timestamp

Timestamp is the Signed component of a timestamp.json

```go
type Timestamp struct {
    SignedCommon
    Meta Files `json:"meta"`
}
```

## type UnknownPrivateKey

UnknownPrivateKey is a catchall for unsupported key types

```go
type UnknownPrivateKey struct {
    TUFKey
    // contains filtered or unexported fields
}
```

### func \(UnknownPrivateKey\) CryptoSigner

```go
func (k UnknownPrivateKey) CryptoSigner() crypto.Signer
```

CryptoSigner returns the UnknownPrivateKey which already implements crypto.Signer

### func \(UnknownPrivateKey\) Sign

```go
func (k UnknownPrivateKey) Sign(rand io.Reader, msg []byte, opts crypto.SignerOpts) (signature []byte, err error)
```

Sign on an UnknownPrivateKey raises an error because the client does not know how to sign with this key type.

### func \(UnknownPrivateKey\) SignatureAlgorithm

```go
func (k UnknownPrivateKey) SignatureAlgorithm() SigAlgorithm
```

SignatureAlgorithm returns the SigAlgorithm for an UnknownPrivateKey

## type UnknownPublicKey

UnknownPublicKey is a catchall for key types that are not supported

```go
type UnknownPublicKey struct {
    TUFKey
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
