<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# fse

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/github.com/klauspost/compress/fse"
```

Package fse provides Finite State Entropy encoding and decoding.

Finite State Entropy encoding provides a fast near\-optimal symbol encoding/decoding for byte blocks as implemented in zstd.

See https://github.com/klauspost/compress/tree/master/fse for more information.

## Index

- [Variables](<#variables>)
- [func Compress(in []byte, s *Scratch) ([]byte, error)](<#func-compress>)
- [func Decompress(b []byte, s *Scratch) ([]byte, error)](<#func-decompress>)
- [type Scratch](<#type-scratch>)
  - [func (s *Scratch) Histogram() []uint32](<#func-scratch-histogram>)
  - [func (s *Scratch) HistogramFinished(maxSymbol uint8, maxCount int)](<#func-scratch-histogramfinished>)


## Variables

```go
var (
    // ErrIncompressible is returned when input is judged to be too hard to compress.
    ErrIncompressible = errors.New("input is not compressible")

    // ErrUseRLE is returned from the compressor when the input is a single byte value repeated.
    ErrUseRLE = errors.New("input is single value repeated")
)
```

## func Compress

```go
func Compress(in []byte, s *Scratch) ([]byte, error)
```

Compress the input bytes. Input must be \< 2GB. Provide a Scratch buffer to avoid memory allocations. Note that the output is also kept in the scratch buffer. If input is too hard to compress, ErrIncompressible is returned. If input is a single byte value repeated ErrUseRLE is returned.

## func Decompress

```go
func Decompress(b []byte, s *Scratch) ([]byte, error)
```

Decompress a block of data. You can provide a scratch buffer to avoid allocations. If nil is provided a temporary one will be allocated. It is possible, but by no way guaranteed that corrupt data will return an error. It is up to the caller to verify integrity of the returned data. Use a predefined Scrach to set maximum acceptable output size.

## type Scratch

Scratch provides temporary storage for compression and decompression.

```go
type Scratch struct {

    // Out is output buffer.
    // If the scratch is re-used before the caller is done processing the output,
    // set this field to nil.
    // Otherwise the output buffer will be re-used for next Compression/Decompression step
    // and allocation will be avoided.
    Out []byte

    // DecompressLimit limits the maximum decoded size acceptable.
    // If > 0 decompression will stop when approximately this many bytes
    // has been decoded.
    // If 0, maximum size will be 2GB.
    DecompressLimit int

    // MaxSymbolValue will override the maximum symbol value of the next block.
    MaxSymbolValue uint8

    // TableLog will attempt to override the tablelog for the next block.
    TableLog uint8
    // contains filtered or unexported fields
}
```

### func \(\*Scratch\) Histogram

```go
func (s *Scratch) Histogram() []uint32
```

Histogram allows to populate the histogram and skip that step in the compression, It otherwise allows to inspect the histogram when compression is done. To indicate that you have populated the histogram call HistogramFinished with the value of the highest populated symbol, as well as the number of entries in the most populated entry. These are accepted at face value. The returned slice will always be length 256.

### func \(\*Scratch\) HistogramFinished

```go
func (s *Scratch) HistogramFinished(maxSymbol uint8, maxCount int)
```

HistogramFinished can be called to indicate that the histogram has been populated. maxSymbol is the index of the highest set symbol of the next data segment. maxCount is the number of entries in the most populated entry. These are accepted at face value.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
