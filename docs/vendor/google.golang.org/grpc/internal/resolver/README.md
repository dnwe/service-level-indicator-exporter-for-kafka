<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# resolver

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/google.golang.org/grpc/internal/resolver"
```

Package resolver provides internal resolver\-related functionality.

## Index

- [func SetConfigSelector(state resolver.State, cs ConfigSelector) resolver.State](<#func-setconfigselector>)
- [type ClientInterceptor](<#type-clientinterceptor>)
- [type ClientStream](<#type-clientstream>)
- [type ConfigSelector](<#type-configselector>)
  - [func GetConfigSelector(state resolver.State) ConfigSelector](<#func-getconfigselector>)
- [type RPCConfig](<#type-rpcconfig>)
- [type RPCInfo](<#type-rpcinfo>)
- [type SafeConfigSelector](<#type-safeconfigselector>)
  - [func (scs *SafeConfigSelector) SelectConfig(r RPCInfo) (*RPCConfig, error)](<#func-safeconfigselector-selectconfig>)
  - [func (scs *SafeConfigSelector) UpdateConfigSelector(cs ConfigSelector)](<#func-safeconfigselector-updateconfigselector>)
- [type ServerInterceptor](<#type-serverinterceptor>)


## func SetConfigSelector

```go
func SetConfigSelector(state resolver.State, cs ConfigSelector) resolver.State
```

SetConfigSelector sets the config selector in state and returns the new state.

## type ClientInterceptor

ClientInterceptor is an interceptor for gRPC client streams.

```go
type ClientInterceptor interface {
    // NewStream produces a ClientStream for an RPC which may optionally use
    // the provided function to produce a stream for delegation.  Note:
    // RPCInfo.Context should not be used (will be nil).
    //
    // done is invoked when the RPC is finished using its connection, or could
    // not be assigned a connection.  RPC operations may still occur on
    // ClientStream after done is called, since the interceptor is invoked by
    // application-layer operations.  done must never be nil when called.
    NewStream(ctx context.Context, ri RPCInfo, done func(), newStream func(ctx context.Context, done func()) (ClientStream, error)) (ClientStream, error)
}
```

## type ClientStream

ClientStream is the same as grpc.ClientStream, but defined here for circular dependency reasons.

```go
type ClientStream interface {
    // Header returns the header metadata received from the server if there
    // is any. It blocks if the metadata is not ready to read.
    Header() (metadata.MD, error)
    // Trailer returns the trailer metadata from the server, if there is any.
    // It must only be called after stream.CloseAndRecv has returned, or
    // stream.Recv has returned a non-nil error (including io.EOF).
    Trailer() metadata.MD
    // CloseSend closes the send direction of the stream. It closes the stream
    // when non-nil error is met. It is also not safe to call CloseSend
    // concurrently with SendMsg.
    CloseSend() error
    // Context returns the context for this stream.
    //
    // It should not be called until after Header or RecvMsg has returned. Once
    // called, subsequent client-side retries are disabled.
    Context() context.Context
    // SendMsg is generally called by generated code. On error, SendMsg aborts
    // the stream. If the error was generated by the client, the status is
    // returned directly; otherwise, io.EOF is returned and the status of
    // the stream may be discovered using RecvMsg.
    //
    // SendMsg blocks until:
    //   - There is sufficient flow control to schedule m with the transport, or
    //   - The stream is done, or
    //   - The stream breaks.
    //
    // SendMsg does not wait until the message is received by the server. An
    // untimely stream closure may result in lost messages. To ensure delivery,
    // users should ensure the RPC completed successfully using RecvMsg.
    //
    // It is safe to have a goroutine calling SendMsg and another goroutine
    // calling RecvMsg on the same stream at the same time, but it is not safe
    // to call SendMsg on the same stream in different goroutines. It is also
    // not safe to call CloseSend concurrently with SendMsg.
    SendMsg(m interface{}) error
    // RecvMsg blocks until it receives a message into m or the stream is
    // done. It returns io.EOF when the stream completes successfully. On
    // any other error, the stream is aborted and the error contains the RPC
    // status.
    //
    // It is safe to have a goroutine calling SendMsg and another goroutine
    // calling RecvMsg on the same stream at the same time, but it is not
    // safe to call RecvMsg on the same stream in different goroutines.
    RecvMsg(m interface{}) error
}
```

## type ConfigSelector

ConfigSelector controls what configuration to use for every RPC.

```go
type ConfigSelector interface {
    // Selects the configuration for the RPC, or terminates it using the error.
    // This error will be converted by the gRPC library to a status error with
    // code UNKNOWN if it is not returned as a status error.
    SelectConfig(RPCInfo) (*RPCConfig, error)
}
```

### func GetConfigSelector

```go
func GetConfigSelector(state resolver.State) ConfigSelector
```

GetConfigSelector retrieves the config selector from state, if present, and returns it or nil if absent.

## type RPCConfig

RPCConfig describes the configuration to use for each RPC.

```go
type RPCConfig struct {
    // The context to use for the remainder of the RPC; can pass info to LB
    // policy or affect timeout or metadata.
    Context      context.Context
    MethodConfig serviceconfig.MethodConfig // configuration to use for this RPC
    OnCommitted  func()                     // Called when the RPC has been committed (retries no longer possible)
    Interceptor  ClientInterceptor
}
```

## type RPCInfo

RPCInfo contains RPC information needed by a ConfigSelector.

```go
type RPCInfo struct {
    // Context is the user's context for the RPC and contains headers and
    // application timeout.  It is passed for interception purposes and for
    // efficiency reasons.  SelectConfig should not be blocking.
    Context context.Context
    Method  string // i.e. "/Service/Method"
}
```

## type SafeConfigSelector

SafeConfigSelector allows for safe switching of ConfigSelector implementations such that previous values are guaranteed to not be in use when UpdateConfigSelector returns.

```go
type SafeConfigSelector struct {
    // contains filtered or unexported fields
}
```

### func \(\*SafeConfigSelector\) SelectConfig

```go
func (scs *SafeConfigSelector) SelectConfig(r RPCInfo) (*RPCConfig, error)
```

SelectConfig defers to the current ConfigSelector in scs.

### func \(\*SafeConfigSelector\) UpdateConfigSelector

```go
func (scs *SafeConfigSelector) UpdateConfigSelector(cs ConfigSelector)
```

UpdateConfigSelector swaps to the provided ConfigSelector and blocks until all uses of the previous ConfigSelector have completed.

## type ServerInterceptor

ServerInterceptor is an interceptor for incoming RPC's on gRPC server side.

```go
type ServerInterceptor interface {
    // AllowRPC checks if an incoming RPC is allowed to proceed based on
    // information about connection RPC was received on, and HTTP Headers. This
    // information will be piped into context.
    AllowRPC(ctx context.Context) error // TODO: Make this a real interceptor for filters such as rate limiting.
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
