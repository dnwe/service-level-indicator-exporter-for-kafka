<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# durationpb

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/google.golang.org/protobuf/types/known/durationpb"
```

Package durationpb contains generated types for google/protobuf/duration.proto.

The Duration message represents a signed span of time.

### Conversion to a Go Duration

The AsDuration method can be used to convert a Duration message to a standard Go time.Duration value:

```
d := dur.AsDuration()
... // make use of d as a time.Duration
```

Converting to a time.Duration is a common operation so that the extensive set of time\-based operations provided by the time package can be leveraged. See https://golang.org/pkg/time for more information.

The AsDuration method performs the conversion on a best\-effort basis. Durations with denormal values \(e.g., nanoseconds beyond \-99999999 and \+99999999, inclusive; or seconds and nanoseconds with opposite signs\) are normalized during the conversion to a time.Duration. To manually check for invalid Duration per the documented limitations in duration.proto, additionally call the CheckValid method:

```
if err := dur.CheckValid(); err != nil {
	... // handle error
}
```

Note that the documented limitations in duration.proto does not protect a Duration from overflowing the representable range of a time.Duration in Go. The AsDuration method uses saturation arithmetic such that an overflow clamps the resulting value to the closest representable value \(e.g., math.MaxInt64 for positive overflow and math.MinInt64 for negative overflow\).

### Conversion from a Go Duration

The durationpb.New function can be used to construct a Duration message from a standard Go time.Duration value:

```
dur := durationpb.New(d)
... // make use of d as a *durationpb.Duration
```

## Index

- [Variables](<#variables>)
- [type Duration](<#type-duration>)
  - [func New(d time.Duration) *Duration](<#func-new>)
  - [func (x *Duration) AsDuration() time.Duration](<#func-duration-asduration>)
  - [func (x *Duration) CheckValid() error](<#func-duration-checkvalid>)
  - [func (*Duration) Descriptor() ([]byte, []int)](<#func-duration-descriptor>)
  - [func (x *Duration) GetNanos() int32](<#func-duration-getnanos>)
  - [func (x *Duration) GetSeconds() int64](<#func-duration-getseconds>)
  - [func (x *Duration) IsValid() bool](<#func-duration-isvalid>)
  - [func (*Duration) ProtoMessage()](<#func-duration-protomessage>)
  - [func (x *Duration) ProtoReflect() protoreflect.Message](<#func-duration-protoreflect>)
  - [func (x *Duration) Reset()](<#func-duration-reset>)
  - [func (x *Duration) String() string](<#func-duration-string>)


## Variables

```go
var File_google_protobuf_duration_proto protoreflect.FileDescriptor
```

## type Duration

A Duration represents a signed, fixed\-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately \+\-10,000 years.

\# Examples

Example 1: Compute Duration from two Timestamps in pseudo code.

```
Timestamp start = ...;
Timestamp end = ...;
Duration duration = ...;

duration.seconds = end.seconds - start.seconds;
duration.nanos = end.nanos - start.nanos;

if (duration.seconds < 0 && duration.nanos > 0) {
  duration.seconds += 1;
  duration.nanos -= 1000000000;
} else if (duration.seconds > 0 && duration.nanos < 0) {
  duration.seconds -= 1;
  duration.nanos += 1000000000;
}
```

Example 2: Compute Timestamp from Timestamp \+ Duration in pseudo code.

```
Timestamp start = ...;
Duration duration = ...;
Timestamp end = ...;

end.seconds = start.seconds + duration.seconds;
end.nanos = start.nanos + duration.nanos;

if (end.nanos < 0) {
  end.seconds -= 1;
  end.nanos += 1000000000;
} else if (end.nanos >= 1000000000) {
  end.seconds += 1;
  end.nanos -= 1000000000;
}
```

Example 3: Compute Duration from datetime.timedelta in Python.

```
td = datetime.timedelta(days=3, minutes=10)
duration = Duration()
duration.FromTimedelta(td)
```

\# JSON Mapping

In JSON format, the Duration type is encoded as a string rather than an object, where the string ends in the suffix "s" \(indicating seconds\) and is preceded by the number of seconds, with nanoseconds expressed as fractional seconds. For example, 3 seconds with 0 nanoseconds should be encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should be expressed in JSON format as "3.000000001s", and 3 seconds and 1 microsecond should be expressed in JSON format as "3.000001s".

```go
type Duration struct {

    // Signed seconds of the span of time. Must be from -315,576,000,000
    // to +315,576,000,000 inclusive. Note: these bounds are computed from:
    // 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
    // Signed fractions of a second at nanosecond resolution of the span
    // of time. Durations less than one second are represented with a 0
    // `seconds` field and a positive or negative `nanos` field. For durations
    // of one second or more, a non-zero value for the `nanos` field must be
    // of the same sign as the `seconds` field. Must be from -999,999,999
    // to +999,999,999 inclusive.
    Nanos int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
    // contains filtered or unexported fields
}
```

### func New

```go
func New(d time.Duration) *Duration
```

New constructs a new Duration from the provided time.Duration.

### func \(\*Duration\) AsDuration

```go
func (x *Duration) AsDuration() time.Duration
```

AsDuration converts x to a time.Duration, returning the closest duration value in the event of overflow.

### func \(\*Duration\) CheckValid

```go
func (x *Duration) CheckValid() error
```

CheckValid returns an error if the duration is invalid. In particular, it checks whether the value is within the range of \-10000 years to \+10000 years inclusive. An error is reported for a nil Duration.

### func \(\*Duration\) Descriptor

```go
func (*Duration) Descriptor() ([]byte, []int)
```

Deprecated: Use Duration.ProtoReflect.Descriptor instead.

### func \(\*Duration\) GetNanos

```go
func (x *Duration) GetNanos() int32
```

### func \(\*Duration\) GetSeconds

```go
func (x *Duration) GetSeconds() int64
```

### func \(\*Duration\) IsValid

```go
func (x *Duration) IsValid() bool
```

IsValid reports whether the duration is valid. It is equivalent to CheckValid == nil.

### func \(\*Duration\) ProtoMessage

```go
func (*Duration) ProtoMessage()
```

### func \(\*Duration\) ProtoReflect

```go
func (x *Duration) ProtoReflect() protoreflect.Message
```

### func \(\*Duration\) Reset

```go
func (x *Duration) Reset()
```

### func \(\*Duration\) String

```go
func (x *Duration) String() string
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
