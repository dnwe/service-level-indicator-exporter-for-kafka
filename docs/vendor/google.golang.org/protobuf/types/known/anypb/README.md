<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# anypb

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/google.golang.org/protobuf/types/known/anypb"
```

Package anypb contains generated types for google/protobuf/any.proto.

The Any message is a dynamic representation of any other message value. It is functionally a tuple of the full name of the remote message type and the serialized bytes of the remote message value.

### Constructing an Any

An Any message containing another message value is constructed using New:

```
any, err := anypb.New(m)
if err != nil {
	... // handle error
}
... // make use of any
```

### Unmarshaling an Any

With a populated Any message, the underlying message can be serialized into a remote concrete message value in a few ways.

If the exact concrete type is known, then a new \(or pre\-existing\) instance of that message can be passed to the UnmarshalTo method:

```
m := new(foopb.MyMessage)
if err := any.UnmarshalTo(m); err != nil {
	... // handle error
}
... // make use of m
```

If the exact concrete type is not known, then the UnmarshalNew method can be used to unmarshal the contents into a new instance of the remote message type:

```
m, err := any.UnmarshalNew()
if err != nil {
	... // handle error
}
... // make use of m
```

UnmarshalNew uses the global type registry to resolve the message type and construct a new instance of that message to unmarshal into. In order for a message type to appear in the global registry, the Go type representing that protobuf message type must be linked into the Go binary. For messages generated by protoc\-gen\-go, this is achieved through an import of the generated Go package representing a .proto file.

A common pattern with UnmarshalNew is to use a type switch with the resulting proto.Message value:

```
switch m := m.(type) {
case *foopb.MyMessage:
	... // make use of m as a *foopb.MyMessage
case *barpb.OtherMessage:
	... // make use of m as a *barpb.OtherMessage
case *bazpb.SomeMessage:
	... // make use of m as a *bazpb.SomeMessage
}
```

This pattern ensures that the generated packages containing the message types listed in the case clauses are linked into the Go binary and therefore also registered in the global registry.

### Type checking an Any

In order to type check whether an Any message represents some other message, then use the MessageIs method:

```
if any.MessageIs((*foopb.MyMessage)(nil)) {
	... // make use of any, knowing that it contains a foopb.MyMessage
}
```

The MessageIs method can also be used with an allocated instance of the target message type if the intention is to unmarshal into it if the type matches:

```
m := new(foopb.MyMessage)
if any.MessageIs(m) {
	if err := any.UnmarshalTo(m); err != nil {
		... // handle error
	}
	... // make use of m
}
```

## Index

- [Variables](<#variables>)
- [func MarshalFrom(dst *Any, src proto.Message, opts proto.MarshalOptions) error](<#func-marshalfrom>)
- [func UnmarshalNew(src *Any, opts proto.UnmarshalOptions) (dst proto.Message, err error)](<#func-unmarshalnew>)
- [func UnmarshalTo(src *Any, dst proto.Message, opts proto.UnmarshalOptions) error](<#func-unmarshalto>)
- [type Any](<#type-any>)
  - [func New(src proto.Message) (*Any, error)](<#func-new>)
  - [func (*Any) Descriptor() ([]byte, []int)](<#func-any-descriptor>)
  - [func (x *Any) GetTypeUrl() string](<#func-any-gettypeurl>)
  - [func (x *Any) GetValue() []byte](<#func-any-getvalue>)
  - [func (x *Any) MarshalFrom(m proto.Message) error](<#func-any-marshalfrom>)
  - [func (x *Any) MessageIs(m proto.Message) bool](<#func-any-messageis>)
  - [func (x *Any) MessageName() protoreflect.FullName](<#func-any-messagename>)
  - [func (*Any) ProtoMessage()](<#func-any-protomessage>)
  - [func (x *Any) ProtoReflect() protoreflect.Message](<#func-any-protoreflect>)
  - [func (x *Any) Reset()](<#func-any-reset>)
  - [func (x *Any) String() string](<#func-any-string>)
  - [func (x *Any) UnmarshalNew() (proto.Message, error)](<#func-any-unmarshalnew>)
  - [func (x *Any) UnmarshalTo(m proto.Message) error](<#func-any-unmarshalto>)


## Variables

```go
var File_google_protobuf_any_proto protoreflect.FileDescriptor
```

## func MarshalFrom

```go
func MarshalFrom(dst *Any, src proto.Message, opts proto.MarshalOptions) error
```

MarshalFrom marshals src into dst as the underlying message using the provided marshal options.

If no options are specified, call dst.MarshalFrom instead.

## func UnmarshalNew

```go
func UnmarshalNew(src *Any, opts proto.UnmarshalOptions) (dst proto.Message, err error)
```

UnmarshalNew unmarshals the underlying message from src into dst, which is newly created message using a type resolved from the type URL. The message type is resolved according to opt.Resolver, which should implement protoregistry.MessageTypeResolver. It reports an error if the underlying message type could not be resolved.

If no options are specified, call src.UnmarshalNew instead.

## func UnmarshalTo

```go
func UnmarshalTo(src *Any, dst proto.Message, opts proto.UnmarshalOptions) error
```

UnmarshalTo unmarshals the underlying message from src into dst using the provided unmarshal options. It reports an error if dst is not of the right message type.

If no options are specified, call src.UnmarshalTo instead.

## type Any

\`Any\` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C\+\+.

```
Foo foo = ...;
Any any;
any.PackFrom(foo);
...
if (any.UnpackTo(&foo)) {
  ...
}
```

Example 2: Pack and unpack a message in Java.

```
Foo foo = ...;
Any any = Any.pack(foo);
...
if (any.is(Foo.class)) {
  foo = any.unpack(Foo.class);
}
```

Example 3: Pack and unpack a message in Python.

```
foo = Foo(...)
any = Any()
any.Pack(foo)
...
if any.Is(Foo.DESCRIPTOR):
  any.Unpack(foo)
  ...
```

Example 4: Pack and unpack a message in Go

```
foo := &pb.Foo{...}
any, err := anypb.New(foo)
if err != nil {
  ...
}
...
foo := &pb.Foo{}
if err := any.UnmarshalTo(foo); err != nil {
  ...
}
```

The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z".

JSON ==== The JSON representation of an \`Any\` value uses the regular representation of the deserialized, embedded message, with an additional field \`@type\` which contains the type URL. Example:

```
package google.profile;
message Person {
  string first_name = 1;
  string last_name = 2;
}

{
  "@type": "type.googleapis.com/google.profile.Person",
  "firstName": <string>,
  "lastName": <string>
}
```

If the embedded message type is well\-known and has a custom JSON representation, that representation will be embedded adding a field \`value\` which holds the custom JSON in addition to the \`@type\` field. Example \(for message \[google.protobuf.Duration\]\[\]\):

```
{
  "@type": "type.googleapis.com/google.protobuf.Duration",
  "value": "1.212s"
}
```

```go
type Any struct {

    // A URL/resource name that uniquely identifies the type of the serialized
    // protocol buffer message. This string must contain at least
    // one "/" character. The last segment of the URL's path must represent
    // the fully qualified name of the type (as in
    // `path/google.protobuf.Duration`). The name should be in a canonical form
    // (e.g., leading "." is not accepted).
    //
    // In practice, teams usually precompile into the binary all types that they
    // expect it to use in the context of Any. However, for URLs which use the
    // scheme `http`, `https`, or no scheme, one can optionally set up a type
    // server that maps type URLs to message definitions as follows:
    //
    // * If no scheme is provided, `https` is assumed.
    // * An HTTP GET on the URL must yield a [google.protobuf.Type][]
    //   value in binary format, or produce an error.
    // * Applications are allowed to cache lookup results based on the
    //   URL, or have them precompiled into a binary to avoid any
    //   lookup. Therefore, binary compatibility needs to be preserved
    //   on changes to types. (Use versioned type names to manage
    //   breaking changes.)
    //
    // Note: this functionality is not currently available in the official
    // protobuf release, and it is not used for type URLs beginning with
    // type.googleapis.com.
    //
    // Schemes other than `http`, `https` (or the empty scheme) might be
    // used with implementation specific semantics.
    //
    TypeUrl string `protobuf:"bytes,1,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
    // Must be a valid serialized protocol buffer of the above specified type.
    Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
    // contains filtered or unexported fields
}
```

### func New

```go
func New(src proto.Message) (*Any, error)
```

New marshals src into a new Any instance.

### func \(\*Any\) Descriptor

```go
func (*Any) Descriptor() ([]byte, []int)
```

Deprecated: Use Any.ProtoReflect.Descriptor instead.

### func \(\*Any\) GetTypeUrl

```go
func (x *Any) GetTypeUrl() string
```

### func \(\*Any\) GetValue

```go
func (x *Any) GetValue() []byte
```

### func \(\*Any\) MarshalFrom

```go
func (x *Any) MarshalFrom(m proto.Message) error
```

MarshalFrom marshals m into x as the underlying message.

### func \(\*Any\) MessageIs

```go
func (x *Any) MessageIs(m proto.Message) bool
```

MessageIs reports whether the underlying message is of the same type as m.

### func \(\*Any\) MessageName

```go
func (x *Any) MessageName() protoreflect.FullName
```

MessageName reports the full name of the underlying message, returning an empty string if invalid.

### func \(\*Any\) ProtoMessage

```go
func (*Any) ProtoMessage()
```

### func \(\*Any\) ProtoReflect

```go
func (x *Any) ProtoReflect() protoreflect.Message
```

### func \(\*Any\) Reset

```go
func (x *Any) Reset()
```

### func \(\*Any\) String

```go
func (x *Any) String() string
```

### func \(\*Any\) UnmarshalNew

```go
func (x *Any) UnmarshalNew() (proto.Message, error)
```

UnmarshalNew unmarshals the contents of the underlying message of x into a newly allocated message of the specified type. It reports an error if the underlying message type could not be resolved.

### func \(\*Any\) UnmarshalTo

```go
func (x *Any) UnmarshalTo(m proto.Message) error
```

UnmarshalTo unmarshals the contents of the underlying message of x into m. It resets m before performing the unmarshal operation. It reports an error if m is not of the right message type.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
