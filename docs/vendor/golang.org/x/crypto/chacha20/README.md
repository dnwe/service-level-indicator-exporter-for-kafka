<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# chacha20

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/golang.org/x/crypto/chacha20"
```

Package chacha20 implements the ChaCha20 and XChaCha20 encryption algorithms as specified in RFC 8439 and draft\-irtf\-cfrg\-xchacha\-01.

## Index

- [Constants](<#constants>)
- [func HChaCha20(key, nonce []byte) ([]byte, error)](<#func-hchacha20>)
- [type Cipher](<#type-cipher>)
  - [func NewUnauthenticatedCipher(key, nonce []byte) (*Cipher, error)](<#func-newunauthenticatedcipher>)
  - [func (s *Cipher) SetCounter(counter uint32)](<#func-cipher-setcounter>)
  - [func (s *Cipher) XORKeyStream(dst, src []byte)](<#func-cipher-xorkeystream>)


## Constants

```go
const (
    // KeySize is the size of the key used by this cipher, in bytes.
    KeySize = 32

    // NonceSize is the size of the nonce used with the standard variant of this
    // cipher, in bytes.
    //
    // Note that this is too short to be safely generated at random if the same
    // key is reused more than 2³² times.
    NonceSize = 12

    // NonceSizeX is the size of the nonce used with the XChaCha20 variant of
    // this cipher, in bytes.
    NonceSizeX = 24
)
```

## func HChaCha20

```go
func HChaCha20(key, nonce []byte) ([]byte, error)
```

HChaCha20 uses the ChaCha20 core to generate a derived key from a 32 bytes key and a 16 bytes nonce. It returns an error if key or nonce have any other length. It is used as part of the XChaCha20 construction.

## type Cipher

Cipher is a stateful instance of ChaCha20 or XChaCha20 using a particular key and nonce. A \*Cipher implements the cipher.Stream interface.

```go
type Cipher struct {
    // contains filtered or unexported fields
}
```

### func NewUnauthenticatedCipher

```go
func NewUnauthenticatedCipher(key, nonce []byte) (*Cipher, error)
```

NewUnauthenticatedCipher creates a new ChaCha20 stream cipher with the given 32 bytes key and a 12 or 24 bytes nonce. If a nonce of 24 bytes is provided, the XChaCha20 construction will be used. It returns an error if key or nonce have any other length.

Note that ChaCha20, like all stream ciphers, is not authenticated and allows attackers to silently tamper with the plaintext. For this reason, it is more appropriate as a building block than as a standalone encryption mechanism. Instead, consider using package golang.org/x/crypto/chacha20poly1305.

### func \(\*Cipher\) SetCounter

```go
func (s *Cipher) SetCounter(counter uint32)
```

SetCounter sets the Cipher counter. The next invocation of XORKeyStream will behave as if \(64 \* counter\) bytes had been encrypted so far.

To prevent accidental counter reuse, SetCounter panics if counter is less than the current value.

Note that the execution time of XORKeyStream is not independent of the counter value.

### func \(\*Cipher\) XORKeyStream

```go
func (s *Cipher) XORKeyStream(dst, src []byte)
```

XORKeyStream XORs each byte in the given slice with a byte from the cipher's key stream. Dst and src must overlap entirely or not at all.

If len\(dst\) \< len\(src\), XORKeyStream will panic. It is acceptable to pass a dst bigger than src, and in that case, XORKeyStream will only update dst\[:len\(src\)\] and will not touch the rest of dst.

Multiple calls to XORKeyStream behave as if the concatenation of the src buffers was passed in a single run. That is, Cipher maintains state and does not reset at each XORKeyStream call.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
