<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# http2

```go
import "golang.org/x/net/http2"
```

Package http2 implements the HTTP/2 protocol.

This package is low\-level and intended to be used directly by very few people. Most users will use it indirectly through the automatic use by the net/http package \(from Go 1.6 and later\). For use in earlier Go versions see ConfigureServer. \(Transport support requires Go 1.6 or later\)

See https://http2.github.io/ for more information on HTTP/2.

See https://http2.golang.org/ for a test server running this code.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func ConfigureServer(s *http.Server, conf *Server) error](<#func-configureserver>)
- [func ConfigureTransport(t1 *http.Transport) error](<#func-configuretransport>)
- [func ConfigureTransports(t1 *http.Transport) (*Transport, error)](<#func-configuretransports>)
- [func ReadFrameHeader(r io.Reader) (FrameHeader, error)](<#func-readframeheader>)
- [type ClientConn](<#type-clientconn>)
  - [func (cc *ClientConn) CanTakeNewRequest() bool](<#func-clientconn-cantakenewrequest>)
  - [func (cc *ClientConn) Close() error](<#func-clientconn-close>)
  - [func (cc *ClientConn) Ping(ctx context.Context) error](<#func-clientconn-ping>)
  - [func (cc *ClientConn) ReserveNewRequest() bool](<#func-clientconn-reservenewrequest>)
  - [func (cc *ClientConn) RoundTrip(req *http.Request) (*http.Response, error)](<#func-clientconn-roundtrip>)
  - [func (cc *ClientConn) SetDoNotReuse()](<#func-clientconn-setdonotreuse>)
  - [func (cc *ClientConn) Shutdown(ctx context.Context) error](<#func-clientconn-shutdown>)
  - [func (cc *ClientConn) State() ClientConnState](<#func-clientconn-state>)
- [type ClientConnPool](<#type-clientconnpool>)
- [type ClientConnState](<#type-clientconnstate>)
- [type ConnectionError](<#type-connectionerror>)
  - [func (e ConnectionError) Error() string](<#func-connectionerror-error>)
- [type ContinuationFrame](<#type-continuationframe>)
  - [func (f *ContinuationFrame) HeaderBlockFragment() []byte](<#func-continuationframe-headerblockfragment>)
  - [func (f *ContinuationFrame) HeadersEnded() bool](<#func-continuationframe-headersended>)
- [type DataFrame](<#type-dataframe>)
  - [func (f *DataFrame) Data() []byte](<#func-dataframe-data>)
  - [func (f *DataFrame) StreamEnded() bool](<#func-dataframe-streamended>)
- [type ErrCode](<#type-errcode>)
  - [func (e ErrCode) String() string](<#func-errcode-string>)
- [type Flags](<#type-flags>)
  - [func (f Flags) Has(v Flags) bool](<#func-flags-has>)
- [type Frame](<#type-frame>)
- [type FrameHeader](<#type-frameheader>)
  - [func (h FrameHeader) Header() FrameHeader](<#func-frameheader-header>)
  - [func (h FrameHeader) String() string](<#func-frameheader-string>)
- [type FrameType](<#type-frametype>)
  - [func (t FrameType) String() string](<#func-frametype-string>)
- [type FrameWriteRequest](<#type-framewriterequest>)
  - [func (wr FrameWriteRequest) Consume(n int32) (FrameWriteRequest, FrameWriteRequest, int)](<#func-framewriterequest-consume>)
  - [func (wr FrameWriteRequest) DataSize() int](<#func-framewriterequest-datasize>)
  - [func (wr FrameWriteRequest) StreamID() uint32](<#func-framewriterequest-streamid>)
  - [func (wr FrameWriteRequest) String() string](<#func-framewriterequest-string>)
- [type Framer](<#type-framer>)
  - [func NewFramer(w io.Writer, r io.Reader) *Framer](<#func-newframer>)
  - [func (fr *Framer) ErrorDetail() error](<#func-framer-errordetail>)
  - [func (fr *Framer) ReadFrame() (Frame, error)](<#func-framer-readframe>)
  - [func (fr *Framer) SetMaxReadFrameSize(v uint32)](<#func-framer-setmaxreadframesize>)
  - [func (fr *Framer) SetReuseFrames()](<#func-framer-setreuseframes>)
  - [func (f *Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error](<#func-framer-writecontinuation>)
  - [func (f *Framer) WriteData(streamID uint32, endStream bool, data []byte) error](<#func-framer-writedata>)
  - [func (f *Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error](<#func-framer-writedatapadded>)
  - [func (f *Framer) WriteGoAway(maxStreamID uint32, code ErrCode, debugData []byte) error](<#func-framer-writegoaway>)
  - [func (f *Framer) WriteHeaders(p HeadersFrameParam) error](<#func-framer-writeheaders>)
  - [func (f *Framer) WritePing(ack bool, data [8]byte) error](<#func-framer-writeping>)
  - [func (f *Framer) WritePriority(streamID uint32, p PriorityParam) error](<#func-framer-writepriority>)
  - [func (f *Framer) WritePushPromise(p PushPromiseParam) error](<#func-framer-writepushpromise>)
  - [func (f *Framer) WriteRSTStream(streamID uint32, code ErrCode) error](<#func-framer-writerststream>)
  - [func (f *Framer) WriteRawFrame(t FrameType, flags Flags, streamID uint32, payload []byte) error](<#func-framer-writerawframe>)
  - [func (f *Framer) WriteSettings(settings ...Setting) error](<#func-framer-writesettings>)
  - [func (f *Framer) WriteSettingsAck() error](<#func-framer-writesettingsack>)
  - [func (f *Framer) WriteWindowUpdate(streamID, incr uint32) error](<#func-framer-writewindowupdate>)
- [type GoAwayError](<#type-goawayerror>)
  - [func (e GoAwayError) Error() string](<#func-goawayerror-error>)
- [type GoAwayFrame](<#type-goawayframe>)
  - [func (f *GoAwayFrame) DebugData() []byte](<#func-goawayframe-debugdata>)
- [type HeadersFrame](<#type-headersframe>)
  - [func (f *HeadersFrame) HasPriority() bool](<#func-headersframe-haspriority>)
  - [func (f *HeadersFrame) HeaderBlockFragment() []byte](<#func-headersframe-headerblockfragment>)
  - [func (f *HeadersFrame) HeadersEnded() bool](<#func-headersframe-headersended>)
  - [func (f *HeadersFrame) StreamEnded() bool](<#func-headersframe-streamended>)
- [type HeadersFrameParam](<#type-headersframeparam>)
- [type MetaHeadersFrame](<#type-metaheadersframe>)
  - [func (mh *MetaHeadersFrame) PseudoFields() []hpack.HeaderField](<#func-metaheadersframe-pseudofields>)
  - [func (mh *MetaHeadersFrame) PseudoValue(pseudo string) string](<#func-metaheadersframe-pseudovalue>)
  - [func (mh *MetaHeadersFrame) RegularFields() []hpack.HeaderField](<#func-metaheadersframe-regularfields>)
- [type OpenStreamOptions](<#type-openstreamoptions>)
- [type PingFrame](<#type-pingframe>)
  - [func (f *PingFrame) IsAck() bool](<#func-pingframe-isack>)
- [type PriorityFrame](<#type-priorityframe>)
- [type PriorityParam](<#type-priorityparam>)
  - [func (p PriorityParam) IsZero() bool](<#func-priorityparam-iszero>)
- [type PriorityWriteSchedulerConfig](<#type-prioritywriteschedulerconfig>)
- [type PushPromiseFrame](<#type-pushpromiseframe>)
  - [func (f *PushPromiseFrame) HeaderBlockFragment() []byte](<#func-pushpromiseframe-headerblockfragment>)
  - [func (f *PushPromiseFrame) HeadersEnded() bool](<#func-pushpromiseframe-headersended>)
- [type PushPromiseParam](<#type-pushpromiseparam>)
- [type RSTStreamFrame](<#type-rststreamframe>)
- [type RoundTripOpt](<#type-roundtripopt>)
- [type ServeConnOpts](<#type-serveconnopts>)
- [type Server](<#type-server>)
  - [func (s *Server) ServeConn(c net.Conn, opts *ServeConnOpts)](<#func-server-serveconn>)
- [type Setting](<#type-setting>)
  - [func (s Setting) String() string](<#func-setting-string>)
  - [func (s Setting) Valid() error](<#func-setting-valid>)
- [type SettingID](<#type-settingid>)
  - [func (s SettingID) String() string](<#func-settingid-string>)
- [type SettingsFrame](<#type-settingsframe>)
  - [func (f *SettingsFrame) ForeachSetting(fn func(Setting) error) error](<#func-settingsframe-foreachsetting>)
  - [func (f *SettingsFrame) HasDuplicates() bool](<#func-settingsframe-hasduplicates>)
  - [func (f *SettingsFrame) IsAck() bool](<#func-settingsframe-isack>)
  - [func (f *SettingsFrame) NumSettings() int](<#func-settingsframe-numsettings>)
  - [func (f *SettingsFrame) Setting(i int) Setting](<#func-settingsframe-setting>)
  - [func (f *SettingsFrame) Value(id SettingID) (v uint32, ok bool)](<#func-settingsframe-value>)
- [type StreamError](<#type-streamerror>)
  - [func (e StreamError) Error() string](<#func-streamerror-error>)
- [type Transport](<#type-transport>)
  - [func (t *Transport) CloseIdleConnections()](<#func-transport-closeidleconnections>)
  - [func (t *Transport) NewClientConn(c net.Conn) (*ClientConn, error)](<#func-transport-newclientconn>)
  - [func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error)](<#func-transport-roundtrip>)
  - [func (t *Transport) RoundTripOpt(req *http.Request, opt RoundTripOpt) (*http.Response, error)](<#func-transport-roundtripopt>)
- [type UnknownFrame](<#type-unknownframe>)
  - [func (f *UnknownFrame) Payload() []byte](<#func-unknownframe-payload>)
- [type WindowUpdateFrame](<#type-windowupdateframe>)
- [type WriteScheduler](<#type-writescheduler>)
  - [func NewPriorityWriteScheduler(cfg *PriorityWriteSchedulerConfig) WriteScheduler](<#func-newprioritywritescheduler>)
  - [func NewRandomWriteScheduler() WriteScheduler](<#func-newrandomwritescheduler>)


## Constants

```go
const (
    // ClientPreface is the string that must be sent by new
    // connections from clients.
    ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"

    // NextProtoTLS is the NPN/ALPN protocol negotiated during
    // HTTP/2's TLS setup.
    NextProtoTLS = "h2"
)
```

TrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers.

This mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred:

```
https://golang.org/pkg/net/http/#ResponseWriter
https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
```

```go
const TrailerPrefix = "Trailer:"
```

## Variables

Push errors.

```go
var (
    ErrRecursivePush    = errors.New("http2: recursive push not allowed")
    ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS")
)
```

```go
var DebugGoroutines = os.Getenv("DEBUG_HTTP2_GOROUTINES") == "1"
```

ErrFrameTooLarge is returned from Framer.ReadFrame when the peer sends a frame that is larger than declared with SetMaxReadFrameSize.

```go
var ErrFrameTooLarge = errors.New("http2: frame too large")
```

```go
var ErrNoCachedConn error = noCachedConnError{}
```

```go
var (
    VerboseLogs bool
)
```

## func ConfigureServer

```go
func ConfigureServer(s *http.Server, conf *Server) error
```

ConfigureServer adds HTTP/2 support to a net/http Server.

The configuration conf may be nil.

ConfigureServer must be called before s begins serving.

## func ConfigureTransport

```go
func ConfigureTransport(t1 *http.Transport) error
```

ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2. It returns an error if t1 has already been HTTP/2\-enabled.

Use ConfigureTransports instead to configure the HTTP/2 Transport.

## func ConfigureTransports

```go
func ConfigureTransports(t1 *http.Transport) (*Transport, error)
```

ConfigureTransports configures a net/http HTTP/1 Transport to use HTTP/2. It returns a new HTTP/2 Transport for further configuration. It returns an error if t1 has already been HTTP/2\-enabled.

## func ReadFrameHeader

```go
func ReadFrameHeader(r io.Reader) (FrameHeader, error)
```

ReadFrameHeader reads 9 bytes from r and returns a FrameHeader. Most users should use Framer.ReadFrame instead.

## type ClientConn

ClientConn is the state of a single HTTP/2 client connection to an HTTP/2 server.

```go
type ClientConn struct {
    // contains filtered or unexported fields
}
```

### func \(\*ClientConn\) CanTakeNewRequest

```go
func (cc *ClientConn) CanTakeNewRequest() bool
```

CanTakeNewRequest reports whether the connection can take a new request, meaning it has not been closed or received or sent a GOAWAY.

If the caller is going to immediately make a new request on this connection, use ReserveNewRequest instead.

### func \(\*ClientConn\) Close

```go
func (cc *ClientConn) Close() error
```

Close closes the client connection immediately.

In\-flight requests are interrupted. For a graceful shutdown, use Shutdown instead.

### func \(\*ClientConn\) Ping

```go
func (cc *ClientConn) Ping(ctx context.Context) error
```

Ping sends a PING frame to the server and waits for the ack.

### func \(\*ClientConn\) ReserveNewRequest

```go
func (cc *ClientConn) ReserveNewRequest() bool
```

ReserveNewRequest is like CanTakeNewRequest but also reserves a concurrent stream in cc. The reservation is decremented on the next call to RoundTrip.

### func \(\*ClientConn\) RoundTrip

```go
func (cc *ClientConn) RoundTrip(req *http.Request) (*http.Response, error)
```

### func \(\*ClientConn\) SetDoNotReuse

```go
func (cc *ClientConn) SetDoNotReuse()
```

SetDoNotReuse marks cc as not reusable for future HTTP requests.

### func \(\*ClientConn\) Shutdown

```go
func (cc *ClientConn) Shutdown(ctx context.Context) error
```

Shutdown gracefully closes the client connection, waiting for running streams to complete.

### func \(\*ClientConn\) State

```go
func (cc *ClientConn) State() ClientConnState
```

State returns a snapshot of cc's state.

## type ClientConnPool

ClientConnPool manages a pool of HTTP/2 client connections.

```go
type ClientConnPool interface {
    // GetClientConn returns a specific HTTP/2 connection (usually
    // a TLS-TCP connection) to an HTTP/2 server. On success, the
    // returned ClientConn accounts for the upcoming RoundTrip
    // call, so the caller should not omit it. If the caller needs
    // to, ClientConn.RoundTrip can be called with a bogus
    // new(http.Request) to release the stream reservation.
    GetClientConn(req *http.Request, addr string) (*ClientConn, error)
    MarkDead(*ClientConn)
}
```

## type ClientConnState

ClientConnState describes the state of a ClientConn.

```go
type ClientConnState struct {
    // Closed is whether the connection is closed.
    Closed bool

    // Closing is whether the connection is in the process of
    // closing. It may be closing due to shutdown, being a
    // single-use connection, being marked as DoNotReuse, or
    // having received a GOAWAY frame.
    Closing bool

    // StreamsActive is how many streams are active.
    StreamsActive int

    // StreamsReserved is how many streams have been reserved via
    // ClientConn.ReserveNewRequest.
    StreamsReserved int

    // StreamsPending is how many requests have been sent in excess
    // of the peer's advertised MaxConcurrentStreams setting and
    // are waiting for other streams to complete.
    StreamsPending int

    // MaxConcurrentStreams is how many concurrent streams the
    // peer advertised as acceptable. Zero means no SETTINGS
    // frame has been received yet.
    MaxConcurrentStreams uint32

    // LastIdle, if non-zero, is when the connection last
    // transitioned to idle state.
    LastIdle time.Time
}
```

## type ConnectionError

ConnectionError is an error that results in the termination of the entire connection.

```go
type ConnectionError ErrCode
```

### func \(ConnectionError\) Error

```go
func (e ConnectionError) Error() string
```

## type ContinuationFrame

A ContinuationFrame is used to continue a sequence of header block fragments. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.10

```go
type ContinuationFrame struct {
    FrameHeader
    // contains filtered or unexported fields
}
```

### func \(\*ContinuationFrame\) HeaderBlockFragment

```go
func (f *ContinuationFrame) HeaderBlockFragment() []byte
```

### func \(\*ContinuationFrame\) HeadersEnded

```go
func (f *ContinuationFrame) HeadersEnded() bool
```

## type DataFrame

A DataFrame conveys arbitrary, variable\-length sequences of octets associated with a stream. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.1

```go
type DataFrame struct {
    FrameHeader
    // contains filtered or unexported fields
}
```

### func \(\*DataFrame\) Data

```go
func (f *DataFrame) Data() []byte
```

Data returns the frame's data octets, not including any padding size byte or padding suffix bytes. The caller must not retain the returned memory past the next call to ReadFrame.

### func \(\*DataFrame\) StreamEnded

```go
func (f *DataFrame) StreamEnded() bool
```

## type ErrCode

An ErrCode is an unsigned 32\-bit error code as defined in the HTTP/2 spec.

```go
type ErrCode uint32
```

```go
const (
    ErrCodeNo                 ErrCode = 0x0
    ErrCodeProtocol           ErrCode = 0x1
    ErrCodeInternal           ErrCode = 0x2
    ErrCodeFlowControl        ErrCode = 0x3
    ErrCodeSettingsTimeout    ErrCode = 0x4
    ErrCodeStreamClosed       ErrCode = 0x5
    ErrCodeFrameSize          ErrCode = 0x6
    ErrCodeRefusedStream      ErrCode = 0x7
    ErrCodeCancel             ErrCode = 0x8
    ErrCodeCompression        ErrCode = 0x9
    ErrCodeConnect            ErrCode = 0xa
    ErrCodeEnhanceYourCalm    ErrCode = 0xb
    ErrCodeInadequateSecurity ErrCode = 0xc
    ErrCodeHTTP11Required     ErrCode = 0xd
)
```

### func \(ErrCode\) String

```go
func (e ErrCode) String() string
```

## type Flags

Flags is a bitmask of HTTP/2 flags. The meaning of flags varies depending on the frame type.

```go
type Flags uint8
```

Frame\-specific FrameHeader flag bits.

```go
const (
    // Data Frame
    FlagDataEndStream Flags = 0x1
    FlagDataPadded    Flags = 0x8

    // Headers Frame
    FlagHeadersEndStream  Flags = 0x1
    FlagHeadersEndHeaders Flags = 0x4
    FlagHeadersPadded     Flags = 0x8
    FlagHeadersPriority   Flags = 0x20

    // Settings Frame
    FlagSettingsAck Flags = 0x1

    // Ping Frame
    FlagPingAck Flags = 0x1

    // Continuation Frame
    FlagContinuationEndHeaders Flags = 0x4

    FlagPushPromiseEndHeaders Flags = 0x4
    FlagPushPromisePadded     Flags = 0x8
)
```

### func \(Flags\) Has

```go
func (f Flags) Has(v Flags) bool
```

Has reports whether f contains all \(0 or more\) flags in v.

## type Frame

A Frame is the base interface implemented by all frame types. Callers will generally type\-assert the specific frame type: \*HeadersFrame, \*SettingsFrame, \*WindowUpdateFrame, etc.

Frames are only valid until the next call to Framer.ReadFrame.

```go
type Frame interface {
    Header() FrameHeader
    // contains filtered or unexported methods
}
```

## type FrameHeader

A FrameHeader is the 9 byte header of all HTTP/2 frames.

See https://httpwg.org/specs/rfc7540.html#FrameHeader

```go
type FrameHeader struct {

    // Type is the 1 byte frame type. There are ten standard frame
    // types, but extension frame types may be written by WriteRawFrame
    // and will be returned by ReadFrame (as UnknownFrame).
    Type FrameType

    // Flags are the 1 byte of 8 potential bit flags per frame.
    // They are specific to the frame type.
    Flags Flags

    // Length is the length of the frame, not including the 9 byte header.
    // The maximum size is one byte less than 16MB (uint24), but only
    // frames up to 16KB are allowed without peer agreement.
    Length uint32

    // StreamID is which stream this frame is for. Certain frames
    // are not stream-specific, in which case this field is 0.
    StreamID uint32
    // contains filtered or unexported fields
}
```

### func \(FrameHeader\) Header

```go
func (h FrameHeader) Header() FrameHeader
```

Header returns h. It exists so FrameHeaders can be embedded in other specific frame types and implement the Frame interface.

### func \(FrameHeader\) String

```go
func (h FrameHeader) String() string
```

## type FrameType

A FrameType is a registered frame type as defined in https://httpwg.org/specs/rfc7540.html#rfc.section.11.2

```go
type FrameType uint8
```

```go
const (
    FrameData         FrameType = 0x0
    FrameHeaders      FrameType = 0x1
    FramePriority     FrameType = 0x2
    FrameRSTStream    FrameType = 0x3
    FrameSettings     FrameType = 0x4
    FramePushPromise  FrameType = 0x5
    FramePing         FrameType = 0x6
    FrameGoAway       FrameType = 0x7
    FrameWindowUpdate FrameType = 0x8
    FrameContinuation FrameType = 0x9
)
```

### func \(FrameType\) String

```go
func (t FrameType) String() string
```

## type FrameWriteRequest

FrameWriteRequest is a request to write a frame.

```go
type FrameWriteRequest struct {
    // contains filtered or unexported fields
}
```

### func \(FrameWriteRequest\) Consume

```go
func (wr FrameWriteRequest) Consume(n int32) (FrameWriteRequest, FrameWriteRequest, int)
```

Consume consumes min\(n, available\) bytes from this frame, where available is the number of flow control bytes available on the stream. Consume returns 0, 1, or 2 frames, where the integer return value gives the number of frames returned.

If flow control prevents consuming any bytes, this returns \(\_, \_, 0\). If the entire frame was consumed, this returns \(wr, \_, 1\). Otherwise, this returns \(consumed, rest, 2\), where 'consumed' contains the consumed bytes and 'rest' contains the remaining bytes. The consumed bytes are deducted from the underlying stream's flow control budget.

### func \(FrameWriteRequest\) DataSize

```go
func (wr FrameWriteRequest) DataSize() int
```

DataSize returns the number of flow control bytes that must be consumed to write this entire frame. This is 0 for non\-DATA frames.

### func \(FrameWriteRequest\) StreamID

```go
func (wr FrameWriteRequest) StreamID() uint32
```

StreamID returns the id of the stream this frame will be written to. 0 is used for non\-stream frames such as PING and SETTINGS.

### func \(FrameWriteRequest\) String

```go
func (wr FrameWriteRequest) String() string
```

String is for debugging only.

## type Framer

A Framer reads and writes Frames.

```go
type Framer struct {

    // AllowIllegalWrites permits the Framer's Write methods to
    // write frames that do not conform to the HTTP/2 spec. This
    // permits using the Framer to test other HTTP/2
    // implementations' conformance to the spec.
    // If false, the Write methods will prefer to return an error
    // rather than comply.
    AllowIllegalWrites bool

    // AllowIllegalReads permits the Framer's ReadFrame method
    // to return non-compliant frames or frame orders.
    // This is for testing and permits using the Framer to test
    // other HTTP/2 implementations' conformance to the spec.
    // It is not compatible with ReadMetaHeaders.
    AllowIllegalReads bool

    // ReadMetaHeaders if non-nil causes ReadFrame to merge
    // HEADERS and CONTINUATION frames together and return
    // MetaHeadersFrame instead.
    ReadMetaHeaders *hpack.Decoder

    // MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
    // It's used only if ReadMetaHeaders is set; 0 means a sane default
    // (currently 16MB)
    // If the limit is hit, MetaHeadersFrame.Truncated is set true.
    MaxHeaderListSize uint32
    // contains filtered or unexported fields
}
```

### func NewFramer

```go
func NewFramer(w io.Writer, r io.Reader) *Framer
```

NewFramer returns a Framer that writes frames to w and reads them from r.

### func \(\*Framer\) ErrorDetail

```go
func (fr *Framer) ErrorDetail() error
```

ErrorDetail returns a more detailed error of the last error returned by Framer.ReadFrame. For instance, if ReadFrame returns a StreamError with code PROTOCOL\_ERROR, ErrorDetail will say exactly what was invalid. ErrorDetail is not guaranteed to return a non\-nil value and like the rest of the http2 package, its return value is not protected by an API compatibility promise. ErrorDetail is reset after the next call to ReadFrame.

### func \(\*Framer\) ReadFrame

```go
func (fr *Framer) ReadFrame() (Frame, error)
```

ReadFrame reads a single frame. The returned Frame is only valid until the next call to ReadFrame.

If the frame is larger than previously set with SetMaxReadFrameSize, the returned error is ErrFrameTooLarge. Other errors may be of type ConnectionError, StreamError, or anything else from the underlying reader.

### func \(\*Framer\) SetMaxReadFrameSize

```go
func (fr *Framer) SetMaxReadFrameSize(v uint32)
```

SetMaxReadFrameSize sets the maximum size of a frame that will be read by a subsequent call to ReadFrame. It is the caller's responsibility to advertise this limit with a SETTINGS frame.

### func \(\*Framer\) SetReuseFrames

```go
func (fr *Framer) SetReuseFrames()
```

SetReuseFrames allows the Framer to reuse Frames. If called on a Framer, Frames returned by calls to ReadFrame are only valid until the next call to ReadFrame.

### func \(\*Framer\) WriteContinuation

```go
func (f *Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error
```

WriteContinuation writes a CONTINUATION frame.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently.

### func \(\*Framer\) WriteData

```go
func (f *Framer) WriteData(streamID uint32, endStream bool, data []byte) error
```

WriteData writes a DATA frame.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility not to violate the maximum frame size and to not call other Write methods concurrently.

### func \(\*Framer\) WriteDataPadded

```go
func (f *Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error
```

WriteDataPadded writes a DATA frame with optional padding.

If pad is nil, the padding bit is not sent. The length of pad must not exceed 255 bytes. The bytes of pad must all be zero, unless f.AllowIllegalWrites is set.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility not to violate the maximum frame size and to not call other Write methods concurrently.

### func \(\*Framer\) WriteGoAway

```go
func (f *Framer) WriteGoAway(maxStreamID uint32, code ErrCode, debugData []byte) error
```

### func \(\*Framer\) WriteHeaders

```go
func (f *Framer) WriteHeaders(p HeadersFrameParam) error
```

WriteHeaders writes a single HEADERS frame.

This is a low\-level header writing method. Encoding headers and splitting them into any necessary CONTINUATION frames is handled elsewhere.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently.

### func \(\*Framer\) WritePing

```go
func (f *Framer) WritePing(ack bool, data [8]byte) error
```

### func \(\*Framer\) WritePriority

```go
func (f *Framer) WritePriority(streamID uint32, p PriorityParam) error
```

WritePriority writes a PRIORITY frame.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently.

### func \(\*Framer\) WritePushPromise

```go
func (f *Framer) WritePushPromise(p PushPromiseParam) error
```

WritePushPromise writes a single PushPromise Frame.

As with Header Frames, This is the low level call for writing individual frames. Continuation frames are handled elsewhere.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently.

### func \(\*Framer\) WriteRSTStream

```go
func (f *Framer) WriteRSTStream(streamID uint32, code ErrCode) error
```

WriteRSTStream writes a RST\_STREAM frame.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently.

### func \(\*Framer\) WriteRawFrame

```go
func (f *Framer) WriteRawFrame(t FrameType, flags Flags, streamID uint32, payload []byte) error
```

WriteRawFrame writes a raw frame. This can be used to write extension frames unknown to this package.

### func \(\*Framer\) WriteSettings

```go
func (f *Framer) WriteSettings(settings ...Setting) error
```

WriteSettings writes a SETTINGS frame with zero or more settings specified and the ACK bit not set.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently.

### func \(\*Framer\) WriteSettingsAck

```go
func (f *Framer) WriteSettingsAck() error
```

WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.

It will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently.

### func \(\*Framer\) WriteWindowUpdate

```go
func (f *Framer) WriteWindowUpdate(streamID, incr uint32) error
```

WriteWindowUpdate writes a WINDOW\_UPDATE frame. The increment value must be between 1 and 2,147,483,647, inclusive. If the Stream ID is zero, the window update applies to the connection as a whole.

## type GoAwayError

GoAwayError is returned by the Transport when the server closes the TCP connection after sending a GOAWAY frame.

```go
type GoAwayError struct {
    LastStreamID uint32
    ErrCode      ErrCode
    DebugData    string
}
```

### func \(GoAwayError\) Error

```go
func (e GoAwayError) Error() string
```

## type GoAwayFrame

A GoAwayFrame informs the remote peer to stop creating streams on this connection. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.8

```go
type GoAwayFrame struct {
    FrameHeader
    LastStreamID uint32
    ErrCode      ErrCode
    // contains filtered or unexported fields
}
```

### func \(\*GoAwayFrame\) DebugData

```go
func (f *GoAwayFrame) DebugData() []byte
```

DebugData returns any debug data in the GOAWAY frame. Its contents are not defined. The caller must not retain the returned memory past the next call to ReadFrame.

## type HeadersFrame

A HeadersFrame is used to open a stream and additionally carries a header block fragment.

```go
type HeadersFrame struct {
    FrameHeader

    // Priority is set if FlagHeadersPriority is set in the FrameHeader.
    Priority PriorityParam
    // contains filtered or unexported fields
}
```

### func \(\*HeadersFrame\) HasPriority

```go
func (f *HeadersFrame) HasPriority() bool
```

### func \(\*HeadersFrame\) HeaderBlockFragment

```go
func (f *HeadersFrame) HeaderBlockFragment() []byte
```

### func \(\*HeadersFrame\) HeadersEnded

```go
func (f *HeadersFrame) HeadersEnded() bool
```

### func \(\*HeadersFrame\) StreamEnded

```go
func (f *HeadersFrame) StreamEnded() bool
```

## type HeadersFrameParam

HeadersFrameParam are the parameters for writing a HEADERS frame.

```go
type HeadersFrameParam struct {
    // StreamID is the required Stream ID to initiate.
    StreamID uint32
    // BlockFragment is part (or all) of a Header Block.
    BlockFragment []byte

    // EndStream indicates that the header block is the last that
    // the endpoint will send for the identified stream. Setting
    // this flag causes the stream to enter one of "half closed"
    // states.
    EndStream bool

    // EndHeaders indicates that this frame contains an entire
    // header block and is not followed by any
    // CONTINUATION frames.
    EndHeaders bool

    // PadLength is the optional number of bytes of zeros to add
    // to this frame.
    PadLength uint8

    // Priority, if non-zero, includes stream priority information
    // in the HEADER frame.
    Priority PriorityParam
}
```

## type MetaHeadersFrame

A MetaHeadersFrame is the representation of one HEADERS frame and zero or more contiguous CONTINUATION frames and the decoding of their HPACK\-encoded contents.

This type of frame does not appear on the wire and is only returned by the Framer when Framer.ReadMetaHeaders is set.

```go
type MetaHeadersFrame struct {
    *HeadersFrame

    // Fields are the fields contained in the HEADERS and
    // CONTINUATION frames. The underlying slice is owned by the
    // Framer and must not be retained after the next call to
    // ReadFrame.
    //
    // Fields are guaranteed to be in the correct http2 order and
    // not have unknown pseudo header fields or invalid header
    // field names or values. Required pseudo header fields may be
    // missing, however. Use the MetaHeadersFrame.Pseudo accessor
    // method access pseudo headers.
    Fields []hpack.HeaderField

    // Truncated is whether the max header list size limit was hit
    // and Fields is incomplete. The hpack decoder state is still
    // valid, however.
    Truncated bool
}
```

### func \(\*MetaHeadersFrame\) PseudoFields

```go
func (mh *MetaHeadersFrame) PseudoFields() []hpack.HeaderField
```

PseudoFields returns the pseudo header fields of mh. The caller does not own the returned slice.

### func \(\*MetaHeadersFrame\) PseudoValue

```go
func (mh *MetaHeadersFrame) PseudoValue(pseudo string) string
```

PseudoValue returns the given pseudo header field's value. The provided pseudo field should not contain the leading colon.

### func \(\*MetaHeadersFrame\) RegularFields

```go
func (mh *MetaHeadersFrame) RegularFields() []hpack.HeaderField
```

RegularFields returns the regular \(non\-pseudo\) header fields of mh. The caller does not own the returned slice.

## type OpenStreamOptions

OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.

```go
type OpenStreamOptions struct {
    // PusherID is zero if the stream was initiated by the client. Otherwise,
    // PusherID names the stream that pushed the newly opened stream.
    PusherID uint32
}
```

## type PingFrame

A PingFrame is a mechanism for measuring a minimal round trip time from the sender, as well as determining whether an idle connection is still functional. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.7

```go
type PingFrame struct {
    FrameHeader
    Data [8]byte
}
```

### func \(\*PingFrame\) IsAck

```go
func (f *PingFrame) IsAck() bool
```

## type PriorityFrame

A PriorityFrame specifies the sender\-advised priority of a stream. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.3

```go
type PriorityFrame struct {
    FrameHeader
    PriorityParam
}
```

## type PriorityParam

PriorityParam are the stream prioritzation parameters.

```go
type PriorityParam struct {
    // StreamDep is a 31-bit stream identifier for the
    // stream that this stream depends on. Zero means no
    // dependency.
    StreamDep uint32

    // Exclusive is whether the dependency is exclusive.
    Exclusive bool

    // Weight is the stream's zero-indexed weight. It should be
    // set together with StreamDep, or neither should be set. Per
    // the spec, "Add one to the value to obtain a weight between
    // 1 and 256."
    Weight uint8
}
```

### func \(PriorityParam\) IsZero

```go
func (p PriorityParam) IsZero() bool
```

## type PriorityWriteSchedulerConfig

PriorityWriteSchedulerConfig configures a priorityWriteScheduler.

```go
type PriorityWriteSchedulerConfig struct {
    // MaxClosedNodesInTree controls the maximum number of closed streams to
    // retain in the priority tree. Setting this to zero saves a small amount
    // of memory at the cost of performance.
    //
    // See RFC 7540, Section 5.3.4:
    //   "It is possible for a stream to become closed while prioritization
    //   information ... is in transit. ... This potentially creates suboptimal
    //   prioritization, since the stream could be given a priority that is
    //   different from what is intended. To avoid these problems, an endpoint
    //   SHOULD retain stream prioritization state for a period after streams
    //   become closed. The longer state is retained, the lower the chance that
    //   streams are assigned incorrect or default priority values."
    MaxClosedNodesInTree int

    // MaxIdleNodesInTree controls the maximum number of idle streams to
    // retain in the priority tree. Setting this to zero saves a small amount
    // of memory at the cost of performance.
    //
    // See RFC 7540, Section 5.3.4:
    //   Similarly, streams that are in the "idle" state can be assigned
    //   priority or become a parent of other streams. This allows for the
    //   creation of a grouping node in the dependency tree, which enables
    //   more flexible expressions of priority. Idle streams begin with a
    //   default priority (Section 5.3.5).
    MaxIdleNodesInTree int

    // ThrottleOutOfOrderWrites enables write throttling to help ensure that
    // data is delivered in priority order. This works around a race where
    // stream B depends on stream A and both streams are about to call Write
    // to queue DATA frames. If B wins the race, a naive scheduler would eagerly
    // write as much data from B as possible, but this is suboptimal because A
    // is a higher-priority stream. With throttling enabled, we write a small
    // amount of data from B to minimize the amount of bandwidth that B can
    // steal from A.
    ThrottleOutOfOrderWrites bool
}
```

## type PushPromiseFrame

A PushPromiseFrame is used to initiate a server stream. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.6

```go
type PushPromiseFrame struct {
    FrameHeader
    PromiseID uint32
    // contains filtered or unexported fields
}
```

### func \(\*PushPromiseFrame\) HeaderBlockFragment

```go
func (f *PushPromiseFrame) HeaderBlockFragment() []byte
```

### func \(\*PushPromiseFrame\) HeadersEnded

```go
func (f *PushPromiseFrame) HeadersEnded() bool
```

## type PushPromiseParam

PushPromiseParam are the parameters for writing a PUSH\_PROMISE frame.

```go
type PushPromiseParam struct {
    // StreamID is the required Stream ID to initiate.
    StreamID uint32

    // PromiseID is the required Stream ID which this
    // Push Promises
    PromiseID uint32

    // BlockFragment is part (or all) of a Header Block.
    BlockFragment []byte

    // EndHeaders indicates that this frame contains an entire
    // header block and is not followed by any
    // CONTINUATION frames.
    EndHeaders bool

    // PadLength is the optional number of bytes of zeros to add
    // to this frame.
    PadLength uint8
}
```

## type RSTStreamFrame

A RSTStreamFrame allows for abnormal termination of a stream. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.4

```go
type RSTStreamFrame struct {
    FrameHeader
    ErrCode ErrCode
}
```

## type RoundTripOpt

RoundTripOpt are options for the Transport.RoundTripOpt method.

```go
type RoundTripOpt struct {
    // OnlyCachedConn controls whether RoundTripOpt may
    // create a new TCP connection. If set true and
    // no cached connection is available, RoundTripOpt
    // will return ErrNoCachedConn.
    OnlyCachedConn bool
}
```

## type ServeConnOpts

ServeConnOpts are options for the Server.ServeConn method.

```go
type ServeConnOpts struct {
    // Context is the base context to use.
    // If nil, context.Background is used.
    Context context.Context

    // BaseConfig optionally sets the base configuration
    // for values. If nil, defaults are used.
    BaseConfig *http.Server

    // Handler specifies which handler to use for processing
    // requests. If nil, BaseConfig.Handler is used. If BaseConfig
    // or BaseConfig.Handler is nil, http.DefaultServeMux is used.
    Handler http.Handler

    // UpgradeRequest is an initial request received on a connection
    // undergoing an h2c upgrade. The request body must have been
    // completely read from the connection before calling ServeConn,
    // and the 101 Switching Protocols response written.
    UpgradeRequest *http.Request

    // Settings is the decoded contents of the HTTP2-Settings header
    // in an h2c upgrade request.
    Settings []byte

    // SawClientPreface is set if the HTTP/2 connection preface
    // has already been read from the connection.
    SawClientPreface bool
}
```

## type Server

Server is an HTTP/2 server.

```go
type Server struct {
    // MaxHandlers limits the number of http.Handler ServeHTTP goroutines
    // which may run at a time over all connections.
    // Negative or zero no limit.
    // TODO: implement
    MaxHandlers int

    // MaxConcurrentStreams optionally specifies the number of
    // concurrent streams that each client may have open at a
    // time. This is unrelated to the number of http.Handler goroutines
    // which may be active globally, which is MaxHandlers.
    // If zero, MaxConcurrentStreams defaults to at least 100, per
    // the HTTP/2 spec's recommendations.
    MaxConcurrentStreams uint32

    // MaxReadFrameSize optionally specifies the largest frame
    // this server is willing to read. A valid value is between
    // 16k and 16M, inclusive. If zero or otherwise invalid, a
    // default value is used.
    MaxReadFrameSize uint32

    // PermitProhibitedCipherSuites, if true, permits the use of
    // cipher suites prohibited by the HTTP/2 spec.
    PermitProhibitedCipherSuites bool

    // IdleTimeout specifies how long until idle clients should be
    // closed with a GOAWAY frame. PING frames are not considered
    // activity for the purposes of IdleTimeout.
    IdleTimeout time.Duration

    // MaxUploadBufferPerConnection is the size of the initial flow
    // control window for each connections. The HTTP/2 spec does not
    // allow this to be smaller than 65535 or larger than 2^32-1.
    // If the value is outside this range, a default value will be
    // used instead.
    MaxUploadBufferPerConnection int32

    // MaxUploadBufferPerStream is the size of the initial flow control
    // window for each stream. The HTTP/2 spec does not allow this to
    // be larger than 2^32-1. If the value is zero or larger than the
    // maximum, a default value will be used instead.
    MaxUploadBufferPerStream int32

    // NewWriteScheduler constructs a write scheduler for a connection.
    // If nil, a default scheduler is chosen.
    NewWriteScheduler func() WriteScheduler

    // CountError, if non-nil, is called on HTTP/2 server errors.
    // It's intended to increment a metric for monitoring, such
    // as an expvar or Prometheus metric.
    // The errType consists of only ASCII word characters.
    CountError func(errType string)
    // contains filtered or unexported fields
}
```

### func \(\*Server\) ServeConn

```go
func (s *Server) ServeConn(c net.Conn, opts *ServeConnOpts)
```

ServeConn serves HTTP/2 requests on the provided connection and blocks until the connection is no longer readable.

ServeConn starts speaking HTTP/2 assuming that c has not had any reads or writes. It writes its initial settings frame and expects to be able to read the preface and settings frame from the client. If c has a ConnectionState method like a \*tls.Conn, the ConnectionState is used to verify the TLS ciphersuite and to set the Request.TLS field in Handlers.

ServeConn does not support h2c by itself. Any h2c support must be implemented in terms of providing a suitably\-behaving net.Conn.

The opts parameter is optional. If nil, default values are used.

## type Setting

Setting is a setting parameter: which setting it is, and its value.

```go
type Setting struct {
    // ID is which setting is being set.
    // See https://httpwg.org/specs/rfc7540.html#SettingFormat
    ID  SettingID

    // Val is the value.
    Val uint32
}
```

### func \(Setting\) String

```go
func (s Setting) String() string
```

### func \(Setting\) Valid

```go
func (s Setting) Valid() error
```

Valid reports whether the setting is valid.

## type SettingID

A SettingID is an HTTP/2 setting as defined in https://httpwg.org/specs/rfc7540.html#iana-settings

```go
type SettingID uint16
```

```go
const (
    SettingHeaderTableSize      SettingID = 0x1
    SettingEnablePush           SettingID = 0x2
    SettingMaxConcurrentStreams SettingID = 0x3
    SettingInitialWindowSize    SettingID = 0x4
    SettingMaxFrameSize         SettingID = 0x5
    SettingMaxHeaderListSize    SettingID = 0x6
)
```

### func \(SettingID\) String

```go
func (s SettingID) String() string
```

## type SettingsFrame

A SettingsFrame conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior.

See https://httpwg.org/specs/rfc7540.html#SETTINGS

```go
type SettingsFrame struct {
    FrameHeader
    // contains filtered or unexported fields
}
```

### func \(\*SettingsFrame\) ForeachSetting

```go
func (f *SettingsFrame) ForeachSetting(fn func(Setting) error) error
```

ForeachSetting runs fn for each setting. It stops and returns the first error.

### func \(\*SettingsFrame\) HasDuplicates

```go
func (f *SettingsFrame) HasDuplicates() bool
```

HasDuplicates reports whether f contains any duplicate setting IDs.

### func \(\*SettingsFrame\) IsAck

```go
func (f *SettingsFrame) IsAck() bool
```

### func \(\*SettingsFrame\) NumSettings

```go
func (f *SettingsFrame) NumSettings() int
```

### func \(\*SettingsFrame\) Setting

```go
func (f *SettingsFrame) Setting(i int) Setting
```

Setting returns the setting from the frame at the given 0\-based index. The index must be \>= 0 and less than f.NumSettings\(\).

### func \(\*SettingsFrame\) Value

```go
func (f *SettingsFrame) Value(id SettingID) (v uint32, ok bool)
```

## type StreamError

StreamError is an error that only affects one stream within an HTTP/2 connection.

```go
type StreamError struct {
    StreamID uint32
    Code     ErrCode
    Cause    error // optional additional detail
}
```

### func \(StreamError\) Error

```go
func (e StreamError) Error() string
```

## type Transport

Transport is an HTTP/2 Transport.

A Transport internally caches connections to servers. It is safe for concurrent use by multiple goroutines.

```go
type Transport struct {
    // DialTLSContext specifies an optional dial function with context for
    // creating TLS connections for requests.
    //
    // If DialTLSContext and DialTLS is nil, tls.Dial is used.
    //
    // If the returned net.Conn has a ConnectionState method like tls.Conn,
    // it will be used to set http.Response.TLS.
    DialTLSContext func(ctx context.Context, network, addr string, cfg *tls.Config) (net.Conn, error)

    // DialTLS specifies an optional dial function for creating
    // TLS connections for requests.
    //
    // If DialTLSContext and DialTLS is nil, tls.Dial is used.
    //
    // Deprecated: Use DialTLSContext instead, which allows the transport
    // to cancel dials as soon as they are no longer needed.
    // If both are set, DialTLSContext takes priority.
    DialTLS func(network, addr string, cfg *tls.Config) (net.Conn, error)

    // TLSClientConfig specifies the TLS configuration to use with
    // tls.Client. If nil, the default configuration is used.
    TLSClientConfig *tls.Config

    // ConnPool optionally specifies an alternate connection pool to use.
    // If nil, the default is used.
    ConnPool ClientConnPool

    // DisableCompression, if true, prevents the Transport from
    // requesting compression with an "Accept-Encoding: gzip"
    // request header when the Request contains no existing
    // Accept-Encoding value. If the Transport requests gzip on
    // its own and gets a gzipped response, it's transparently
    // decoded in the Response.Body. However, if the user
    // explicitly requested gzip it is not automatically
    // uncompressed.
    DisableCompression bool

    // AllowHTTP, if true, permits HTTP/2 requests using the insecure,
    // plain-text "http" scheme. Note that this does not enable h2c support.
    AllowHTTP bool

    // MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to
    // send in the initial settings frame. It is how many bytes
    // of response headers are allowed. Unlike the http2 spec, zero here
    // means to use a default limit (currently 10MB). If you actually
    // want to advertise an unlimited value to the peer, Transport
    // interprets the highest possible value here (0xffffffff or 1<<32-1)
    // to mean no limit.
    MaxHeaderListSize uint32

    // StrictMaxConcurrentStreams controls whether the server's
    // SETTINGS_MAX_CONCURRENT_STREAMS should be respected
    // globally. If false, new TCP connections are created to the
    // server as needed to keep each under the per-connection
    // SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the
    // server's SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as
    // a global limit and callers of RoundTrip block when needed,
    // waiting for their turn.
    StrictMaxConcurrentStreams bool

    // ReadIdleTimeout is the timeout after which a health check using ping
    // frame will be carried out if no frame is received on the connection.
    // Note that a ping response will is considered a received frame, so if
    // there is no other traffic on the connection, the health check will
    // be performed every ReadIdleTimeout interval.
    // If zero, no health check is performed.
    ReadIdleTimeout time.Duration

    // PingTimeout is the timeout after which the connection will be closed
    // if a response to Ping is not received.
    // Defaults to 15s.
    PingTimeout time.Duration

    // WriteByteTimeout is the timeout after which the connection will be
    // closed no data can be written to it. The timeout begins when data is
    // available to write, and is extended whenever any bytes are written.
    WriteByteTimeout time.Duration

    // CountError, if non-nil, is called on HTTP/2 transport errors.
    // It's intended to increment a metric for monitoring, such
    // as an expvar or Prometheus metric.
    // The errType consists of only ASCII word characters.
    CountError func(errType string)
    // contains filtered or unexported fields
}
```

### func \(\*Transport\) CloseIdleConnections

```go
func (t *Transport) CloseIdleConnections()
```

CloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle. It does not interrupt any connections currently in use.

### func \(\*Transport\) NewClientConn

```go
func (t *Transport) NewClientConn(c net.Conn) (*ClientConn, error)
```

### func \(\*Transport\) RoundTrip

```go
func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error)
```

### func \(\*Transport\) RoundTripOpt

```go
func (t *Transport) RoundTripOpt(req *http.Request, opt RoundTripOpt) (*http.Response, error)
```

RoundTripOpt is like RoundTrip, but takes options.

## type UnknownFrame

An UnknownFrame is the frame type returned when the frame type is unknown or no specific frame type parser exists.

```go
type UnknownFrame struct {
    FrameHeader
    // contains filtered or unexported fields
}
```

### func \(\*UnknownFrame\) Payload

```go
func (f *UnknownFrame) Payload() []byte
```

Payload returns the frame's payload \(after the header\).  It is not valid to call this method after a subsequent call to Framer.ReadFrame, nor is it valid to retain the returned slice. The memory is owned by the Framer and is invalidated when the next frame is read.

## type WindowUpdateFrame

A WindowUpdateFrame is used to implement flow control. See https://httpwg.org/specs/rfc7540.html#rfc.section.6.9

```go
type WindowUpdateFrame struct {
    FrameHeader
    Increment uint32 // never read with high bit set
}
```

## type WriteScheduler

WriteScheduler is the interface implemented by HTTP/2 write schedulers. Methods are never called concurrently.

```go
type WriteScheduler interface {
    // OpenStream opens a new stream in the write scheduler.
    // It is illegal to call this with streamID=0 or with a streamID that is
    // already open -- the call may panic.
    OpenStream(streamID uint32, options OpenStreamOptions)

    // CloseStream closes a stream in the write scheduler. Any frames queued on
    // this stream should be discarded. It is illegal to call this on a stream
    // that is not open -- the call may panic.
    CloseStream(streamID uint32)

    // AdjustStream adjusts the priority of the given stream. This may be called
    // on a stream that has not yet been opened or has been closed. Note that
    // RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:
    // https://tools.ietf.org/html/rfc7540#section-5.1
    AdjustStream(streamID uint32, priority PriorityParam)

    // Push queues a frame in the scheduler. In most cases, this will not be
    // called with wr.StreamID()!=0 unless that stream is currently open. The one
    // exception is RST_STREAM frames, which may be sent on idle or closed streams.
    Push(wr FrameWriteRequest)

    // Pop dequeues the next frame to write. Returns false if no frames can
    // be written. Frames with a given wr.StreamID() are Pop'd in the same
    // order they are Push'd, except RST_STREAM frames. No frames should be
    // discarded except by CloseStream.
    Pop() (wr FrameWriteRequest, ok bool)
}
```

### func NewPriorityWriteScheduler

```go
func NewPriorityWriteScheduler(cfg *PriorityWriteSchedulerConfig) WriteScheduler
```

NewPriorityWriteScheduler constructs a WriteScheduler that schedules frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3. If cfg is nil, default options are used.

### func NewRandomWriteScheduler

```go
func NewRandomWriteScheduler() WriteScheduler
```

NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2 priorities. Control frames like SETTINGS and PING are written before DATA frames, but if no control frames are queued and multiple streams have queued HEADERS or DATA frames, Pop selects a ready stream arbitrarily.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
