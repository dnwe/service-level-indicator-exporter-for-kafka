<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# fieldpath

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/sigs.k8s.io/structured-merge-diff/v4/fieldpath"
```

Package fieldpath defines a way for referencing path elements \(e.g., an index in an array, or a key in a map\). It provides types for arranging these into paths for referencing nested fields, and for grouping those into sets, for referencing multiple nested fields.

## Index

- [Variables](<#variables>)
- [func KeyByFields(nameValues ...interface{}) *value.FieldList](<#func-keybyfields>)
- [func SerializePathElement(pe PathElement) (string, error)](<#func-serializepathelement>)
- [type APIVersion](<#type-apiversion>)
- [type ManagedFields](<#type-managedfields>)
  - [func (lhs ManagedFields) Copy() ManagedFields](<#func-managedfields-copy>)
  - [func (lhs ManagedFields) Difference(rhs ManagedFields) ManagedFields](<#func-managedfields-difference>)
  - [func (lhs ManagedFields) Equals(rhs ManagedFields) bool](<#func-managedfields-equals>)
  - [func (lhs ManagedFields) String() string](<#func-managedfields-string>)
- [type Path](<#type-path>)
  - [func MakePath(parts ...interface{}) (Path, error)](<#func-makepath>)
  - [func MakePathOrDie(parts ...interface{}) Path](<#func-makepathordie>)
  - [func (fp Path) Compare(rhs Path) int](<#func-path-compare>)
  - [func (fp Path) Copy() Path](<#func-path-copy>)
  - [func (fp Path) Equals(fp2 Path) bool](<#func-path-equals>)
  - [func (fp Path) String() string](<#func-path-string>)
- [type PathElement](<#type-pathelement>)
  - [func DeserializePathElement(s string) (PathElement, error)](<#func-deserializepathelement>)
  - [func (e PathElement) Compare(rhs PathElement) int](<#func-pathelement-compare>)
  - [func (e PathElement) Equals(rhs PathElement) bool](<#func-pathelement-equals>)
  - [func (e PathElement) Less(rhs PathElement) bool](<#func-pathelement-less>)
  - [func (e PathElement) String() string](<#func-pathelement-string>)
- [type PathElementSet](<#type-pathelementset>)
  - [func MakePathElementSet(size int) PathElementSet](<#func-makepathelementset>)
  - [func (s *PathElementSet) Difference(s2 *PathElementSet) *PathElementSet](<#func-pathelementset-difference>)
  - [func (s *PathElementSet) Equals(s2 *PathElementSet) bool](<#func-pathelementset-equals>)
  - [func (s *PathElementSet) Has(pe PathElement) bool](<#func-pathelementset-has>)
  - [func (s *PathElementSet) Insert(pe PathElement)](<#func-pathelementset-insert>)
  - [func (s *PathElementSet) Intersection(s2 *PathElementSet) *PathElementSet](<#func-pathelementset-intersection>)
  - [func (s *PathElementSet) Iterate(f func(PathElement))](<#func-pathelementset-iterate>)
  - [func (s *PathElementSet) Size() int](<#func-pathelementset-size>)
  - [func (s *PathElementSet) Union(s2 *PathElementSet) *PathElementSet](<#func-pathelementset-union>)
- [type PathElementValueMap](<#type-pathelementvaluemap>)
  - [func MakePathElementValueMap(size int) PathElementValueMap](<#func-makepathelementvaluemap>)
  - [func (s *PathElementValueMap) Get(pe PathElement) (value.Value, bool)](<#func-pathelementvaluemap-get>)
  - [func (s *PathElementValueMap) Insert(pe PathElement, v value.Value)](<#func-pathelementvaluemap-insert>)
- [type Set](<#type-set>)
  - [func NewSet(paths ...Path) *Set](<#func-newset>)
  - [func SetFromValue(v value.Value) *Set](<#func-setfromvalue>)
  - [func (s *Set) Difference(s2 *Set) *Set](<#func-set-difference>)
  - [func (s *Set) Empty() bool](<#func-set-empty>)
  - [func (s *Set) EnsureNamedFieldsAreMembers(sc *schema.Schema, tr schema.TypeRef) *Set](<#func-set-ensurenamedfieldsaremembers>)
  - [func (s *Set) Equals(s2 *Set) bool](<#func-set-equals>)
  - [func (s *Set) FromJSON(r io.Reader) error](<#func-set-fromjson>)
  - [func (s *Set) Has(p Path) bool](<#func-set-has>)
  - [func (s *Set) Insert(p Path)](<#func-set-insert>)
  - [func (s *Set) Intersection(s2 *Set) *Set](<#func-set-intersection>)
  - [func (s *Set) Iterate(f func(Path))](<#func-set-iterate>)
  - [func (s *Set) Leaves() *Set](<#func-set-leaves>)
  - [func (s *Set) RecursiveDifference(s2 *Set) *Set](<#func-set-recursivedifference>)
  - [func (s *Set) Size() int](<#func-set-size>)
  - [func (s *Set) String() string](<#func-set-string>)
  - [func (s *Set) ToJSON() ([]byte, error)](<#func-set-tojson>)
  - [func (s *Set) ToJSONStream(w io.Writer) error](<#func-set-tojsonstream>)
  - [func (s *Set) Union(s2 *Set) *Set](<#func-set-union>)
  - [func (s *Set) WithPrefix(pe PathElement) *Set](<#func-set-withprefix>)
- [type SetNodeMap](<#type-setnodemap>)
  - [func (s *SetNodeMap) Descend(pe PathElement) *Set](<#func-setnodemap-descend>)
  - [func (s *SetNodeMap) Difference(s2 *Set) *SetNodeMap](<#func-setnodemap-difference>)
  - [func (s *SetNodeMap) Empty() bool](<#func-setnodemap-empty>)
  - [func (s *SetNodeMap) EnsureNamedFieldsAreMembers(sc *schema.Schema, tr schema.TypeRef) *SetNodeMap](<#func-setnodemap-ensurenamedfieldsaremembers>)
  - [func (s *SetNodeMap) Equals(s2 *SetNodeMap) bool](<#func-setnodemap-equals>)
  - [func (s *SetNodeMap) Get(pe PathElement) (*Set, bool)](<#func-setnodemap-get>)
  - [func (s *SetNodeMap) Intersection(s2 *SetNodeMap) *SetNodeMap](<#func-setnodemap-intersection>)
  - [func (s *SetNodeMap) Iterate(f func(PathElement))](<#func-setnodemap-iterate>)
  - [func (s *SetNodeMap) Leaves() *SetNodeMap](<#func-setnodemap-leaves>)
  - [func (s *SetNodeMap) RecursiveDifference(s2 *Set) *SetNodeMap](<#func-setnodemap-recursivedifference>)
  - [func (s *SetNodeMap) Size() int](<#func-setnodemap-size>)
  - [func (s *SetNodeMap) Union(s2 *SetNodeMap) *SetNodeMap](<#func-setnodemap-union>)
- [type VersionedSet](<#type-versionedset>)
  - [func NewVersionedSet(set *Set, apiVersion APIVersion, applied bool) VersionedSet](<#func-newversionedset>)


## Variables

AssociativeListCandidateFieldNames lists the field names which are considered keys if found in a list element.

```go
var AssociativeListCandidateFieldNames = []string{
    "key",
    "id",
    "name",
}
```

```go
var ErrUnknownPathElementType = errors.New("unknown path element type")
```

## func KeyByFields

```go
func KeyByFields(nameValues ...interface{}) *value.FieldList
```

KeyByFields is a helper function which constructs a key for an associative list type. \`nameValues\` must have an even number of entries, alternating names \(type must be string\) with values \(type must be value.Value\). If these conditions are not met, KeyByFields will panic\-\-it's intended for static construction and shouldn't have user\-produced values passed to it.

## func SerializePathElement

```go
func SerializePathElement(pe PathElement) (string, error)
```

SerializePathElement serializes a path element

## type APIVersion

APIVersion describes the version of an object or of a fieldset.

```go
type APIVersion string
```

## type ManagedFields

ManagedFields is a map from manager to VersionedSet \(what they own in what version\).

```go
type ManagedFields map[string]VersionedSet
```

### func \(ManagedFields\) Copy

```go
func (lhs ManagedFields) Copy() ManagedFields
```

Copy the list, this is mostly a shallow copy.

### func \(ManagedFields\) Difference

```go
func (lhs ManagedFields) Difference(rhs ManagedFields) ManagedFields
```

Difference returns a symmetric difference between two Managers. If a given user's entry has version X in lhs and version Y in rhs, then the return value for that user will be from rhs. If the difference for a user is an empty set, that user will not be inserted in the map.

### func \(ManagedFields\) Equals

```go
func (lhs ManagedFields) Equals(rhs ManagedFields) bool
```

Equals returns true if the two managedfields are the same, false otherwise.

### func \(ManagedFields\) String

```go
func (lhs ManagedFields) String() string
```

## type Path

Path describes how to select a potentially deeply\-nested child field given a containing object.

```go
type Path []PathElement
```

### func MakePath

```go
func MakePath(parts ...interface{}) (Path, error)
```

MakePath constructs a Path. The parts may be PathElements, ints, strings.

### func MakePathOrDie

```go
func MakePathOrDie(parts ...interface{}) Path
```

MakePathOrDie panics if parts can't be turned into a path. Good for things that are known at complie time.

### func \(Path\) Compare

```go
func (fp Path) Compare(rhs Path) int
```

Less provides a lexical order for Paths.

### func \(Path\) Copy

```go
func (fp Path) Copy() Path
```

### func \(Path\) Equals

```go
func (fp Path) Equals(fp2 Path) bool
```

Equals returns true if the two paths are equivalent.

### func \(Path\) String

```go
func (fp Path) String() string
```

## type PathElement

PathElement describes how to select a child field given a containing object.

```go
type PathElement struct {

    // FieldName selects a single field from a map (reminder: this is also
    // how structs are represented). The containing object must be a map.
    FieldName *string

    // Key selects the list element which has fields matching those given.
    // The containing object must be an associative list with map typed
    // elements. They are sorted alphabetically.
    Key *value.FieldList

    // Value selects the list element with the given value. The containing
    // object must be an associative list with a primitive typed element
    // (i.e., a set).
    Value *value.Value

    // Index selects a list element by its index number. The containing
    // object must be an atomic list.
    Index *int
}
```

### func DeserializePathElement

```go
func DeserializePathElement(s string) (PathElement, error)
```

DeserializePathElement parses a serialized path element

### func \(PathElement\) Compare

```go
func (e PathElement) Compare(rhs PathElement) int
```

Compare provides an order for path elements.

### func \(PathElement\) Equals

```go
func (e PathElement) Equals(rhs PathElement) bool
```

Equals returns true if both path elements are equal.

### func \(PathElement\) Less

```go
func (e PathElement) Less(rhs PathElement) bool
```

Less provides an order for path elements.

### func \(PathElement\) String

```go
func (e PathElement) String() string
```

String presents the path element as a human\-readable string.

## type PathElementSet

PathElementSet is a set of path elements. TODO: serialize as a list.

```go
type PathElementSet struct {
    // contains filtered or unexported fields
}
```

### func MakePathElementSet

```go
func MakePathElementSet(size int) PathElementSet
```

### func \(\*PathElementSet\) Difference

```go
func (s *PathElementSet) Difference(s2 *PathElementSet) *PathElementSet
```

Difference returns a set containing elements which appear in s but not in s2.

### func \(\*PathElementSet\) Equals

```go
func (s *PathElementSet) Equals(s2 *PathElementSet) bool
```

Equals returns true if s and s2 have exactly the same members.

### func \(\*PathElementSet\) Has

```go
func (s *PathElementSet) Has(pe PathElement) bool
```

Has returns true if pe is a member of the set.

### func \(\*PathElementSet\) Insert

```go
func (s *PathElementSet) Insert(pe PathElement)
```

Insert adds pe to the set.

### func \(\*PathElementSet\) Intersection

```go
func (s *PathElementSet) Intersection(s2 *PathElementSet) *PathElementSet
```

Intersection returns a set containing elements which appear in both s and s2.

### func \(\*PathElementSet\) Iterate

```go
func (s *PathElementSet) Iterate(f func(PathElement))
```

Iterate calls f for each PathElement in the set. The order is deterministic.

### func \(\*PathElementSet\) Size

```go
func (s *PathElementSet) Size() int
```

Size retuns the number of elements in the set.

### func \(\*PathElementSet\) Union

```go
func (s *PathElementSet) Union(s2 *PathElementSet) *PathElementSet
```

Union returns a set containing elements that appear in either s or s2.

## type PathElementValueMap

PathElementValueMap is a map from PathElement to value.Value.

TODO\(apelisse\): We have multiple very similar implementation of this for PathElementSet and SetNodeMap, so we could probably share the code.

```go
type PathElementValueMap struct {
    // contains filtered or unexported fields
}
```

### func MakePathElementValueMap

```go
func MakePathElementValueMap(size int) PathElementValueMap
```

### func \(\*PathElementValueMap\) Get

```go
func (s *PathElementValueMap) Get(pe PathElement) (value.Value, bool)
```

Get retrieves the value associated with the given PathElement from the map. \(nil, false\) is returned if there is no such PathElement.

### func \(\*PathElementValueMap\) Insert

```go
func (s *PathElementValueMap) Insert(pe PathElement, v value.Value)
```

Insert adds the pathelement and associated value in the map.

## type Set

Set identifies a set of fields.

```go
type Set struct {
    // Members lists fields that are part of the set.
    // TODO: will be serialized as a list of path elements.
    Members PathElementSet

    // Children lists child fields which themselves have children that are
    // members of the set. Appearance in this list does not imply membership.
    // Note: this is a tree, not an arbitrary graph.
    Children SetNodeMap
}
```

### func NewSet

```go
func NewSet(paths ...Path) *Set
```

NewSet makes a set from a list of paths.

### func SetFromValue

```go
func SetFromValue(v value.Value) *Set
```

SetFromValue creates a set containing every leaf field mentioned in v.

### func \(\*Set\) Difference

```go
func (s *Set) Difference(s2 *Set) *Set
```

Difference returns a Set containing elements which: \* appear in s \* do not appear in s2

In other words, for leaf fields, this acts like a regular set difference operation. When non leaf fields are compared with leaf fields \("parents" which contain "children"\), the effect is: \* parent \- child = parent \* child \- parent = \{empty set\}

### func \(\*Set\) Empty

```go
func (s *Set) Empty() bool
```

Empty returns true if there are no members of the set. It is a separate function from Size since it's common to check whether size \> 0, and potentially much faster to return as soon as a single element is found.

### func \(\*Set\) EnsureNamedFieldsAreMembers

```go
func (s *Set) EnsureNamedFieldsAreMembers(sc *schema.Schema, tr schema.TypeRef) *Set
```

EnsureNamedFieldsAreMembers returns a Set that contains all the fields in s, as well as all the named fields that are typically not included. For example, a set made of "a.b.c" will end\-up also owning "a" if it's a named fields but not "a.b" if it's a map.

### func \(\*Set\) Equals

```go
func (s *Set) Equals(s2 *Set) bool
```

Equals returns true if s and s2 have exactly the same members.

### func \(\*Set\) FromJSON

```go
func (s *Set) FromJSON(r io.Reader) error
```

FromJSON clears s and reads a JSON formatted set structure.

### func \(\*Set\) Has

```go
func (s *Set) Has(p Path) bool
```

Has returns true if the field referenced by \`p\` is a member of the set.

### func \(\*Set\) Insert

```go
func (s *Set) Insert(p Path)
```

Insert adds the field identified by \`p\` to the set. Important: parent fields are NOT added to the set; if that is desired, they must be added separately.

### func \(\*Set\) Intersection

```go
func (s *Set) Intersection(s2 *Set) *Set
```

Intersection returns a Set containing leaf elements which appear in both s and s2. Intersection can be constructed from Union and Difference operations \(example in the tests\) but it's much faster to do it in one pass.

### func \(\*Set\) Iterate

```go
func (s *Set) Iterate(f func(Path))
```

Iterate calls f once for each field that is a member of the set \(preorder DFS\). The path passed to f will be reused so make a copy if you wish to keep it.

### func \(\*Set\) Leaves

```go
func (s *Set) Leaves() *Set
```

Leaves returns a set containing only the leaf paths of a set.

### func \(\*Set\) RecursiveDifference

```go
func (s *Set) RecursiveDifference(s2 *Set) *Set
```

RecursiveDifference returns a Set containing elements which: \* appear in s \* do not appear in s2

Compared to a regular difference, this removes every field \*\*and its children\*\* from s that is contained in s2.

For example, with s containing \`a.b.c\` and s2 containing \`a.b\`, a RecursiveDifference will result in \`a\`, as the entire node \`a.b\` gets removed.

### func \(\*Set\) Size

```go
func (s *Set) Size() int
```

Size returns the number of members of the set.

### func \(\*Set\) String

```go
func (s *Set) String() string
```

String returns the set one element per line.

### func \(\*Set\) ToJSON

```go
func (s *Set) ToJSON() ([]byte, error)
```

### func \(\*Set\) ToJSONStream

```go
func (s *Set) ToJSONStream(w io.Writer) error
```

### func \(\*Set\) Union

```go
func (s *Set) Union(s2 *Set) *Set
```

Union returns a Set containing elements which appear in either s or s2.

### func \(\*Set\) WithPrefix

```go
func (s *Set) WithPrefix(pe PathElement) *Set
```

WithPrefix returns the subset of paths which begin with the given prefix, with the prefix not included.

## type SetNodeMap

SetNodeMap is a map of PathElement to subset.

```go
type SetNodeMap struct {
    // contains filtered or unexported fields
}
```

### func \(\*SetNodeMap\) Descend

```go
func (s *SetNodeMap) Descend(pe PathElement) *Set
```

Descend adds pe to the set if necessary, returning the associated subset.

### func \(\*SetNodeMap\) Difference

```go
func (s *SetNodeMap) Difference(s2 *Set) *SetNodeMap
```

Difference returns a SetNodeMap with members that appear in s but not in s2.

### func \(\*SetNodeMap\) Empty

```go
func (s *SetNodeMap) Empty() bool
```

Empty returns false if there's at least one member in some child set.

### func \(\*SetNodeMap\) EnsureNamedFieldsAreMembers

```go
func (s *SetNodeMap) EnsureNamedFieldsAreMembers(sc *schema.Schema, tr schema.TypeRef) *SetNodeMap
```

EnsureNamedFieldsAreMembers returns a set that contains all the named fields along with the leaves.

### func \(\*SetNodeMap\) Equals

```go
func (s *SetNodeMap) Equals(s2 *SetNodeMap) bool
```

Equals returns true if s and s2 have the same structure \(same nested child sets\).

### func \(\*SetNodeMap\) Get

```go
func (s *SetNodeMap) Get(pe PathElement) (*Set, bool)
```

Get returns \(the associated set, true\) or \(nil, false\) if there is none.

### func \(\*SetNodeMap\) Intersection

```go
func (s *SetNodeMap) Intersection(s2 *SetNodeMap) *SetNodeMap
```

Intersection returns a SetNodeMap with members that appear in both s and s2.

### func \(\*SetNodeMap\) Iterate

```go
func (s *SetNodeMap) Iterate(f func(PathElement))
```

Iterate calls f for each PathElement in the set.

### func \(\*SetNodeMap\) Leaves

```go
func (s *SetNodeMap) Leaves() *SetNodeMap
```

Leaves returns a SetNodeMap containing only setNodes with leaf PathElements.

### func \(\*SetNodeMap\) RecursiveDifference

```go
func (s *SetNodeMap) RecursiveDifference(s2 *Set) *SetNodeMap
```

RecursiveDifference returns a SetNodeMap with members that appear in s but not in s2.

Compared to a regular difference, this removes every field \*\*and its children\*\* from s that is contained in s2.

For example, with s containing \`a.b.c\` and s2 containing \`a.b\`, a RecursiveDifference will result in \`a\`, as the entire node \`a.b\` gets removed.

### func \(\*SetNodeMap\) Size

```go
func (s *SetNodeMap) Size() int
```

Size returns the sum of the number of members of all subsets.

### func \(\*SetNodeMap\) Union

```go
func (s *SetNodeMap) Union(s2 *SetNodeMap) *SetNodeMap
```

Union returns a SetNodeMap with members that appear in either s or s2.

## type VersionedSet

```go
type VersionedSet interface {
    Set() *Set
    APIVersion() APIVersion
    Applied() bool
}
```

### func NewVersionedSet

```go
func NewVersionedSet(set *Set, apiVersion APIVersion, applied bool) VersionedSet
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
