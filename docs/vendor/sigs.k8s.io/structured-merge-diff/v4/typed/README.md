<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# typed

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/sigs.k8s.io/structured-merge-diff/v4/typed"
```

Package typed contains logic for operating on values with given schemas.

## Index

- [func ReconcileFieldSetWithSchema(fieldset *fieldpath.Set, tv *TypedValue) (*fieldpath.Set, error)](<#func-reconcilefieldsetwithschema>)
- [type Comparison](<#type-comparison>)
  - [func (c *Comparison) ExcludeFields(fields *fieldpath.Set) *Comparison](<#func-comparison-excludefields>)
  - [func (c *Comparison) IsSame() bool](<#func-comparison-issame>)
  - [func (c *Comparison) String() string](<#func-comparison-string>)
- [type ParseableType](<#type-parseabletype>)
  - [func (p ParseableType) FromStructured(in interface{}) (*TypedValue, error)](<#func-parseabletype-fromstructured>)
  - [func (p ParseableType) FromUnstructured(in interface{}) (*TypedValue, error)](<#func-parseabletype-fromunstructured>)
  - [func (p ParseableType) FromYAML(object YAMLObject) (*TypedValue, error)](<#func-parseabletype-fromyaml>)
  - [func (p ParseableType) IsValid() bool](<#func-parseabletype-isvalid>)
- [type Parser](<#type-parser>)
  - [func NewParser(schema YAMLObject) (*Parser, error)](<#func-newparser>)
  - [func (p *Parser) Type(name string) ParseableType](<#func-parser-type>)
  - [func (p *Parser) TypeNames() (names []string)](<#func-parser-typenames>)
- [type TypedValue](<#type-typedvalue>)
  - [func AsTyped(v value.Value, s *schema.Schema, typeRef schema.TypeRef) (*TypedValue, error)](<#func-astyped>)
  - [func AsTypedUnvalidated(v value.Value, s *schema.Schema, typeRef schema.TypeRef) *TypedValue](<#func-astypedunvalidated>)
  - [func (tv TypedValue) AsValue() value.Value](<#func-typedvalue-asvalue>)
  - [func (tv TypedValue) Compare(rhs *TypedValue) (c *Comparison, err error)](<#func-typedvalue-compare>)
  - [func (tv TypedValue) Empty() *TypedValue](<#func-typedvalue-empty>)
  - [func (tv TypedValue) ExtractItems(items *fieldpath.Set) *TypedValue](<#func-typedvalue-extractitems>)
  - [func (tv TypedValue) Merge(pso *TypedValue) (*TypedValue, error)](<#func-typedvalue-merge>)
  - [func (tv TypedValue) NormalizeUnions(new *TypedValue) (*TypedValue, error)](<#func-typedvalue-normalizeunions>)
  - [func (tv TypedValue) NormalizeUnionsApply(new *TypedValue) (*TypedValue, error)](<#func-typedvalue-normalizeunionsapply>)
  - [func (tv TypedValue) RemoveItems(items *fieldpath.Set) *TypedValue](<#func-typedvalue-removeitems>)
  - [func (tv TypedValue) Schema() *schema.Schema](<#func-typedvalue-schema>)
  - [func (tv TypedValue) ToFieldSet() (*fieldpath.Set, error)](<#func-typedvalue-tofieldset>)
  - [func (tv TypedValue) TypeRef() schema.TypeRef](<#func-typedvalue-typeref>)
  - [func (tv TypedValue) Validate() error](<#func-typedvalue-validate>)
- [type ValidationError](<#type-validationerror>)
  - [func (ve ValidationError) Error() string](<#func-validationerror-error>)
- [type ValidationErrors](<#type-validationerrors>)
  - [func (errs ValidationErrors) Error() string](<#func-validationerrors-error>)
  - [func (errs ValidationErrors) WithLazyPrefix(fn func() string) ValidationErrors](<#func-validationerrors-withlazyprefix>)
  - [func (errs ValidationErrors) WithPath(p string) ValidationErrors](<#func-validationerrors-withpath>)
  - [func (errs ValidationErrors) WithPrefix(prefix string) ValidationErrors](<#func-validationerrors-withprefix>)
- [type YAMLObject](<#type-yamlobject>)


## func ReconcileFieldSetWithSchema

```go
func ReconcileFieldSetWithSchema(fieldset *fieldpath.Set, tv *TypedValue) (*fieldpath.Set, error)
```

ReconcileFieldSetWithSchema reconciles the a field set with any changes to the // object's schema since the field set was written. Returns the reconciled field set, or nil of no changes were made to the field set.

Supports: \- changing types from atomic to granular \- changing types from granular to atomic

## type Comparison

Comparison is the return value of a TypedValue.Compare\(\) operation.

No field will appear in more than one of the three fieldsets. If all of the fieldsets are empty, then the objects must have been equal.

```go
type Comparison struct {
    // Removed contains any fields removed by rhs (the right-hand-side
    // object in the comparison).
    Removed *fieldpath.Set
    // Modified contains fields present in both objects but different.
    Modified *fieldpath.Set
    // Added contains any fields added by rhs.
    Added *fieldpath.Set
}
```

### func \(\*Comparison\) ExcludeFields

```go
func (c *Comparison) ExcludeFields(fields *fieldpath.Set) *Comparison
```

ExcludeFields fields from the compare recursively removes the fields from the entire comparison

### func \(\*Comparison\) IsSame

```go
func (c *Comparison) IsSame() bool
```

IsSame returns true if the comparison returned no changes \(the two compared objects are similar\).

### func \(\*Comparison\) String

```go
func (c *Comparison) String() string
```

String returns a human readable version of the comparison.

## type ParseableType

ParseableType allows for easy production of typed objects.

```go
type ParseableType struct {
    TypeRef schema.TypeRef
    Schema  *schema.Schema
}
```

DeducedParseableType is a ParseableType that deduces the type from the content of the object.

```go
var DeducedParseableType ParseableType = createOrDie(YAMLObject(`types:
- name: __untyped_atomic_
  scalar: untyped
  list:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
  map:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
- name: __untyped_deduced_
  scalar: untyped
  list:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
  map:
    elementType:
      namedType: __untyped_deduced_
    elementRelationship: separable
`)).Type("__untyped_deduced_")
```

### func \(ParseableType\) FromStructured

```go
func (p ParseableType) FromStructured(in interface{}) (*TypedValue, error)
```

FromStructured converts a go "interface\{\}" type, typically an structured object in Kubernetes, to a TypedValue. It will return an error if the resulting object fails schema validation. The provided "interface\{\}" value must be a pointer so that the value can be modified via reflection. The provided "interface\{\}" may contain structs and types that are converted to Values by the jsonMarshaler interface.

### func \(ParseableType\) FromUnstructured

```go
func (p ParseableType) FromUnstructured(in interface{}) (*TypedValue, error)
```

FromUnstructured converts a go "interface\{\}" type, typically an unstructured object in Kubernetes world, to a TypedValue. It returns an error if the resulting object fails schema validation. The provided interface\{\} must be one of: map\[string\]interface\{\}, map\[interface\{\}\]interface\{\}, \[\]interface\{\}, int types, float types, string or boolean. Nested interface\{\} must also be one of these types.

### func \(ParseableType\) FromYAML

```go
func (p ParseableType) FromYAML(object YAMLObject) (*TypedValue, error)
```

FromYAML parses a yaml string into an object with the current schema and the type "typename" or an error if validation fails.

### func \(ParseableType\) IsValid

```go
func (p ParseableType) IsValid() bool
```

IsValid return true if p's schema and typename are valid.

## type Parser

Parser implements YAMLParser and allows introspecting the schema.

```go
type Parser struct {
    Schema schema.Schema
}
```

### func NewParser

```go
func NewParser(schema YAMLObject) (*Parser, error)
```

NewParser will build a YAMLParser from a schema. The schema is validated.

### func \(\*Parser\) Type

```go
func (p *Parser) Type(name string) ParseableType
```

Type returns a helper which can produce objects of the given type. Any errors are deferred until a further function is called.

### func \(\*Parser\) TypeNames

```go
func (p *Parser) TypeNames() (names []string)
```

TypeNames returns a list of types this parser understands.

## type TypedValue

TypedValue is a value of some specific type.

```go
type TypedValue struct {
    // contains filtered or unexported fields
}
```

### func AsTyped

```go
func AsTyped(v value.Value, s *schema.Schema, typeRef schema.TypeRef) (*TypedValue, error)
```

AsTyped accepts a value and a type and returns a TypedValue. 'v' must have type 'typeName' in the schema. An error is returned if the v doesn't conform to the schema.

### func AsTypedUnvalidated

```go
func AsTypedUnvalidated(v value.Value, s *schema.Schema, typeRef schema.TypeRef) *TypedValue
```

AsTypeUnvalidated is just like AsTyped, but doesn't validate that the type conforms to the schema, for cases where that has already been checked or where you're going to call a method that validates as a side\-effect \(like ToFieldSet\).

### func \(TypedValue\) AsValue

```go
func (tv TypedValue) AsValue() value.Value
```

AsValue removes the type from the TypedValue and only keeps the value.

### func \(TypedValue\) Compare

```go
func (tv TypedValue) Compare(rhs *TypedValue) (c *Comparison, err error)
```

Compare compares the two objects. See the comments on the \`Comparison\` struct for details on the return value.

tv and rhs must both be of the same type \(their Schema and TypeRef must match\), or an error will be returned. Validation errors will be returned if the objects don't conform to the schema.

### func \(TypedValue\) Empty

```go
func (tv TypedValue) Empty() *TypedValue
```

### func \(TypedValue\) ExtractItems

```go
func (tv TypedValue) ExtractItems(items *fieldpath.Set) *TypedValue
```

ExtractItems returns a value with only the provided list or map items extracted from the value.

### func \(TypedValue\) Merge

```go
func (tv TypedValue) Merge(pso *TypedValue) (*TypedValue, error)
```

Merge returns the result of merging tv and pso \("partially specified object"\) together. Of note: \* No fields can be removed by this operation. \* If both tv and pso specify a given leaf field, the result will keep pso's value. \* Container typed elements will have their items ordered: \* like tv, if pso doesn't change anything in the container \* like pso, if pso does change something in the container. tv and pso must both be of the same type \(their Schema and TypeRef must match\), or an error will be returned. Validation errors will be returned if the objects don't conform to the schema.

### func \(TypedValue\) NormalizeUnions

```go
func (tv TypedValue) NormalizeUnions(new *TypedValue) (*TypedValue, error)
```

NormalizeUnions takes the new object and normalizes the union: \- If discriminator changed to non\-nil, and a new field has been added that doesn't match, an error is returned, \- If discriminator hasn't changed and two fields or more are set, an error is returned, \- If discriminator changed to non\-nil, all other fields but the discriminated one will be cleared, \- Otherwise, If only one field is left, update discriminator to that value.

Please note: union behavior isn't finalized yet and this is still experimental.

### func \(TypedValue\) NormalizeUnionsApply

```go
func (tv TypedValue) NormalizeUnionsApply(new *TypedValue) (*TypedValue, error)
```

NormalizeUnionsApply specifically normalize unions on apply. It validates that the applied union is correct \(there should be no ambiguity there\), and clear the fields according to the sent intent.

Please note: union behavior isn't finalized yet and this is still experimental.

### func \(TypedValue\) RemoveItems

```go
func (tv TypedValue) RemoveItems(items *fieldpath.Set) *TypedValue
```

RemoveItems removes each provided list or map item from the value.

### func \(TypedValue\) Schema

```go
func (tv TypedValue) Schema() *schema.Schema
```

Schema gets the schema from the TypedValue.

### func \(TypedValue\) ToFieldSet

```go
func (tv TypedValue) ToFieldSet() (*fieldpath.Set, error)
```

ToFieldSet creates a set containing every leaf field and item mentioned, or validation errors, if any were encountered.

### func \(TypedValue\) TypeRef

```go
func (tv TypedValue) TypeRef() schema.TypeRef
```

TypeRef is the type of the value.

### func \(TypedValue\) Validate

```go
func (tv TypedValue) Validate() error
```

Validate returns an error with a list of every spec violation.

## type ValidationError

ValidationError reports an error about a particular field

```go
type ValidationError struct {
    Path         string
    ErrorMessage string
}
```

### func \(ValidationError\) Error

```go
func (ve ValidationError) Error() string
```

Error returns a human readable error message.

## type ValidationErrors

ValidationErrors accumulates multiple validation error messages.

```go
type ValidationErrors []ValidationError
```

### func \(ValidationErrors\) Error

```go
func (errs ValidationErrors) Error() string
```

Error returns a human readable error message reporting each error in the list.

### func \(ValidationErrors\) WithLazyPrefix

```go
func (errs ValidationErrors) WithLazyPrefix(fn func() string) ValidationErrors
```

WithLazyPrefix prefixes all errors path with the given pathelement. This is useful when unwinding the stack on errors. Prefix is computed lazily only if there is an error.

### func \(ValidationErrors\) WithPath

```go
func (errs ValidationErrors) WithPath(p string) ValidationErrors
```

Set the given path to all the validation errors.

### func \(ValidationErrors\) WithPrefix

```go
func (errs ValidationErrors) WithPrefix(prefix string) ValidationErrors
```

WithPrefix prefixes all errors path with the given pathelement. This is useful when unwinding the stack on errors.

## type YAMLObject

YAMLObject is an object encoded in YAML.

```go
type YAMLObject string
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
