<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# schema

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/sigs.k8s.io/structured-merge-diff/v4/schema"
```

Package schema defines a targeted schema language which allows one to represent all the schema information necessary to perform "structured" merges and diffs.

Due to the targeted nature of the data model, the schema language can fit in just a few hundred lines of go code, making it much more understandable and concise than e.g. OpenAPI.

This schema was derived by observing the API objects used by Kubernetes, and formalizing a model which allows certain operations \("apply"\) to be more well defined. It is currently missing one feature: one\-of \("unions"\).

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [type Atom](<#type-atom>)
  - [func (a *Atom) Equals(b *Atom) bool](<#func-atom-equals>)
- [type ElementRelationship](<#type-elementrelationship>)
- [type List](<#type-list>)
  - [func (a *List) Equals(b *List) bool](<#func-list-equals>)
- [type Map](<#type-map>)
  - [func (a *Map) Equals(b *Map) bool](<#func-map-equals>)
  - [func (m *Map) FindField(name string) (StructField, bool)](<#func-map-findfield>)
- [type Scalar](<#type-scalar>)
- [type Schema](<#type-schema>)
  - [func (a *Schema) Equals(b *Schema) bool](<#func-schema-equals>)
  - [func (s *Schema) FindNamedType(name string) (TypeDef, bool)](<#func-schema-findnamedtype>)
  - [func (s *Schema) Resolve(tr TypeRef) (Atom, bool)](<#func-schema-resolve>)
- [type StructField](<#type-structfield>)
  - [func (a *StructField) Equals(b *StructField) bool](<#func-structfield-equals>)
- [type TypeDef](<#type-typedef>)
  - [func (a *TypeDef) Equals(b *TypeDef) bool](<#func-typedef-equals>)
- [type TypeRef](<#type-typeref>)
  - [func (a *TypeRef) Equals(b *TypeRef) bool](<#func-typeref-equals>)
- [type TypeSpecifier](<#type-typespecifier>)
- [type Union](<#type-union>)
  - [func (a *Union) Equals(b *Union) bool](<#func-union-equals>)
- [type UnionField](<#type-unionfield>)
  - [func (a *UnionField) Equals(b *UnionField) bool](<#func-unionfield-equals>)


## Constants

```go
const (
    Numeric = Scalar("numeric")
    String  = Scalar("string")
    Boolean = Scalar("boolean")
)
```

```go
const (
    // Associative only applies to lists (see the documentation there).
    Associative = ElementRelationship("associative")
    // Atomic makes container types (lists, maps) behave
    // as scalars / leaf fields
    Atomic = ElementRelationship("atomic")
    // Separable means the items of the container type have no particular
    // relationship (default behavior for maps).
    Separable = ElementRelationship("separable")
)
```

## Variables

SchemaSchemaYAML is a schema against which you can validate other schemas. It will validate itself. It can be unmarshalled into a Schema type.

```go
var SchemaSchemaYAML = `types:
- name: schema
  map:
    fields:
      - name: types
        type:
          list:
            elementRelationship: associative
            elementType:
              namedType: typeDef
            keys:
            - name
- name: typeDef
  map:
    fields:
    - name: name
      type:
        scalar: string
    - name: scalar
      type:
        scalar: string
    - name: map
      type:
        namedType: map
    - name: list
      type:
        namedType: list
    - name: untyped
      type:
        namedType: untyped
- name: typeRef
  map:
    fields:
    - name: namedType
      type:
        scalar: string
    - name: scalar
      type:
        scalar: string
    - name: map
      type:
        namedType: map
    - name: list
      type:
        namedType: list
    - name: untyped
      type:
        namedType: untyped
- name: scalar
  scalar: string
- name: map
  map:
    fields:
    - name: fields
      type:
        list:
          elementType:
            namedType: structField
          elementRelationship: associative
          keys: [ "name" ]
    - name: unions
      type:
        list:
          elementType:
            namedType: union
          elementRelationship: atomic
    - name: elementType
      type:
        namedType: typeRef
    - name: elementRelationship
      type:
        scalar: string
- name: unionField
  map:
    fields:
    - name: fieldName
      type:
        scalar: string
    - name: discriminatorValue
      type:
        scalar: string
- name: union
  map:
    fields:
    - name: discriminator
      type:
        scalar: string
    - name: deduceInvalidDiscriminator
      type:
        scalar: bool
    - name: fields
      type:
        list:
          elementRelationship: associative
          elementType:
            namedType: unionField
          keys:
          - fieldName
- name: structField
  map:
    fields:
    - name: name
      type:
        scalar: string
    - name: type
      type:
        namedType: typeRef
    - name: default
      type:
        namedType: __untyped_atomic_
- name: list
  map:
    fields:
    - name: elementType
      type:
        namedType: typeRef
    - name: elementRelationship
      type:
        scalar: string
    - name: keys
      type:
        list:
          elementType:
            scalar: string
- name: untyped
  map:
    fields:
    - name: elementRelationship
      type:
        scalar: string
- name: __untyped_atomic_
  scalar: untyped
  list:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
  map:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
`
```

## type Atom

Atom represents the smallest possible pieces of the type system. Each set field in the Atom represents a possible type for the object. If none of the fields are set, any object will fail validation against the atom.

```go
type Atom struct {
    *Scalar `yaml:"scalar,omitempty"`
    *List   `yaml:"list,omitempty"`
    *Map    `yaml:"map,omitempty"`
}
```

### func \(\*Atom\) Equals

```go
func (a *Atom) Equals(b *Atom) bool
```

Equals returns true iff the two Atoms are equal.

## type ElementRelationship

ElementRelationship is an enum of the different possible relationships between the elements of container types \(maps, lists\).

```go
type ElementRelationship string
```

## type List

List represents a type which contains a zero or more elements, all of the same subtype. Lists may be either associative: each element is more or less independent and could be managed by separate entities in the system; or atomic, where the elements are heavily dependent on each other: it is not sensible to change one element without considering the ramifications on all the other elements.

```go
type List struct {
    // ElementType is the type of the list's elements.
    ElementType TypeRef `yaml:"elementType,omitempty"`

    // ElementRelationship states the relationship between the list's elements
    // and must have one of these values:
    // * `atomic`: the list is treated as a single entity, like a scalar.
    // * `associative`:
    //   - If the list element is a scalar, the list is treated as a set.
    //   - If the list element is a map, the list is treated as a map.
    // There is no default for this value for lists; all schemas must
    // explicitly state the element relationship for all lists.
    ElementRelationship ElementRelationship `yaml:"elementRelationship,omitempty"`

    // Iff ElementRelationship is `associative`, and the element type is
    // map, then Keys must have non-zero length, and it lists the fields
    // of the element's map type which are to be used as the keys of the
    // list.
    //
    // TODO: change this to "non-atomic struct" above and make the code reflect this.
    //
    // Each key must refer to a single field name (no nesting, not JSONPath).
    Keys []string `yaml:"keys,omitempty"`
}
```

### func \(\*List\) Equals

```go
func (a *List) Equals(b *List) bool
```

Equals returns true iff the two Lists are equal.

## type Map

Map is a key\-value pair. Its default semantics are the same as an associative list, but: \* It is serialized differently: map:  \{"k": \{"value": "v"\}\} list: \[\{"key": "k", "value": "v"\}\] \* Keys must be string typed. \* Keys can't have multiple components.

Optionally, maps may be atomic \(for example, imagine representing an RGB color value\-\-it doesn't make sense to have different actors own the R and G values\).

Maps may also represent a type which is composed of a number of different fields. Each field has a name and a type.

Fields are indexed in a map before the first search so this type should be considered immutable.

```go
type Map struct {
    // Each struct field appears exactly once in this list. The order in
    // this list defines the canonical field ordering.
    Fields []StructField `yaml:"fields,omitempty"`

    // A Union is a grouping of fields with special rules. It may refer to
    // one or more fields in the above list. A given field from the above
    // list may be referenced in exactly 0 or 1 places in the below list.
    // One can have multiple unions in the same struct, but the fields can't
    // overlap between unions.
    Unions []Union `yaml:"unions,omitempty"`

    // ElementType is the type of the structs's unknown fields.
    ElementType TypeRef `yaml:"elementType,omitempty"`

    // ElementRelationship states the relationship between the map's items.
    // * `separable` (or unset) implies that each element is 100% independent.
    // * `atomic` implies that all elements depend on each other, and this
    //   is effectively a scalar / leaf field; it doesn't make sense for
    //   separate actors to set the elements. Example: an RGB color struct;
    //   it would never make sense to "own" only one component of the
    //   color.
    // The default behavior for maps is `separable`; it's permitted to
    // leave this unset to get the default behavior.
    ElementRelationship ElementRelationship `yaml:"elementRelationship,omitempty"`
    // contains filtered or unexported fields
}
```

### func \(\*Map\) Equals

```go
func (a *Map) Equals(b *Map) bool
```

Equals returns true iff the two Maps are equal.

### func \(\*Map\) FindField

```go
func (m *Map) FindField(name string) (StructField, bool)
```

FindField is a convenience function that returns the referenced StructField, if it exists, or \(nil, false\) if it doesn't.

## type Scalar

Scalar \(AKA "primitive"\) represents a type which has a single value which is either numeric, string, or boolean.

TODO: split numeric into float/int? Something even more fine\-grained?

```go
type Scalar string
```

## type Schema

Schema is a list of named types.

Schema types are indexed in a map before the first search so this type should be considered immutable.

```go
type Schema struct {
    Types []TypeDef `yaml:"types,omitempty"`
    // contains filtered or unexported fields
}
```

### func \(\*Schema\) Equals

```go
func (a *Schema) Equals(b *Schema) bool
```

Equals returns true iff the two Schemas are equal.

### func \(\*Schema\) FindNamedType

```go
func (s *Schema) FindNamedType(name string) (TypeDef, bool)
```

FindNamedType is a convenience function that returns the referenced TypeDef, if it exists, or \(nil, false\) if it doesn't.

### func \(\*Schema\) Resolve

```go
func (s *Schema) Resolve(tr TypeRef) (Atom, bool)
```

Resolve is a convenience function which returns the atom referenced, whether it is inline or named. Returns \(Atom\{\}, false\) if the type can't be resolved.

This allows callers to not care about the difference between a \(possibly inlined\) reference and a definition.

## type StructField

StructField pairs a field name with a field type.

```go
type StructField struct {
    // Name is the field name.
    Name string `yaml:"name,omitempty"`
    // Type is the field type.
    Type TypeRef `yaml:"type,omitempty"`
    // Default value for the field, nil if not present.
    Default interface{} `yaml:"default,omitempty"`
}
```

### func \(\*StructField\) Equals

```go
func (a *StructField) Equals(b *StructField) bool
```

Equals returns true iff the two StructFields are equal.

## type TypeDef

TypeDef represents a named type in a schema.

```go
type TypeDef struct {
    // Top level types should be named. Every type must have a unique name.
    Name string `yaml:"name,omitempty"`

    Atom `yaml:"atom,omitempty,inline"`
}
```

### func \(\*TypeDef\) Equals

```go
func (a *TypeDef) Equals(b *TypeDef) bool
```

Equals returns true iff the two TypeDefs are equal.

## type TypeRef

TypeRef either refers to a named type or declares an inlined type.

```go
type TypeRef struct {
    // Either the name or one member of Atom should be set.
    NamedType *string `yaml:"namedType,omitempty"`
    Inlined   Atom    `yaml:",inline,omitempty"`
}
```

### func \(\*TypeRef\) Equals

```go
func (a *TypeRef) Equals(b *TypeRef) bool
```

Equals returns true iff the two TypeRefs are equal.

Note that two typerefs that have an equivalent type but where one is inlined and the other is named, are not considered equal.

## type TypeSpecifier

A TypeSpecifier references a particular type in a schema.

```go
type TypeSpecifier struct {
    Type   TypeRef `yaml:"type,omitempty"`
    Schema Schema  `yaml:"schema,omitempty"`
}
```

## type Union

Union, or oneof, means that only one of multiple fields of a structure can be set at a time. Setting the discriminator helps clearing oher fields: \- If discriminator changed to non\-nil, and a new field has been added that doesn't match, an error is returned, \- If discriminator hasn't changed and two fields or more are set, an error is returned, \- If discriminator changed to non\-nil, all other fields but the discriminated one will be cleared, \- Otherwise, If only one field is left, update discriminator to that value.

```go
type Union struct {
    // Discriminator, if present, is the name of the field that
    // discriminates fields in the union. The mapping between the value of
    // the discriminator and the field is done by using the Fields list
    // below.
    Discriminator *string `yaml:"discriminator,omitempty"`

    // DeduceInvalidDiscriminator indicates if the discriminator
    // should be updated automatically based on the fields set. This
    // typically defaults to false since we don't want to deduce by
    // default (the behavior exists to maintain compatibility on
    // existing types and shouldn't be used for new types).
    DeduceInvalidDiscriminator bool `yaml:"deduceInvalidDiscriminator,omitempty"`

    // This is the list of fields that belong to this union. All the
    // fields present in here have to be part of the parent
    // structure. Discriminator (if oneOf has one), is NOT included in
    // this list. The value for field is how we map the name of the field
    // to actual value for discriminator.
    Fields []UnionField `yaml:"fields,omitempty"`
}
```

### func \(\*Union\) Equals

```go
func (a *Union) Equals(b *Union) bool
```

Equals returns true iff the two Unions are equal.

## type UnionField

UnionFields are mapping between the fields that are part of the union and their discriminated value. The discriminated value has to be set, and should not conflict with other discriminated value in the list.

```go
type UnionField struct {
    // FieldName is the name of the field that is part of the union. This
    // is the serialized form of the field.
    FieldName string `yaml:"fieldName"`
    // Discriminatorvalue is the value of the discriminator to
    // select that field. If the union doesn't have a discriminator,
    // this field is ignored.
    DiscriminatorValue string `yaml:"discriminatorValue"`
}
```

### func \(\*UnionField\) Equals

```go
func (a *UnionField) Equals(b *UnionField) bool
```

Equals returns true iff the two UnionFields are equal.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
