<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# value

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/sigs.k8s.io/structured-merge-diff/v4/value"
```

Package value defines types for an in\-memory representation of yaml or json objects, organized for convenient comparison with a schema \(as defined by the sibling schema package\). Functions for reading and writing the objects are also provided.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func BoolCompare(lhs, rhs bool) int](<#func-boolcompare>)
- [func Compare(lhs, rhs Value) int](<#func-compare>)
- [func CompareUsing(a Allocator, lhs, rhs Value) int](<#func-compareusing>)
- [func Equals(lhs, rhs Value) bool](<#func-equals>)
- [func EqualsUsing(a Allocator, lhs, rhs Value) bool](<#func-equalsusing>)
- [func FloatCompare(lhs, rhs float64) int](<#func-floatcompare>)
- [func IntCompare(lhs, rhs int64) int](<#func-intcompare>)
- [func Less(lhs, rhs Value) bool](<#func-less>)
- [func ListCompare(lhs, rhs List) int](<#func-listcompare>)
- [func ListCompareUsing(a Allocator, lhs, rhs List) int](<#func-listcompareusing>)
- [func ListEquals(lhs, rhs List) bool](<#func-listequals>)
- [func ListEqualsUsing(a Allocator, lhs, rhs List) bool](<#func-listequalsusing>)
- [func ListLess(lhs, rhs List) bool](<#func-listless>)
- [func MapCompare(lhs, rhs Map) int](<#func-mapcompare>)
- [func MapCompareUsing(a Allocator, lhs, rhs Map) int](<#func-mapcompareusing>)
- [func MapEquals(lhs, rhs Map) bool](<#func-mapequals>)
- [func MapEqualsUsing(a Allocator, lhs, rhs Map) bool](<#func-mapequalsusing>)
- [func MapLess(lhs, rhs Map) bool](<#func-mapless>)
- [func MapZip(lhs, rhs Map, order MapTraverseOrder, fn func(key string, lhs, rhs Value) bool) bool](<#func-mapzip>)
- [func MapZipUsing(a Allocator, lhs, rhs Map, order MapTraverseOrder, fn func(key string, lhs, rhs Value) bool) bool](<#func-mapzipusing>)
- [func ToJSON(v Value) ([]byte, error)](<#func-tojson>)
- [func ToString(v Value) string](<#func-tostring>)
- [func ToYAML(v Value) ([]byte, error)](<#func-toyaml>)
- [func WriteJSONStream(v Value, stream *jsoniter.Stream)](<#func-writejsonstream>)
- [type Allocator](<#type-allocator>)
  - [func NewFreelistAllocator() Allocator](<#func-newfreelistallocator>)
- [type Field](<#type-field>)
- [type FieldCacheEntry](<#type-fieldcacheentry>)
  - [func (f *FieldCacheEntry) CanOmit(fieldVal reflect.Value) bool](<#func-fieldcacheentry-canomit>)
  - [func (f *FieldCacheEntry) GetFrom(structVal reflect.Value) reflect.Value](<#func-fieldcacheentry-getfrom>)
- [type FieldList](<#type-fieldlist>)
  - [func (f FieldList) Compare(rhs FieldList) int](<#func-fieldlist-compare>)
  - [func (f FieldList) Equals(rhs FieldList) bool](<#func-fieldlist-equals>)
  - [func (f FieldList) Less(rhs FieldList) bool](<#func-fieldlist-less>)
  - [func (f FieldList) Sort()](<#func-fieldlist-sort>)
- [type List](<#type-list>)
- [type ListRange](<#type-listrange>)
- [type Map](<#type-map>)
- [type MapTraverseOrder](<#type-maptraverseorder>)
- [type TypeReflectCacheEntry](<#type-typereflectcacheentry>)
  - [func TypeReflectEntryOf(t reflect.Type) *TypeReflectCacheEntry](<#func-typereflectentryof>)
  - [func (e TypeReflectCacheEntry) CanConvertFromUnstructured() bool](<#func-typereflectcacheentry-canconvertfromunstructured>)
  - [func (e TypeReflectCacheEntry) CanConvertToUnstructured() bool](<#func-typereflectcacheentry-canconverttounstructured>)
  - [func (e TypeReflectCacheEntry) Fields() map[string]*FieldCacheEntry](<#func-typereflectcacheentry-fields>)
  - [func (e TypeReflectCacheEntry) FromUnstructured(sv, dv reflect.Value) error](<#func-typereflectcacheentry-fromunstructured>)
  - [func (e TypeReflectCacheEntry) OrderedFields() []*FieldCacheEntry](<#func-typereflectcacheentry-orderedfields>)
  - [func (e TypeReflectCacheEntry) ToUnstructured(sv reflect.Value) (interface{}, error)](<#func-typereflectcacheentry-tounstructured>)
- [type UnstructuredConverter](<#type-unstructuredconverter>)
- [type Value](<#type-value>)
  - [func FromJSON(input []byte) (Value, error)](<#func-fromjson>)
  - [func FromJSONFast(input []byte) (Value, error)](<#func-fromjsonfast>)
  - [func NewValueInterface(v interface{}) Value](<#func-newvalueinterface>)
  - [func NewValueReflect(value interface{}) (Value, error)](<#func-newvaluereflect>)
  - [func ReadJSONIter(iter *jsoniter.Iterator) (Value, error)](<#func-readjsoniter>)


## Constants

```go
const (
    // Unordered indicates that the map traversal has no ordering requirement.
    Unordered = iota
    // LexicalKeyOrder indicates that the map traversal is ordered by key, lexically.
    LexicalKeyOrder
)
```

## Variables

```go
var EmptyRange = &emptyRange{}
```

HeapAllocator simply allocates objects to the heap. It is the default allocator used receiver functions on the value interfaces that do not accept an allocator and should be used whenever allocating objects that will not be given back to an allocator by calling Allocator.Free\(Value\).

```go
var HeapAllocator = &heapAllocator{}
```

## func BoolCompare

```go
func BoolCompare(lhs, rhs bool) int
```

Compare compares booleans. The result will be 0 if b==rhs, \-1 if b \< rhs, and \+1 if b \> rhs.

## func Compare

```go
func Compare(lhs, rhs Value) int
```

Compare provides a total ordering for Value \(so that they can be sorted, even if they are of different types\). The result will be 0 if v==rhs, \-1 if v \< rhs, and \+1 if v \> rhs.

## func CompareUsing

```go
func CompareUsing(a Allocator, lhs, rhs Value) int
```

CompareUsing uses the provided allocator and provides a total ordering for Value \(so that they can be sorted, even if they are of different types\). The result will be 0 if v==rhs, \-1 if v \< rhs, and \+1 if v \> rhs.

## func Equals

```go
func Equals(lhs, rhs Value) bool
```

Equals returns true iff the two values are equal.

## func EqualsUsing

```go
func EqualsUsing(a Allocator, lhs, rhs Value) bool
```

EqualsUsing uses the provided allocator and returns true iff the two values are equal.

## func FloatCompare

```go
func FloatCompare(lhs, rhs float64) int
```

Compare compares floats. The result will be 0 if lhs==rhs, \-1 if f \< rhs, and \+1 if f \> rhs.

## func IntCompare

```go
func IntCompare(lhs, rhs int64) int
```

IntCompare compares integers. The result will be 0 if i==rhs, \-1 if i \< rhs, and \+1 if i \> rhs.

## func Less

```go
func Less(lhs, rhs Value) bool
```

Less provides a total ordering for Value \(so that they can be sorted, even if they are of different types\).

## func ListCompare

```go
func ListCompare(lhs, rhs List) int
```

ListCompare compares two lists lexically. The result will be 0 if l==rhs, \-1 if l \< rhs, and \+1 if l \> rhs.

## func ListCompareUsing

```go
func ListCompareUsing(a Allocator, lhs, rhs List) int
```

ListCompareUsing uses the provided allocator and compares two lists lexically. The result will be 0 if l==rhs, \-1 if l \< rhs, and \+1 if l \> rhs.

## func ListEquals

```go
func ListEquals(lhs, rhs List) bool
```

ListEquals compares two lists lexically. WARN: This is a naive implementation, calling lhs.Equals\(rhs\) is typically the most efficient.

## func ListEqualsUsing

```go
func ListEqualsUsing(a Allocator, lhs, rhs List) bool
```

ListEqualsUsing uses the provided allocator and compares two lists lexically. WARN: This is a naive implementation, calling lhs.EqualsUsing\(allocator, rhs\) is typically the most efficient.

## func ListLess

```go
func ListLess(lhs, rhs List) bool
```

ListLess compares two lists lexically.

## func MapCompare

```go
func MapCompare(lhs, rhs Map) int
```

MapCompare compares two maps lexically.

## func MapCompareUsing

```go
func MapCompareUsing(a Allocator, lhs, rhs Map) int
```

MapCompareUsing uses the provided allocator and compares two maps lexically.

## func MapEquals

```go
func MapEquals(lhs, rhs Map) bool
```

MapEquals returns true if lhs == rhs, false otherwise. This function acts on generic types and should not be used by callers, but can help implement Map.Equals. WARN: This is a naive implementation, calling lhs.Equals\(rhs\) is typically the most efficient.

## func MapEqualsUsing

```go
func MapEqualsUsing(a Allocator, lhs, rhs Map) bool
```

MapEqualsUsing uses the provided allocator and returns true if lhs == rhs, false otherwise. This function acts on generic types and should not be used by callers, but can help implement Map.Equals. WARN: This is a naive implementation, calling lhs.EqualsUsing\(allocator, rhs\) is typically the most efficient.

## func MapLess

```go
func MapLess(lhs, rhs Map) bool
```

MapLess compares two maps lexically.

## func MapZip

```go
func MapZip(lhs, rhs Map, order MapTraverseOrder, fn func(key string, lhs, rhs Value) bool) bool
```

MapZip iterates over the entries of two maps together. If both maps contain a value for a given key, fn is called with the values from both maps, otherwise it is called with the value of the map that contains the key and nil for the other map. Returning false in the closure prematurely stops the iteration.

## func MapZipUsing

```go
func MapZipUsing(a Allocator, lhs, rhs Map, order MapTraverseOrder, fn func(key string, lhs, rhs Value) bool) bool
```

MapZipUsing uses the provided allocator and iterates over the entries of two maps together. If both maps contain a value for a given key, fn is called with the values from both maps, otherwise it is called with the value of the map that contains the key and nil for the other map. Returning false in the closure prematurely stops the iteration.

## func ToJSON

```go
func ToJSON(v Value) ([]byte, error)
```

ToJSON is a helper function for producing a JSon document.

## func ToString

```go
func ToString(v Value) string
```

ToString returns a human\-readable representation of the value.

## func ToYAML

```go
func ToYAML(v Value) ([]byte, error)
```

ToYAML marshals a value as YAML.

## func WriteJSONStream

```go
func WriteJSONStream(v Value, stream *jsoniter.Stream)
```

WriteJSONStream writes a value into a JSON stream.

## type Allocator

Allocator provides a value object allocation strategy. Value objects can be allocated by passing an allocator to the "Using" receiver functions on the value interfaces, e.g. Map.ZipUsing\(allocator, ...\). Value objects returned from "Using" functions should be given back to the allocator once longer needed by calling Allocator.Free\(Value\).

```go
type Allocator interface {
    // Free gives the allocator back any value objects returned by the "Using"
    // receiver functions on the value interfaces.
    // interface{} may be any of: Value, Map, List or Range.
    Free(interface{})
    // contains filtered or unexported methods
}
```

### func NewFreelistAllocator

```go
func NewFreelistAllocator() Allocator
```

NewFreelistAllocator creates freelist based allocator. This allocator provides fast allocation and freeing of short lived value objects.

The freelists are bounded in size by freelistMaxSize. If more than this amount of value objects is allocated at once, the excess will be returned to the heap for garbage collection when freed.

This allocator is unsafe and must not be accessed concurrently by goroutines.

This allocator works well for traversal of value data trees. Typical usage is to acquire a freelist at the beginning of the traversal and use it through out for all temporary value access.

## type Field

Field is an individual key\-value pair.

```go
type Field struct {
    Name  string
    Value Value
}
```

## type FieldCacheEntry

FieldCacheEntry keeps data gathered using reflection about how the field of a struct is converted to/from unstructured.

```go
type FieldCacheEntry struct {
    // JsonName returns the name of the field according to the json tags on the struct field.
    JsonName string

    TypeEntry *TypeReflectCacheEntry
    // contains filtered or unexported fields
}
```

### func \(\*FieldCacheEntry\) CanOmit

```go
func (f *FieldCacheEntry) CanOmit(fieldVal reflect.Value) bool
```

### func \(\*FieldCacheEntry\) GetFrom

```go
func (f *FieldCacheEntry) GetFrom(structVal reflect.Value) reflect.Value
```

GetFrom returns the field identified by this FieldCacheEntry from the provided struct.

## type FieldList

FieldList is a list of key\-value pairs. Each field is expected to have a different name.

```go
type FieldList []Field
```

### func \(FieldList\) Compare

```go
func (f FieldList) Compare(rhs FieldList) int
```

Compare compares two lists lexically. The result will be 0 if f==rhs, \-1 if f \< rhs, and \+1 if f \> rhs.

### func \(FieldList\) Equals

```go
func (f FieldList) Equals(rhs FieldList) bool
```

Equals returns true if the two fieldslist are equals, false otherwise.

### func \(FieldList\) Less

```go
func (f FieldList) Less(rhs FieldList) bool
```

Less compares two lists lexically.

### func \(FieldList\) Sort

```go
func (f FieldList) Sort()
```

Sort sorts the field list by Name.

## type List

List represents a list object.

```go
type List interface {
    // Length returns how many items can be found in the map.
    Length() int
    // At returns the item at the given position in the map. It will
    // panic if the index is out of range.
    At(int) Value
    // AtUsing uses the provided allocator and returns the item at the given
    // position in the map. It will panic if the index is out of range.
    // The returned Value should be given back to the Allocator when no longer needed
    // by calling Allocator.Free(Value).
    AtUsing(Allocator, int) Value
    // Range returns a ListRange for iterating over the items in the list.
    Range() ListRange
    // RangeUsing uses the provided allocator and returns a ListRange for
    // iterating over the items in the list.
    // The returned Range should be given back to the Allocator when no longer needed
    // by calling Allocator.Free(Value).
    RangeUsing(Allocator) ListRange
    // Equals compares the two lists, and return true if they are the same, false otherwise.
    // Implementations can use ListEquals as a general implementation for this methods.
    Equals(List) bool
    // EqualsUsing uses the provided allocator and compares the two lists, and return true if
    // they are the same, false otherwise. Implementations can use ListEqualsUsing as a general
    // implementation for this methods.
    EqualsUsing(Allocator, List) bool
}
```

## type ListRange

ListRange represents a single iteration across the items of a list.

```go
type ListRange interface {
    // Next increments to the next item in the range, if there is one, and returns true, or returns false if there are no more items.
    Next() bool
    // Item returns the index and value of the current item in the range. or panics if there is no current item.
    // For efficiency, Item may reuse the values returned by previous Item calls. Callers should be careful avoid holding
    // pointers to the value returned by Item() that escape the iteration loop since they become invalid once either
    // Item() or Allocator.Free() is called.
    Item() (index int, value Value)
}
```

## type Map

Map represents a Map or go structure.

```go
type Map interface {
    // Set changes or set the value of the given key.
    Set(key string, val Value)
    // Get returns the value for the given key, if present, or (nil, false) otherwise.
    Get(key string) (Value, bool)
    // GetUsing uses the provided allocator and returns the value for the given key,
    // if present, or (nil, false) otherwise.
    // The returned Value should be given back to the Allocator when no longer needed
    // by calling Allocator.Free(Value).
    GetUsing(a Allocator, key string) (Value, bool)
    // Has returns true if the key is present, or false otherwise.
    Has(key string) bool
    // Delete removes the key from the map.
    Delete(key string)
    // Equals compares the two maps, and return true if they are the same, false otherwise.
    // Implementations can use MapEquals as a general implementation for this methods.
    Equals(other Map) bool
    // EqualsUsing uses the provided allocator and compares the two maps, and return true if
    // they are the same, false otherwise. Implementations can use MapEqualsUsing as a general
    // implementation for this methods.
    EqualsUsing(a Allocator, other Map) bool
    // Iterate runs the given function for each key/value in the
    // map. Returning false in the closure prematurely stops the
    // iteration.
    Iterate(func(key string, value Value) bool) bool
    // IterateUsing uses the provided allocator and runs the given function for each key/value
    // in the map. Returning false in the closure prematurely stops the iteration.
    IterateUsing(Allocator, func(key string, value Value) bool) bool
    // Length returns the number of items in the map.
    Length() int
    // Empty returns true if the map is empty.
    Empty() bool
    // Zip iterates over the entries of two maps together. If both maps contain a value for a given key, fn is called
    // with the values from both maps, otherwise it is called with the value of the map that contains the key and nil
    // for the map that does not contain the key. Returning false in the closure prematurely stops the iteration.
    Zip(other Map, order MapTraverseOrder, fn func(key string, lhs, rhs Value) bool) bool
    // ZipUsing uses the provided allocator and iterates over the entries of two maps together. If both maps
    // contain a value for a given key, fn is called with the values from both maps, otherwise it is called with
    // the value of the map that contains the key and nil for the map that does not contain the key. Returning
    // false in the closure prematurely stops the iteration.
    ZipUsing(a Allocator, other Map, order MapTraverseOrder, fn func(key string, lhs, rhs Value) bool) bool
}
```

## type MapTraverseOrder

MapTraverseOrder defines the map traversal ordering available.

```go
type MapTraverseOrder int
```

## type TypeReflectCacheEntry

TypeReflectCacheEntry keeps data gathered using reflection about how a type is converted to/from unstructured.

```go
type TypeReflectCacheEntry struct {
    // contains filtered or unexported fields
}
```

### func TypeReflectEntryOf

```go
func TypeReflectEntryOf(t reflect.Type) *TypeReflectCacheEntry
```

TypeReflectEntryOf returns the TypeReflectCacheEntry of the provided reflect.Type.

### func \(TypeReflectCacheEntry\) CanConvertFromUnstructured

```go
func (e TypeReflectCacheEntry) CanConvertFromUnstructured() bool
```

CanConvertFromUnstructured returns true if this TypeReflectCacheEntry can convert objects of the type from unstructured.

### func \(TypeReflectCacheEntry\) CanConvertToUnstructured

```go
func (e TypeReflectCacheEntry) CanConvertToUnstructured() bool
```

CanConvertToUnstructured returns true if this TypeReflectCacheEntry can convert values of its type to unstructured.

### func \(TypeReflectCacheEntry\) Fields

```go
func (e TypeReflectCacheEntry) Fields() map[string]*FieldCacheEntry
```

Fields returns a map of JSON field name to FieldCacheEntry for structs, or nil for non\-structs.

### func \(TypeReflectCacheEntry\) FromUnstructured

```go
func (e TypeReflectCacheEntry) FromUnstructured(sv, dv reflect.Value) error
```

FromUnstructured converts the provided source value from unstructured into the provided destination value.

### func \(TypeReflectCacheEntry\) OrderedFields

```go
func (e TypeReflectCacheEntry) OrderedFields() []*FieldCacheEntry
```

Fields returns a map of JSON field name to FieldCacheEntry for structs, or nil for non\-structs.

### func \(TypeReflectCacheEntry\) ToUnstructured

```go
func (e TypeReflectCacheEntry) ToUnstructured(sv reflect.Value) (interface{}, error)
```

ToUnstructured converts the provided value to unstructured and returns it.

## type UnstructuredConverter

UnstructuredConverter defines how a type can be converted directly to unstructured. Types that implement json.Marshaler may also optionally implement this interface to provide a more direct and more efficient conversion. All types that choose to implement this interface must still implement this same conversion via json.Marshaler.

```go
type UnstructuredConverter interface {
    json.Marshaler // require that json.Marshaler is implemented

    // ToUnstructured returns the unstructured representation.
    ToUnstructured() interface{}
}
```

## type Value

A Value corresponds to an 'atom' in the schema. It should return true for at least one of the IsXXX methods below, or the value is considered "invalid"

```go
type Value interface {
    // IsMap returns true if the Value is a Map, false otherwise.
    IsMap() bool
    // IsList returns true if the Value is a List, false otherwise.
    IsList() bool
    // IsBool returns true if the Value is a bool, false otherwise.
    IsBool() bool
    // IsInt returns true if the Value is a int64, false otherwise.
    IsInt() bool
    // IsFloat returns true if the Value is a float64, false
    // otherwise.
    IsFloat() bool
    // IsString returns true if the Value is a string, false
    // otherwise.
    IsString() bool
    // IsMap returns true if the Value is null, false otherwise.
    IsNull() bool

    // AsMap converts the Value into a Map (or panic if the type
    // doesn't allow it).
    AsMap() Map
    // AsMapUsing uses the provided allocator and converts the Value
    // into a Map (or panic if the type doesn't allow it).
    AsMapUsing(Allocator) Map
    // AsList converts the Value into a List (or panic if the type
    // doesn't allow it).
    AsList() List
    // AsListUsing uses the provided allocator and converts the Value
    // into a List (or panic if the type doesn't allow it).
    AsListUsing(Allocator) List
    // AsBool converts the Value into a bool (or panic if the type
    // doesn't allow it).
    AsBool() bool
    // AsInt converts the Value into an int64 (or panic if the type
    // doesn't allow it).
    AsInt() int64
    // AsFloat converts the Value into a float64 (or panic if the type
    // doesn't allow it).
    AsFloat() float64
    // AsString converts the Value into a string (or panic if the type
    // doesn't allow it).
    AsString() string

    // Unstructured converts the Value into an Unstructured interface{}.
    Unstructured() interface{}
}
```

### func FromJSON

```go
func FromJSON(input []byte) (Value, error)
```

FromJSON is a helper function for reading a JSON document.

### func FromJSONFast

```go
func FromJSONFast(input []byte) (Value, error)
```

FromJSONFast is a helper function for reading a JSON document.

### func NewValueInterface

```go
func NewValueInterface(v interface{}) Value
```

NewValueInterface creates a Value backed by an "interface\{\}" type, typically an unstructured object in Kubernetes world. interface\{\} must be one of: map\[string\]interface\{\}, map\[interface\{\}\]interface\{\}, \[\]interface\{\}, int types, float types, string or boolean. Nested interface\{\} must also be one of these types.

### func NewValueReflect

```go
func NewValueReflect(value interface{}) (Value, error)
```

NewValueReflect creates a Value backed by an "interface\{\}" type, typically an structured object in Kubernetes world that is uses reflection to expose. The provided "interface\{\}" value must be a pointer so that the value can be modified via reflection. The provided "interface\{\}" may contain structs and types that are converted to Values by the jsonMarshaler interface.

### func ReadJSONIter

```go
func ReadJSONIter(iter *jsoniter.Iterator) (Value, error)
```

ReadJSONIter reads a Value from a JSON iterator.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
