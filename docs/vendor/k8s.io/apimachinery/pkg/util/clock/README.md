<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# clock

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/k8s.io/apimachinery/pkg/util/clock"
```

## Index

- [type Clock](<#type-clock>)
- [type FakeClock](<#type-fakeclock>)
  - [func NewFakeClock(t time.Time) *FakeClock](<#func-newfakeclock>)
  - [func (f *FakeClock) After(d time.Duration) <-chan time.Time](<#func-fakeclock-after>)
  - [func (f *FakeClock) AfterFunc(d time.Duration, cb func()) Timer](<#func-fakeclock-afterfunc>)
  - [func (f *FakeClock) HasWaiters() bool](<#func-fakeclock-haswaiters>)
  - [func (f *FakeClock) NewTicker(d time.Duration) Ticker](<#func-fakeclock-newticker>)
  - [func (f *FakeClock) NewTimer(d time.Duration) Timer](<#func-fakeclock-newtimer>)
  - [func (f *FakeClock) SetTime(t time.Time)](<#func-fakeclock-settime>)
  - [func (f *FakeClock) Sleep(d time.Duration)](<#func-fakeclock-sleep>)
  - [func (f *FakeClock) Step(d time.Duration)](<#func-fakeclock-step>)
- [type FakePassiveClock](<#type-fakepassiveclock>)
  - [func NewFakePassiveClock(t time.Time) *FakePassiveClock](<#func-newfakepassiveclock>)
  - [func (f *FakePassiveClock) Now() time.Time](<#func-fakepassiveclock-now>)
  - [func (f *FakePassiveClock) SetTime(t time.Time)](<#func-fakepassiveclock-settime>)
  - [func (f *FakePassiveClock) Since(ts time.Time) time.Duration](<#func-fakepassiveclock-since>)
- [type IntervalClock](<#type-intervalclock>)
  - [func (*IntervalClock) After(d time.Duration) <-chan time.Time](<#func-intervalclock-after>)
  - [func (*IntervalClock) AfterFunc(d time.Duration, cb func()) Timer](<#func-intervalclock-afterfunc>)
  - [func (*IntervalClock) NewTicker(d time.Duration) Ticker](<#func-intervalclock-newticker>)
  - [func (*IntervalClock) NewTimer(d time.Duration) Timer](<#func-intervalclock-newtimer>)
  - [func (i *IntervalClock) Now() time.Time](<#func-intervalclock-now>)
  - [func (i *IntervalClock) Since(ts time.Time) time.Duration](<#func-intervalclock-since>)
  - [func (*IntervalClock) Sleep(d time.Duration)](<#func-intervalclock-sleep>)
- [type PassiveClock](<#type-passiveclock>)
- [type RealClock](<#type-realclock>)
  - [func (RealClock) After(d time.Duration) <-chan time.Time](<#func-realclock-after>)
  - [func (RealClock) AfterFunc(d time.Duration, f func()) Timer](<#func-realclock-afterfunc>)
  - [func (RealClock) NewTicker(d time.Duration) Ticker](<#func-realclock-newticker>)
  - [func (RealClock) NewTimer(d time.Duration) Timer](<#func-realclock-newtimer>)
  - [func (RealClock) Now() time.Time](<#func-realclock-now>)
  - [func (RealClock) Since(ts time.Time) time.Duration](<#func-realclock-since>)
  - [func (RealClock) Sleep(d time.Duration)](<#func-realclock-sleep>)
- [type Ticker](<#type-ticker>)
- [type Timer](<#type-timer>)


## type Clock

Clock allows for injecting fake or real clocks into code that needs to do arbitrary things based on time.

```go
type Clock interface {
    PassiveClock
    After(time.Duration) <-chan time.Time
    AfterFunc(time.Duration, func()) Timer
    NewTimer(time.Duration) Timer
    Sleep(time.Duration)
    NewTicker(time.Duration) Ticker
}
```

## type FakeClock

FakeClock implements Clock, but returns an arbitrary time.

```go
type FakeClock struct {
    FakePassiveClock
    // contains filtered or unexported fields
}
```

### func NewFakeClock

```go
func NewFakeClock(t time.Time) *FakeClock
```

NewFakeClock returns a new FakeClock

### func \(\*FakeClock\) After

```go
func (f *FakeClock) After(d time.Duration) <-chan time.Time
```

After is the Fake version of time.After\(d\).

### func \(\*FakeClock\) AfterFunc

```go
func (f *FakeClock) AfterFunc(d time.Duration, cb func()) Timer
```

AfterFunc is the Fake version of time.AfterFunc\(d, callback\).

### func \(\*FakeClock\) HasWaiters

```go
func (f *FakeClock) HasWaiters() bool
```

HasWaiters returns true if After or AfterFunc has been called on f but not yet satisfied \(so you can write race\-free tests\).

### func \(\*FakeClock\) NewTicker

```go
func (f *FakeClock) NewTicker(d time.Duration) Ticker
```

NewTicker returns a new Ticker.

### func \(\*FakeClock\) NewTimer

```go
func (f *FakeClock) NewTimer(d time.Duration) Timer
```

NewTimer is the Fake version of time.NewTimer\(d\).

### func \(\*FakeClock\) SetTime

```go
func (f *FakeClock) SetTime(t time.Time)
```

SetTime sets the time on a FakeClock.

### func \(\*FakeClock\) Sleep

```go
func (f *FakeClock) Sleep(d time.Duration)
```

Sleep pauses the FakeClock for duration d.

### func \(\*FakeClock\) Step

```go
func (f *FakeClock) Step(d time.Duration)
```

Step moves clock by Duration, notifies anyone that's called After, Tick, or NewTimer

## type FakePassiveClock

FakePassiveClock implements PassiveClock, but returns an arbitrary time.

```go
type FakePassiveClock struct {
    // contains filtered or unexported fields
}
```

### func NewFakePassiveClock

```go
func NewFakePassiveClock(t time.Time) *FakePassiveClock
```

NewFakePassiveClock returns a new FakePassiveClock.

### func \(\*FakePassiveClock\) Now

```go
func (f *FakePassiveClock) Now() time.Time
```

Now returns f's time.

### func \(\*FakePassiveClock\) SetTime

```go
func (f *FakePassiveClock) SetTime(t time.Time)
```

SetTime sets the time on the FakePassiveClock.

### func \(\*FakePassiveClock\) Since

```go
func (f *FakePassiveClock) Since(ts time.Time) time.Duration
```

Since returns time since the time in f.

## type IntervalClock

IntervalClock implements Clock, but each invocation of Now steps the clock forward the specified duration

```go
type IntervalClock struct {
    Time     time.Time
    Duration time.Duration
}
```

### func \(\*IntervalClock\) After

```go
func (*IntervalClock) After(d time.Duration) <-chan time.Time
```

After is currently unimplemented, will panic. TODO: make interval clock use FakeClock so this can be implemented.

### func \(\*IntervalClock\) AfterFunc

```go
func (*IntervalClock) AfterFunc(d time.Duration, cb func()) Timer
```

AfterFunc is currently unimplemented, will panic. TODO: make interval clock use FakeClock so this can be implemented.

### func \(\*IntervalClock\) NewTicker

```go
func (*IntervalClock) NewTicker(d time.Duration) Ticker
```

NewTicker is currently unimplemented, will panic. TODO: make interval clock use FakeClock so this can be implemented.

### func \(\*IntervalClock\) NewTimer

```go
func (*IntervalClock) NewTimer(d time.Duration) Timer
```

NewTimer is currently unimplemented, will panic. TODO: make interval clock use FakeClock so this can be implemented.

### func \(\*IntervalClock\) Now

```go
func (i *IntervalClock) Now() time.Time
```

Now returns i's time.

### func \(\*IntervalClock\) Since

```go
func (i *IntervalClock) Since(ts time.Time) time.Duration
```

Since returns time since the time in i.

### func \(\*IntervalClock\) Sleep

```go
func (*IntervalClock) Sleep(d time.Duration)
```

Sleep is currently unimplemented; will panic.

## type PassiveClock

PassiveClock allows for injecting fake or real clocks into code that needs to read the current time but does not support scheduling activity in the future.

```go
type PassiveClock interface {
    Now() time.Time
    Since(time.Time) time.Duration
}
```

## type RealClock

RealClock really calls time.Now\(\)

```go
type RealClock struct{}
```

### func \(RealClock\) After

```go
func (RealClock) After(d time.Duration) <-chan time.Time
```

After is the same as time.After\(d\).

### func \(RealClock\) AfterFunc

```go
func (RealClock) AfterFunc(d time.Duration, f func()) Timer
```

AfterFunc is the same as time.AfterFunc\(d, f\).

### func \(RealClock\) NewTicker

```go
func (RealClock) NewTicker(d time.Duration) Ticker
```

NewTicker returns a new Ticker.

### func \(RealClock\) NewTimer

```go
func (RealClock) NewTimer(d time.Duration) Timer
```

NewTimer returns a new Timer.

### func \(RealClock\) Now

```go
func (RealClock) Now() time.Time
```

Now returns the current time.

### func \(RealClock\) Since

```go
func (RealClock) Since(ts time.Time) time.Duration
```

Since returns time since the specified timestamp.

### func \(RealClock\) Sleep

```go
func (RealClock) Sleep(d time.Duration)
```

Sleep pauses the RealClock for duration d.

## type Ticker

Ticker defines the Ticker interface

```go
type Ticker interface {
    C() <-chan time.Time
    Stop()
}
```

## type Timer

Timer allows for injecting fake or real timers into code that needs to do arbitrary things based on time.

```go
type Timer interface {
    C() <-chan time.Time
    Stop() bool
    Reset(d time.Duration) bool
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
