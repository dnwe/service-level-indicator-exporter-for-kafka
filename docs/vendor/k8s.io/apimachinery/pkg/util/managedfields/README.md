<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# managedfields

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/k8s.io/apimachinery/pkg/util/managedfields"
```

## Index

- [func ExtractInto(object runtime.Object, objectType typed.ParseableType, fieldManager string, applyConfiguration interface{}, subresource string) error](<#func-extractinto>)


## func ExtractInto

```go
func ExtractInto(object runtime.Object, objectType typed.ParseableType, fieldManager string, applyConfiguration interface{}, subresource string) error
```

ExtractInto extracts the applied configuration state from object for fieldManager into applyConfiguration. If no managed fields are found for the given fieldManager, no error is returned, but applyConfiguration is left unpopulated. It is possible that no managed fields were found for the fieldManager because other field managers have taken ownership of all the fields previously owned by the fieldManager. It is also possible the fieldManager never owned fields.

The provided object MUST bo a root resource object since subresource objects do not contain their own managed fields. For example, an autoscaling.Scale object read from a "scale" subresource does not have any managed fields and so cannot be used as the object.

If the fields of a subresource are a subset of the fields of the root object, and their field paths and types are exactly the same, then ExtractInto can be called with the root resource as the object and the subresource as the applyConfiguration. This works for "status", obviously, because status is represented by the exact same object as the root resource. This this does NOT work, for example, with the "scale" subresources of Deployment, ReplicaSet and StatefulSet. While the spec.replicas, status.replicas fields are in the same exact field path locations as they are in autoscaling.Scale, the selector fields are in different locations, and are a different type.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
