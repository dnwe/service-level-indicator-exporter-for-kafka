<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# errors

```go
import "k8s.io/apimachinery/pkg/util/errors"
```

Package errors implements various utility functions and types around errors.

## Index

- [Variables](<#variables>)
- [func FilterOut(err error, fns ...Matcher) error](<#func-filterout>)
- [func Reduce(err error) error](<#func-reduce>)
- [type Aggregate](<#type-aggregate>)
  - [func AggregateGoroutines(funcs ...func() error) Aggregate](<#func-aggregategoroutines>)
  - [func CreateAggregateFromMessageCountMap(m MessageCountMap) Aggregate](<#func-createaggregatefrommessagecountmap>)
  - [func Flatten(agg Aggregate) Aggregate](<#func-flatten>)
  - [func NewAggregate(errlist []error) Aggregate](<#func-newaggregate>)
- [type Matcher](<#type-matcher>)
- [type MessageCountMap](<#type-messagecountmap>)


## Variables

ErrPreconditionViolated is returned when the precondition is violated

```go
var ErrPreconditionViolated = errors.New("precondition is violated")
```

## func FilterOut

```go
func FilterOut(err error, fns ...Matcher) error
```

FilterOut removes all errors that match any of the matchers from the input error.  If the input is a singular error, only that error is tested.  If the input implements the Aggregate interface, the list of errors will be processed recursively.

This can be used, for example, to remove known\-OK errors \(such as io.EOF or os.PathNotFound\) from a list of errors.

## func Reduce

```go
func Reduce(err error) error
```

Reduce will return err or, if err is an Aggregate and only has one item, the first item in the aggregate.

## type Aggregate

Aggregate represents an object that contains multiple errors, but does not necessarily have singular semantic meaning. The aggregate can be used with \`errors.Is\(\)\` to check for the occurrence of a specific error type. Errors.As\(\) is not supported, because the caller presumably cares about a specific error of potentially multiple that match the given type.

```go
type Aggregate interface {
    Errors() []error
    Is(error) bool
    // contains filtered or unexported methods
}
```

### func AggregateGoroutines

```go
func AggregateGoroutines(funcs ...func() error) Aggregate
```

AggregateGoroutines runs the provided functions in parallel, stuffing all non\-nil errors into the returned Aggregate. Returns nil if all the functions complete successfully.

### func CreateAggregateFromMessageCountMap

```go
func CreateAggregateFromMessageCountMap(m MessageCountMap) Aggregate
```

CreateAggregateFromMessageCountMap converts MessageCountMap Aggregate

### func Flatten

```go
func Flatten(agg Aggregate) Aggregate
```

Flatten takes an Aggregate, which may hold other Aggregates in arbitrary nesting, and flattens them all into a single Aggregate, recursively.

### func NewAggregate

```go
func NewAggregate(errlist []error) Aggregate
```

NewAggregate converts a slice of errors into an Aggregate interface, which is itself an implementation of the error interface.  If the slice is empty, this returns nil. It will check if any of the element of input error list is nil, to avoid nil pointer panic when call Error\(\).

## type Matcher

Matcher is used to match errors.  Returns true if the error matches.

```go
type Matcher func(error) bool
```

## type MessageCountMap

MessageCountMap contains occurrence for each error message.

```go
type MessageCountMap map[string]int
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
