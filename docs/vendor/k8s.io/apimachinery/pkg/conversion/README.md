<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# conversion

```go
import "k8s.io/apimachinery/pkg/conversion"
```

Package conversion provides go object versioning.

Specifically, conversion provides a way for you to define multiple versions of the same object. You may write functions which implement conversion logic, but for the fields which did not change, copying is automated. This makes it easy to modify the structures you use in memory without affecting the format you store on disk or respond to in your external API calls.

## Index

- [Variables](<#variables>)
- [func Convert_Slice_byte_To_Slice_byte(in *[]byte, out *[]byte, s Scope) error](<#func-convert_slice_byte_to_slice_byte>)
- [func EnforcePtr(obj interface{}) (reflect.Value, error)](<#func-enforceptr>)
- [type ConversionFunc](<#type-conversionfunc>)
- [type ConversionFuncs](<#type-conversionfuncs>)
  - [func NewConversionFuncs() ConversionFuncs](<#func-newconversionfuncs>)
  - [func (c ConversionFuncs) AddUntyped(a, b interface{}, fn ConversionFunc) error](<#func-conversionfuncs-adduntyped>)
  - [func (c ConversionFuncs) Merge(other ConversionFuncs) ConversionFuncs](<#func-conversionfuncs-merge>)
- [type Converter](<#type-converter>)
  - [func NewConverter(nameFn NameFunc) *Converter](<#func-newconverter>)
  - [func (c *Converter) Convert(src, dest interface{}, meta *Meta) error](<#func-converter-convert>)
  - [func (c *Converter) DefaultMeta(t reflect.Type) *Meta](<#func-converter-defaultmeta>)
  - [func (c *Converter) RegisterGeneratedUntypedConversionFunc(a, b interface{}, fn ConversionFunc) error](<#func-converter-registergenerateduntypedconversionfunc>)
  - [func (c *Converter) RegisterIgnoredConversion(from, to interface{}) error](<#func-converter-registerignoredconversion>)
  - [func (c *Converter) RegisterUntypedConversionFunc(a, b interface{}, fn ConversionFunc) error](<#func-converter-registeruntypedconversionfunc>)
  - [func (c *Converter) WithConversions(fns ConversionFuncs) *Converter](<#func-converter-withconversions>)
- [type Equalities](<#type-equalities>)
  - [func EqualitiesOrDie(funcs ...interface{}) Equalities](<#func-equalitiesordie>)
- [type Meta](<#type-meta>)
- [type NameFunc](<#type-namefunc>)
- [type Scope](<#type-scope>)


## Variables

```go
var DefaultNameFunc = func(t reflect.Type) string { return t.Name() }
```

## func Convert\_Slice\_byte\_To\_Slice\_byte

```go
func Convert_Slice_byte_To_Slice_byte(in *[]byte, out *[]byte, s Scope) error
```

Convert\_Slice\_byte\_To\_Slice\_byte prevents recursing into every byte

## func EnforcePtr

```go
func EnforcePtr(obj interface{}) (reflect.Value, error)
```

EnforcePtr ensures that obj is a pointer of some sort. Returns a reflect.Value of the dereferenced pointer, ensuring that it is settable/addressable. Returns an error if this is not possible.

## type ConversionFunc

ConversionFunc converts the object a into the object b, reusing arrays or objects or pointers if necessary. It should return an error if the object cannot be converted or if some data is invalid. If you do not wish a and b to share fields or nested objects, you must copy a before calling this function.

```go
type ConversionFunc func(a, b interface{}, scope Scope) error
```

## type ConversionFuncs

```go
type ConversionFuncs struct {
    // contains filtered or unexported fields
}
```

### func NewConversionFuncs

```go
func NewConversionFuncs() ConversionFuncs
```

### func \(ConversionFuncs\) AddUntyped

```go
func (c ConversionFuncs) AddUntyped(a, b interface{}, fn ConversionFunc) error
```

AddUntyped adds the provided conversion function to the lookup table for the types that are supplied as a and b. a and b must be pointers or an error is returned. This method overwrites previously defined functions.

### func \(ConversionFuncs\) Merge

```go
func (c ConversionFuncs) Merge(other ConversionFuncs) ConversionFuncs
```

Merge returns a new ConversionFuncs that contains all conversions from both other and c, with other conversions taking precedence.

## type Converter

Converter knows how to convert one type to another.

```go
type Converter struct {
    // contains filtered or unexported fields
}
```

### func NewConverter

```go
func NewConverter(nameFn NameFunc) *Converter
```

NewConverter creates a new Converter object.

### func \(\*Converter\) Convert

```go
func (c *Converter) Convert(src, dest interface{}, meta *Meta) error
```

Convert will translate src to dest if it knows how. Both must be pointers. If no conversion func is registered and the default copying mechanism doesn't work on this type pair, an error will be returned. 'meta' is given to allow you to pass information to conversion functions, it is not used by Convert\(\) other than storing it in the scope. Not safe for objects with cyclic references\!

### func \(\*Converter\) DefaultMeta

```go
func (c *Converter) DefaultMeta(t reflect.Type) *Meta
```

DefaultMeta returns meta for a given type.

### func \(\*Converter\) RegisterGeneratedUntypedConversionFunc

```go
func (c *Converter) RegisterGeneratedUntypedConversionFunc(a, b interface{}, fn ConversionFunc) error
```

RegisterGeneratedUntypedConversionFunc registers a function that converts between a and b by passing objects of those types to the provided function. The function \*must\* accept objects of a and b \- this machinery will not enforce any other guarantee.

### func \(\*Converter\) RegisterIgnoredConversion

```go
func (c *Converter) RegisterIgnoredConversion(from, to interface{}) error
```

RegisterIgnoredConversion registers a "no\-op" for conversion, where any requested conversion between from and to is ignored.

### func \(\*Converter\) RegisterUntypedConversionFunc

```go
func (c *Converter) RegisterUntypedConversionFunc(a, b interface{}, fn ConversionFunc) error
```

RegisterUntypedConversionFunc registers a function that converts between a and b by passing objects of those types to the provided function. The function \*must\* accept objects of a and b \- this machinery will not enforce any other guarantee.

### func \(\*Converter\) WithConversions

```go
func (c *Converter) WithConversions(fns ConversionFuncs) *Converter
```

WithConversions returns a Converter that is a copy of c but with the additional fns merged on top.

## type Equalities

The code for this type must be located in third\_party, since it forks from go std lib. But for convenience, we expose the type here, too.

```go
type Equalities struct {
    reflect.Equalities
}
```

### func EqualitiesOrDie

```go
func EqualitiesOrDie(funcs ...interface{}) Equalities
```

For convenience, panics on errors

## type Meta

Meta is supplied by Scheme, when it calls Convert.

```go
type Meta struct {
    // Context is an optional field that callers may use to pass info to conversion functions.
    Context interface{}
}
```

## type NameFunc

```go
type NameFunc func(t reflect.Type) string
```

## type Scope

Scope is passed to conversion funcs to allow them to continue an ongoing conversion. If multiple converters exist in the system, Scope will allow you to use the correct one from a conversion function\-\-that is, the one your conversion function was called by.

```go
type Scope interface {
    // Call Convert to convert sub-objects. Note that if you call it with your own exact
    // parameters, you'll run out of stack space before anything useful happens.
    Convert(src, dest interface{}) error

    // Meta returns any information originally passed to Convert.
    Meta() *Meta
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
