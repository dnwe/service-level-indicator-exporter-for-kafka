<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# runtime

```go
import "k8s.io/apimachinery/pkg/runtime"
```

Package runtime defines conversions between generic types and structs to map query strings to struct objects.

Package runtime includes helper functions for working with API objects that follow the kubernetes API object conventions, which are:

0. Your API objects have a common metadata struct member, TypeMeta.

1. Your code refers to an internal set of API objects.

2. In a separate package, you have an external set of API objects.

3. The external set is considered to be versioned, and no breaking changes are ever made to it \(fields may be added but not changed or removed\).

4. As your api evolves, you'll make an additional versioned package with every major change.

5. Versioned packages have conversion functions which convert to and from the internal version.

6. You'll continue to support older versions according to your deprecation policy, and you can easily provide a program/library to update old versions into new versions because of 5.

7. All of your serializations and deserializations are handled in a centralized place.

Package runtime provides a conversion helper to make 5 easy, and the Encode/Decode/DecodeInto trio to accomplish 7. You can also register additional "codecs" which use a version of your choice. It's recommended that you register your types with runtime in your package's init function.

As a bonus, a few common types useful from all api objects and versions are provided in types.go.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func CheckCodec(c Codec, internalType Object, externalTypes ...schema.GroupVersionKind) error](<#func-checkcodec>)
- [func Convert_Slice_string_To_Pointer_bool(in *[]string, out **bool, s conversion.Scope) error](<#func-convert_slice_string_to_pointer_bool>)
- [func Convert_Slice_string_To_Pointer_int64(in *[]string, out **int64, s conversion.Scope) error](<#func-convert_slice_string_to_pointer_int64>)
- [func Convert_Slice_string_To_bool(in *[]string, out *bool, s conversion.Scope) error](<#func-convert_slice_string_to_bool>)
- [func Convert_Slice_string_To_int(in *[]string, out *int, s conversion.Scope) error](<#func-convert_slice_string_to_int>)
- [func Convert_Slice_string_To_int64(in *[]string, out *int64, s conversion.Scope) error](<#func-convert_slice_string_to_int64>)
- [func Convert_Slice_string_To_string(in *[]string, out *string, s conversion.Scope) error](<#func-convert_slice_string_to_string>)
- [func Convert_runtime_Object_To_runtime_RawExtension(in *Object, out *RawExtension, s conversion.Scope) error](<#func-convert_runtime_object_to_runtime_rawextension>)
- [func Convert_runtime_RawExtension_To_runtime_Object(in *RawExtension, out *Object, s conversion.Scope) error](<#func-convert_runtime_rawextension_to_runtime_object>)
- [func Convert_string_To_Pointer_int64(in *string, out **int64, s conversion.Scope) error](<#func-convert_string_to_pointer_int64>)
- [func Convert_string_To_int64(in *string, out *int64, s conversion.Scope) error](<#func-convert_string_to_int64>)
- [func DecodeInto(d Decoder, data []byte, into Object) error](<#func-decodeinto>)
- [func DecodeList(objects []Object, decoders ...Decoder) []error](<#func-decodelist>)
- [func DeepCopyJSON(x map[string]interface{}) map[string]interface{}](<#func-deepcopyjson>)
- [func DeepCopyJSONValue(x interface{}) interface{}](<#func-deepcopyjsonvalue>)
- [func DefaultMetaV1FieldSelectorConversion(label, value string) (string, string, error)](<#func-defaultmetav1fieldselectorconversion>)
- [func Encode(e Encoder, obj Object) ([]byte, error)](<#func-encode>)
- [func EncodeList(e Encoder, objects []Object) error](<#func-encodelist>)
- [func EncodeOrDie(e Encoder, obj Object) string](<#func-encodeordie>)
- [func Field(v reflect.Value, fieldName string, dest interface{}) error](<#func-field>)
- [func FieldPtr(v reflect.Value, fieldName string, dest interface{}) error](<#func-fieldptr>)
- [func IsMissingKind(err error) bool](<#func-ismissingkind>)
- [func IsMissingVersion(err error) bool](<#func-ismissingversion>)
- [func IsNotRegisteredError(err error) bool](<#func-isnotregisterederror>)
- [func IsStrictDecodingError(err error) bool](<#func-isstrictdecodingerror>)
- [func JSONKeyMapper(key string, sourceTag, destTag reflect.StructTag) (string, string)](<#func-jsonkeymapper>)
- [func NewMissingKindErr(data string) error](<#func-newmissingkinderr>)
- [func NewMissingVersionErr(data string) error](<#func-newmissingversionerr>)
- [func NewNotRegisteredErrForKind(schemeName string, gvk schema.GroupVersionKind) error](<#func-newnotregisterederrforkind>)
- [func NewNotRegisteredErrForTarget(schemeName string, t reflect.Type, target GroupVersioner) error](<#func-newnotregisterederrfortarget>)
- [func NewNotRegisteredErrForType(schemeName string, t reflect.Type) error](<#func-newnotregisterederrfortype>)
- [func NewNotRegisteredGVKErrForTarget(schemeName string, gvk schema.GroupVersionKind, target GroupVersioner) error](<#func-newnotregisteredgvkerrfortarget>)
- [func NewStrictDecodingError(message string, data string) error](<#func-newstrictdecodingerror>)
- [func RegisterEmbeddedConversions(s *Scheme) error](<#func-registerembeddedconversions>)
- [func RegisterStringConversions(s *Scheme) error](<#func-registerstringconversions>)
- [func SetField(src interface{}, v reflect.Value, fieldName string) error](<#func-setfield>)
- [func SetZeroValue(objPtr Object) error](<#func-setzerovalue>)
- [func VerifySwaggerDocsExist(kubeTypes []KubeTypes, w io.Writer) (int, error)](<#func-verifyswaggerdocsexist>)
- [func WriteSwaggerDocFunc(kubeTypes []KubeTypes, w io.Writer) error](<#func-writeswaggerdocfunc>)
- [type CacheableObject](<#type-cacheableobject>)
- [type ClientNegotiator](<#type-clientnegotiator>)
  - [func NewClientNegotiator(serializer NegotiatedSerializer, gv schema.GroupVersion) ClientNegotiator](<#func-newclientnegotiator>)
- [type Codec](<#type-codec>)
  - [func NewCodec(e Encoder, d Decoder) Codec](<#func-newcodec>)
- [type Decoder](<#type-decoder>)
- [type Encoder](<#type-encoder>)
- [type EquivalentResourceMapper](<#type-equivalentresourcemapper>)
- [type EquivalentResourceRegistry](<#type-equivalentresourceregistry>)
  - [func NewEquivalentResourceRegistry() EquivalentResourceRegistry](<#func-newequivalentresourceregistry>)
  - [func NewEquivalentResourceRegistryWithIdentity(keyFunc func(schema.GroupResource) string) EquivalentResourceRegistry](<#func-newequivalentresourceregistrywithidentity>)
- [type FieldLabelConversionFunc](<#type-fieldlabelconversionfunc>)
- [type Framer](<#type-framer>)
- [type GroupVersioner](<#type-groupversioner>)
  - [func NewCoercingMultiGroupVersioner(gv schema.GroupVersion, groupKinds ...schema.GroupKind) GroupVersioner](<#func-newcoercingmultigroupversioner>)
  - [func NewMultiGroupVersioner(gv schema.GroupVersion, groupKinds ...schema.GroupKind) GroupVersioner](<#func-newmultigroupversioner>)
- [type Identifier](<#type-identifier>)
- [type KubeTypes](<#type-kubetypes>)
  - [func ParseDocumentationFrom(src string) []KubeTypes](<#func-parsedocumentationfrom>)
- [type MultiObjectTyper](<#type-multiobjecttyper>)
  - [func (m MultiObjectTyper) ObjectKinds(obj Object) (gvks []schema.GroupVersionKind, unversionedType bool, err error)](<#func-multiobjecttyper-objectkinds>)
  - [func (m MultiObjectTyper) Recognizes(gvk schema.GroupVersionKind) bool](<#func-multiobjecttyper-recognizes>)
- [type NegotiateError](<#type-negotiateerror>)
  - [func (e NegotiateError) Error() string](<#func-negotiateerror-error>)
- [type NegotiatedSerializer](<#type-negotiatedserializer>)
  - [func NewSimpleNegotiatedSerializer(info SerializerInfo) NegotiatedSerializer](<#func-newsimplenegotiatedserializer>)
- [type NestedObjectDecoder](<#type-nestedobjectdecoder>)
- [type NestedObjectEncoder](<#type-nestedobjectencoder>)
- [type NoopDecoder](<#type-noopdecoder>)
  - [func (n NoopDecoder) Decode(data []byte, gvk *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)](<#func-noopdecoder-decode>)
- [type NoopEncoder](<#type-noopencoder>)
  - [func (n NoopEncoder) Encode(obj Object, w io.Writer) error](<#func-noopencoder-encode>)
  - [func (n NoopEncoder) Identifier() Identifier](<#func-noopencoder-identifier>)
- [type Object](<#type-object>)
  - [func Decode(d Decoder, data []byte) (Object, error)](<#func-decode>)
  - [func NewEncodable(e Encoder, obj Object, versions ...schema.GroupVersion) Object](<#func-newencodable>)
  - [func NewEncodableList(e Encoder, objects []Object, versions ...schema.GroupVersion) []Object](<#func-newencodablelist>)
  - [func UseOrCreateObject(t ObjectTyper, c ObjectCreater, gvk schema.GroupVersionKind, obj Object) (Object, error)](<#func-useorcreateobject>)
- [type ObjectConvertor](<#type-objectconvertor>)
  - [func UnsafeObjectConvertor(scheme *Scheme) ObjectConvertor](<#func-unsafeobjectconvertor>)
- [type ObjectCreater](<#type-objectcreater>)
- [type ObjectDefaulter](<#type-objectdefaulter>)
- [type ObjectTyper](<#type-objecttyper>)
- [type ObjectVersioner](<#type-objectversioner>)
- [type Pair](<#type-pair>)
- [type ParameterCodec](<#type-parametercodec>)
  - [func NewParameterCodec(scheme *Scheme) ParameterCodec](<#func-newparametercodec>)
- [type ProtobufMarshaller](<#type-protobufmarshaller>)
- [type ProtobufReverseMarshaller](<#type-protobufreversemarshaller>)
- [type RawExtension](<#type-rawextension>)
  - [func (in *RawExtension) DeepCopy() *RawExtension](<#func-rawextension-deepcopy>)
  - [func (in *RawExtension) DeepCopyInto(out *RawExtension)](<#func-rawextension-deepcopyinto>)
  - [func (*RawExtension) Descriptor() ([]byte, []int)](<#func-rawextension-descriptor>)
  - [func (m *RawExtension) Marshal() (dAtA []byte, err error)](<#func-rawextension-marshal>)
  - [func (re RawExtension) MarshalJSON() ([]byte, error)](<#func-rawextension-marshaljson>)
  - [func (m *RawExtension) MarshalTo(dAtA []byte) (int, error)](<#func-rawextension-marshalto>)
  - [func (m *RawExtension) MarshalToSizedBuffer(dAtA []byte) (int, error)](<#func-rawextension-marshaltosizedbuffer>)
  - [func (*RawExtension) ProtoMessage()](<#func-rawextension-protomessage>)
  - [func (m *RawExtension) Reset()](<#func-rawextension-reset>)
  - [func (m *RawExtension) Size() (n int)](<#func-rawextension-size>)
  - [func (this *RawExtension) String() string](<#func-rawextension-string>)
  - [func (m *RawExtension) Unmarshal(dAtA []byte) error](<#func-rawextension-unmarshal>)
  - [func (re *RawExtension) UnmarshalJSON(in []byte) error](<#func-rawextension-unmarshaljson>)
  - [func (m *RawExtension) XXX_DiscardUnknown()](<#func-rawextension-xxx_discardunknown>)
  - [func (m *RawExtension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error)](<#func-rawextension-xxx_marshal>)
  - [func (m *RawExtension) XXX_Merge(src proto.Message)](<#func-rawextension-xxx_merge>)
  - [func (m *RawExtension) XXX_Size() int](<#func-rawextension-xxx_size>)
  - [func (m *RawExtension) XXX_Unmarshal(b []byte) error](<#func-rawextension-xxx_unmarshal>)
- [type ResourceVersioner](<#type-resourceversioner>)
- [type Scheme](<#type-scheme>)
  - [func NewScheme() *Scheme](<#func-newscheme>)
  - [func (s *Scheme) AddConversionFunc(a, b interface{}, fn conversion.ConversionFunc) error](<#func-scheme-addconversionfunc>)
  - [func (s *Scheme) AddFieldLabelConversionFunc(gvk schema.GroupVersionKind, conversionFunc FieldLabelConversionFunc) error](<#func-scheme-addfieldlabelconversionfunc>)
  - [func (s *Scheme) AddGeneratedConversionFunc(a, b interface{}, fn conversion.ConversionFunc) error](<#func-scheme-addgeneratedconversionfunc>)
  - [func (s *Scheme) AddIgnoredConversionType(from, to interface{}) error](<#func-scheme-addignoredconversiontype>)
  - [func (s *Scheme) AddKnownTypeWithName(gvk schema.GroupVersionKind, obj Object)](<#func-scheme-addknowntypewithname>)
  - [func (s *Scheme) AddKnownTypes(gv schema.GroupVersion, types ...Object)](<#func-scheme-addknowntypes>)
  - [func (s *Scheme) AddTypeDefaultingFunc(srcType Object, fn func(interface{}))](<#func-scheme-addtypedefaultingfunc>)
  - [func (s *Scheme) AddUnversionedTypes(version schema.GroupVersion, types ...Object)](<#func-scheme-addunversionedtypes>)
  - [func (s *Scheme) AllKnownTypes() map[schema.GroupVersionKind]reflect.Type](<#func-scheme-allknowntypes>)
  - [func (s *Scheme) Convert(in, out interface{}, context interface{}) error](<#func-scheme-convert>)
  - [func (s *Scheme) ConvertFieldLabel(gvk schema.GroupVersionKind, label, value string) (string, string, error)](<#func-scheme-convertfieldlabel>)
  - [func (s *Scheme) ConvertToVersion(in Object, target GroupVersioner) (Object, error)](<#func-scheme-converttoversion>)
  - [func (s *Scheme) Converter() *conversion.Converter](<#func-scheme-converter>)
  - [func (s *Scheme) Default(src Object)](<#func-scheme-default>)
  - [func (s *Scheme) IsGroupRegistered(group string) bool](<#func-scheme-isgroupregistered>)
  - [func (s *Scheme) IsUnversioned(obj Object) (bool, bool)](<#func-scheme-isunversioned>)
  - [func (s *Scheme) IsVersionRegistered(version schema.GroupVersion) bool](<#func-scheme-isversionregistered>)
  - [func (s *Scheme) KnownTypes(gv schema.GroupVersion) map[string]reflect.Type](<#func-scheme-knowntypes>)
  - [func (s *Scheme) Name() string](<#func-scheme-name>)
  - [func (s *Scheme) New(kind schema.GroupVersionKind) (Object, error)](<#func-scheme-new>)
  - [func (s *Scheme) ObjectKinds(obj Object) ([]schema.GroupVersionKind, bool, error)](<#func-scheme-objectkinds>)
  - [func (s *Scheme) PreferredVersionAllGroups() []schema.GroupVersion](<#func-scheme-preferredversionallgroups>)
  - [func (s *Scheme) PrioritizedVersionsAllGroups() []schema.GroupVersion](<#func-scheme-prioritizedversionsallgroups>)
  - [func (s *Scheme) PrioritizedVersionsForGroup(group string) []schema.GroupVersion](<#func-scheme-prioritizedversionsforgroup>)
  - [func (s *Scheme) Recognizes(gvk schema.GroupVersionKind) bool](<#func-scheme-recognizes>)
  - [func (s *Scheme) SetVersionPriority(versions ...schema.GroupVersion) error](<#func-scheme-setversionpriority>)
  - [func (s *Scheme) UnsafeConvertToVersion(in Object, target GroupVersioner) (Object, error)](<#func-scheme-unsafeconverttoversion>)
  - [func (s *Scheme) VersionsForGroupKind(gk schema.GroupKind) []schema.GroupVersion](<#func-scheme-versionsforgroupkind>)
- [type SchemeBuilder](<#type-schemebuilder>)
  - [func NewSchemeBuilder(funcs ...func(*Scheme) error) SchemeBuilder](<#func-newschemebuilder>)
  - [func (sb *SchemeBuilder) AddToScheme(s *Scheme) error](<#func-schemebuilder-addtoscheme>)
  - [func (sb *SchemeBuilder) Register(funcs ...func(*Scheme) error)](<#func-schemebuilder-register>)
- [type SelfLinker](<#type-selflinker>)
- [type Serializer](<#type-serializer>)
  - [func NewBase64Serializer(e Encoder, d Decoder) Serializer](<#func-newbase64serializer>)
- [type SerializerInfo](<#type-serializerinfo>)
  - [func SerializerInfoForMediaType(types []SerializerInfo, mediaType string) (SerializerInfo, bool)](<#func-serializerinfoformediatype>)
- [type StorageSerializer](<#type-storageserializer>)
- [type StreamSerializerInfo](<#type-streamserializerinfo>)
- [type TypeMeta](<#type-typemeta>)
  - [func (*TypeMeta) Descriptor() ([]byte, []int)](<#func-typemeta-descriptor>)
  - [func (obj *TypeMeta) GetObjectKind() schema.ObjectKind](<#func-typemeta-getobjectkind>)
  - [func (obj *TypeMeta) GroupVersionKind() schema.GroupVersionKind](<#func-typemeta-groupversionkind>)
  - [func (m *TypeMeta) Marshal() (dAtA []byte, err error)](<#func-typemeta-marshal>)
  - [func (m *TypeMeta) MarshalTo(dAtA []byte) (int, error)](<#func-typemeta-marshalto>)
  - [func (m *TypeMeta) MarshalToSizedBuffer(dAtA []byte) (int, error)](<#func-typemeta-marshaltosizedbuffer>)
  - [func (*TypeMeta) ProtoMessage()](<#func-typemeta-protomessage>)
  - [func (m *TypeMeta) Reset()](<#func-typemeta-reset>)
  - [func (obj *TypeMeta) SetGroupVersionKind(gvk schema.GroupVersionKind)](<#func-typemeta-setgroupversionkind>)
  - [func (m *TypeMeta) Size() (n int)](<#func-typemeta-size>)
  - [func (this *TypeMeta) String() string](<#func-typemeta-string>)
  - [func (m *TypeMeta) Unmarshal(dAtA []byte) error](<#func-typemeta-unmarshal>)
  - [func (m *TypeMeta) XXX_DiscardUnknown()](<#func-typemeta-xxx_discardunknown>)
  - [func (m *TypeMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error)](<#func-typemeta-xxx_marshal>)
  - [func (m *TypeMeta) XXX_Merge(src proto.Message)](<#func-typemeta-xxx_merge>)
  - [func (m *TypeMeta) XXX_Size() int](<#func-typemeta-xxx_size>)
  - [func (m *TypeMeta) XXX_Unmarshal(b []byte) error](<#func-typemeta-xxx_unmarshal>)
- [type Unknown](<#type-unknown>)
  - [func (in *Unknown) DeepCopy() *Unknown](<#func-unknown-deepcopy>)
  - [func (in *Unknown) DeepCopyInto(out *Unknown)](<#func-unknown-deepcopyinto>)
  - [func (in *Unknown) DeepCopyObject() Object](<#func-unknown-deepcopyobject>)
  - [func (*Unknown) Descriptor() ([]byte, []int)](<#func-unknown-descriptor>)
  - [func (m *Unknown) Marshal() (dAtA []byte, err error)](<#func-unknown-marshal>)
  - [func (e Unknown) MarshalJSON() ([]byte, error)](<#func-unknown-marshaljson>)
  - [func (m *Unknown) MarshalTo(dAtA []byte) (int, error)](<#func-unknown-marshalto>)
  - [func (m *Unknown) MarshalToSizedBuffer(dAtA []byte) (int, error)](<#func-unknown-marshaltosizedbuffer>)
  - [func (m *Unknown) NestedMarshalTo(data []byte, b ProtobufMarshaller, size uint64) (int, error)](<#func-unknown-nestedmarshalto>)
  - [func (*Unknown) ProtoMessage()](<#func-unknown-protomessage>)
  - [func (m *Unknown) Reset()](<#func-unknown-reset>)
  - [func (m *Unknown) Size() (n int)](<#func-unknown-size>)
  - [func (this *Unknown) String() string](<#func-unknown-string>)
  - [func (m *Unknown) Unmarshal(dAtA []byte) error](<#func-unknown-unmarshal>)
  - [func (e *Unknown) UnmarshalJSON(in []byte) error](<#func-unknown-unmarshaljson>)
  - [func (m *Unknown) XXX_DiscardUnknown()](<#func-unknown-xxx_discardunknown>)
  - [func (m *Unknown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error)](<#func-unknown-xxx_marshal>)
  - [func (m *Unknown) XXX_Merge(src proto.Message)](<#func-unknown-xxx_merge>)
  - [func (m *Unknown) XXX_Size() int](<#func-unknown-xxx_size>)
  - [func (m *Unknown) XXX_Unmarshal(b []byte) error](<#func-unknown-xxx_unmarshal>)
- [type Unstructured](<#type-unstructured>)
- [type UnstructuredConverter](<#type-unstructuredconverter>)
  - [func NewTestUnstructuredConverter(comparison conversion.Equalities) UnstructuredConverter](<#func-newtestunstructuredconverter>)
- [type WithVersionEncoder](<#type-withversionencoder>)
  - [func (e WithVersionEncoder) Encode(obj Object, stream io.Writer) error](<#func-withversionencoder-encode>)
- [type WithoutVersionDecoder](<#type-withoutversiondecoder>)
  - [func (d WithoutVersionDecoder) Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)](<#func-withoutversiondecoder-decode>)


## Constants

```go
const (
    ContentTypeJSON     string = "application/json"
    ContentTypeYAML     string = "application/yaml"
    ContentTypeProtobuf string = "application/vnd.kubernetes.protobuf"
)
```

```go
const (
    // APIVersionInternal may be used if you are registering a type that should not
    // be considered stable or serialized - it is a convention only and has no
    // special behavior in this package.
    APIVersionInternal = "__internal"
)
```

## Variables

```go
var (
    ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
    ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
    ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
```

DefaultFramer is valid for any stream that can read objects serially without any separation in the stream.

```go
var DefaultFramer = defaultFramer{}
```

```go
var (

    // DefaultUnstructuredConverter performs unstructured to Go typed object conversions.
    DefaultUnstructuredConverter = &unstructuredConverter{
        mismatchDetection: parseBool(os.Getenv("KUBE_PATCH_CONVERSION_DETECTOR")),
        comparison: conversion.EqualitiesOrDie(
            func(a, b time.Time) bool {
                return a.UTC() == b.UTC()
            },
        ),
    }
)
```

## func CheckCodec

```go
func CheckCodec(c Codec, internalType Object, externalTypes ...schema.GroupVersionKind) error
```

CheckCodec makes sure that the codec can encode objects like internalType, decode all of the external types listed, and also decode them into the given object. \(Will modify internalObject.\) \(Assumes JSON serialization.\) TODO: verify that the correct external version is chosen on encode...

## func Convert\_Slice\_string\_To\_Pointer\_bool

```go
func Convert_Slice_string_To_Pointer_bool(in *[]string, out **bool, s conversion.Scope) error
```

Convert\_Slice\_string\_To\_bool will convert a string parameter to boolean. Only the absence of a value \(i.e. zero\-length slice\), a value of "false", or a value of "0" resolve to false. Any other value \(including empty string\) resolves to true.

## func Convert\_Slice\_string\_To\_Pointer\_int64

```go
func Convert_Slice_string_To_Pointer_int64(in *[]string, out **int64, s conversion.Scope) error
```

## func Convert\_Slice\_string\_To\_bool

```go
func Convert_Slice_string_To_bool(in *[]string, out *bool, s conversion.Scope) error
```

Convert\_Slice\_string\_To\_bool will convert a string parameter to boolean. Only the absence of a value \(i.e. zero\-length slice\), a value of "false", or a value of "0" resolve to false. Any other value \(including empty string\) resolves to true.

## func Convert\_Slice\_string\_To\_int

```go
func Convert_Slice_string_To_int(in *[]string, out *int, s conversion.Scope) error
```

## func Convert\_Slice\_string\_To\_int64

```go
func Convert_Slice_string_To_int64(in *[]string, out *int64, s conversion.Scope) error
```

## func Convert\_Slice\_string\_To\_string

```go
func Convert_Slice_string_To_string(in *[]string, out *string, s conversion.Scope) error
```

## func Convert\_runtime\_Object\_To\_runtime\_RawExtension

```go
func Convert_runtime_Object_To_runtime_RawExtension(in *Object, out *RawExtension, s conversion.Scope) error
```

## func Convert\_runtime\_RawExtension\_To\_runtime\_Object

```go
func Convert_runtime_RawExtension_To_runtime_Object(in *RawExtension, out *Object, s conversion.Scope) error
```

## func Convert\_string\_To\_Pointer\_int64

```go
func Convert_string_To_Pointer_int64(in *string, out **int64, s conversion.Scope) error
```

## func Convert\_string\_To\_int64

```go
func Convert_string_To_int64(in *string, out *int64, s conversion.Scope) error
```

## func DecodeInto

```go
func DecodeInto(d Decoder, data []byte, into Object) error
```

DecodeInto performs a Decode into the provided object.

## func DecodeList

```go
func DecodeList(objects []Object, decoders ...Decoder) []error
```

DecodeList alters the list in place, attempting to decode any objects found in the list that have the Unknown type. Any errors that occur are returned after the entire list is processed. Decoders are tried in order.

## func DeepCopyJSON

```go
func DeepCopyJSON(x map[string]interface{}) map[string]interface{}
```

DeepCopyJSON deep copies the passed value, assuming it is a valid JSON representation i.e. only contains types produced by json.Unmarshal\(\) and also int64. bool, int64, float64, string, \[\]interface\{\}, map\[string\]interface\{\}, json.Number and nil

## func DeepCopyJSONValue

```go
func DeepCopyJSONValue(x interface{}) interface{}
```

DeepCopyJSONValue deep copies the passed value, assuming it is a valid JSON representation i.e. only contains types produced by json.Unmarshal\(\) and also int64. bool, int64, float64, string, \[\]interface\{\}, map\[string\]interface\{\}, json.Number and nil

## func DefaultMetaV1FieldSelectorConversion

```go
func DefaultMetaV1FieldSelectorConversion(label, value string) (string, string, error)
```

DefaultMetaV1FieldSelectorConversion auto\-accepts metav1 values for name and namespace. A cluster scoped resource specifying namespace empty works fine and specifying a particular namespace will return no results, as expected.

## func Encode

```go
func Encode(e Encoder, obj Object) ([]byte, error)
```

Encode is a convenience wrapper for encoding to a \[\]byte from an Encoder

## func EncodeList

```go
func EncodeList(e Encoder, objects []Object) error
```

EncodeList ensures that each object in an array is converted to a Unknown\{\} in serialized form. TODO: accept a content type.

## func EncodeOrDie

```go
func EncodeOrDie(e Encoder, obj Object) string
```

EncodeOrDie is a version of Encode which will panic instead of returning an error. For tests.

## func Field

```go
func Field(v reflect.Value, fieldName string, dest interface{}) error
```

Field puts the value of fieldName, which must be a member of v, into dest, which must be a variable to which this field's value can be assigned.

## func FieldPtr

```go
func FieldPtr(v reflect.Value, fieldName string, dest interface{}) error
```

FieldPtr puts the address of fieldName, which must be a member of v, into dest, which must be an address of a variable to which this field's address can be assigned.

## func IsMissingKind

```go
func IsMissingKind(err error) bool
```

IsMissingKind returns true if the error indicates that the provided object is missing a 'Kind' field.

## func IsMissingVersion

```go
func IsMissingVersion(err error) bool
```

IsMissingVersion returns true if the error indicates that the provided object is missing a 'Version' field.

## func IsNotRegisteredError

```go
func IsNotRegisteredError(err error) bool
```

IsNotRegisteredError returns true if the error indicates the provided object or input data is not registered.

## func IsStrictDecodingError

```go
func IsStrictDecodingError(err error) bool
```

IsStrictDecodingError returns true if the error indicates that the provided object strictness violations.

## func JSONKeyMapper

```go
func JSONKeyMapper(key string, sourceTag, destTag reflect.StructTag) (string, string)
```

JSONKeyMapper uses the struct tags on a conversion to determine the key value for the other side. Use when mapping from a map\[string\]\* to a struct or vice versa.

## func NewMissingKindErr

```go
func NewMissingKindErr(data string) error
```

## func NewMissingVersionErr

```go
func NewMissingVersionErr(data string) error
```

## func NewNotRegisteredErrForKind

```go
func NewNotRegisteredErrForKind(schemeName string, gvk schema.GroupVersionKind) error
```

## func NewNotRegisteredErrForTarget

```go
func NewNotRegisteredErrForTarget(schemeName string, t reflect.Type, target GroupVersioner) error
```

## func NewNotRegisteredErrForType

```go
func NewNotRegisteredErrForType(schemeName string, t reflect.Type) error
```

## func NewNotRegisteredGVKErrForTarget

```go
func NewNotRegisteredGVKErrForTarget(schemeName string, gvk schema.GroupVersionKind, target GroupVersioner) error
```

## func NewStrictDecodingError

```go
func NewStrictDecodingError(message string, data string) error
```

NewStrictDecodingError creates a new strictDecodingError object.

## func RegisterEmbeddedConversions

```go
func RegisterEmbeddedConversions(s *Scheme) error
```

## func RegisterStringConversions

```go
func RegisterStringConversions(s *Scheme) error
```

## func SetField

```go
func SetField(src interface{}, v reflect.Value, fieldName string) error
```

SetField puts the value of src, into fieldName, which must be a member of v. The value of src must be assignable to the field.

## func SetZeroValue

```go
func SetZeroValue(objPtr Object) error
```

SetZeroValue would set the object of objPtr to zero value of its type.

## func VerifySwaggerDocsExist

```go
func VerifySwaggerDocsExist(kubeTypes []KubeTypes, w io.Writer) (int, error)
```

VerifySwaggerDocsExist writes in a io.Writer a list of structs and fields that are missing of documentation.

## func WriteSwaggerDocFunc

```go
func WriteSwaggerDocFunc(kubeTypes []KubeTypes, w io.Writer) error
```

WriteSwaggerDocFunc writes a declaration of a function as a string. This function is used in Swagger as a documentation source for structs and theirs fields

## type CacheableObject

CacheableObject allows an object to cache its different serializations to avoid performing the same serialization multiple times.

```go
type CacheableObject interface {
    // CacheEncode writes an object to a stream. The <encode> function will
    // be used in case of cache miss. The <encode> function takes ownership
    // of the object.
    // If CacheableObject is a wrapper, then deep-copy of the wrapped object
    // should be passed to <encode> function.
    // CacheEncode assumes that for two different calls with the same <id>,
    // <encode> function will also be the same.
    CacheEncode(id Identifier, encode func(Object, io.Writer) error, w io.Writer) error
    // GetObject returns a deep-copy of an object to be encoded - the caller of
    // GetObject() is the owner of returned object. The reason for making a copy
    // is to avoid bugs, where caller modifies the object and forgets to copy it,
    // thus modifying the object for everyone.
    // The object returned by GetObject should be the same as the one that is supposed
    // to be passed to <encode> function in CacheEncode method.
    // If CacheableObject is a wrapper, the copy of wrapped object should be returned.
    GetObject() Object
}
```

## type ClientNegotiator

ClientNegotiator handles turning an HTTP content type into the appropriate encoder. Use NewClientNegotiator or NewVersionedClientNegotiator to create this interface from a NegotiatedSerializer.

```go
type ClientNegotiator interface {
    // Encoder returns the appropriate encoder for the provided contentType (e.g. application/json)
    // and any optional mediaType parameters (e.g. pretty=1), or an error. If no serializer is found
    // a NegotiateError will be returned. The current client implementations consider params to be
    // optional modifiers to the contentType and will ignore unrecognized parameters.
    Encoder(contentType string, params map[string]string) (Encoder, error)
    // Decoder returns the appropriate decoder for the provided contentType (e.g. application/json)
    // and any optional mediaType parameters (e.g. pretty=1), or an error. If no serializer is found
    // a NegotiateError will be returned. The current client implementations consider params to be
    // optional modifiers to the contentType and will ignore unrecognized parameters.
    Decoder(contentType string, params map[string]string) (Decoder, error)
    // StreamDecoder returns the appropriate stream decoder for the provided contentType (e.g.
    // application/json) and any optional mediaType parameters (e.g. pretty=1), or an error. If no
    // serializer is found a NegotiateError will be returned. The Serializer and Framer will always
    // be returned if a Decoder is returned. The current client implementations consider params to be
    // optional modifiers to the contentType and will ignore unrecognized parameters.
    StreamDecoder(contentType string, params map[string]string) (Decoder, Serializer, Framer, error)
}
```

### func NewClientNegotiator

```go
func NewClientNegotiator(serializer NegotiatedSerializer, gv schema.GroupVersion) ClientNegotiator
```

NewClientNegotiator will attempt to retrieve the appropriate encoder, decoder, or stream decoder for a given content type. Does not perform any conversion, but will encode the object to the desired group, version, and kind. Use when creating a client.

## type Codec

Codec is a Serializer that deals with the details of versioning objects. It offers the same interface as Serializer, so this is a marker to consumers that care about the version of the objects they receive.

```go
type Codec Serializer
```

### func NewCodec

```go
func NewCodec(e Encoder, d Decoder) Codec
```

NewCodec creates a Codec from an Encoder and Decoder.

## type Decoder

Decoder attempts to load an object from data.

```go
type Decoder interface {
    // Decode attempts to deserialize the provided data using either the innate typing of the scheme or the
    // default kind, group, and version provided. It returns a decoded object as well as the kind, group, and
    // version from the serialized data, or an error. If into is non-nil, it will be used as the target type
    // and implementations may choose to use it rather than reallocating an object. However, the object is not
    // guaranteed to be populated. The returned object is not guaranteed to match into. If defaults are
    // provided, they are applied to the data by default. If no defaults or partial defaults are provided, the
    // type of the into may be used to guide conversion decisions.
    Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)
}
```

## type Encoder

Encoder writes objects to a serialized form

```go
type Encoder interface {
    // Encode writes an object to a stream. Implementations may return errors if the versions are
    // incompatible, or if no conversion is defined.
    Encode(obj Object, w io.Writer) error
    // Identifier returns an identifier of the encoder.
    // Identifiers of two different encoders should be equal if and only if for every input
    // object it will be encoded to the same representation by both of them.
    //
    // Identifier is intended for use with CacheableObject#CacheEncode method. In order to
    // correctly handle CacheableObject, Encode() method should look similar to below, where
    // doEncode() is the encoding logic of implemented encoder:
    //   func (e *MyEncoder) Encode(obj Object, w io.Writer) error {
    //     if co, ok := obj.(CacheableObject); ok {
    //       return co.CacheEncode(e.Identifier(), e.doEncode, w)
    //     }
    //     return e.doEncode(obj, w)
    //   }
    Identifier() Identifier
}
```

## type EquivalentResourceMapper

EquivalentResourceMapper provides information about resources that address the same underlying data as a specified resource

```go
type EquivalentResourceMapper interface {
    // EquivalentResourcesFor returns a list of resources that address the same underlying data as resource.
    // If subresource is specified, only equivalent resources which also have the same subresource are included.
    // The specified resource can be included in the returned list.
    EquivalentResourcesFor(resource schema.GroupVersionResource, subresource string) []schema.GroupVersionResource
    // KindFor returns the kind expected by the specified resource[/subresource].
    // A zero value is returned if the kind is unknown.
    KindFor(resource schema.GroupVersionResource, subresource string) schema.GroupVersionKind
}
```

## type EquivalentResourceRegistry

EquivalentResourceRegistry provides an EquivalentResourceMapper interface, and allows registering known resource\[/subresource\] \-\> kind

```go
type EquivalentResourceRegistry interface {
    EquivalentResourceMapper
    // RegisterKindFor registers the existence of the specified resource[/subresource] along with its expected kind.
    RegisterKindFor(resource schema.GroupVersionResource, subresource string, kind schema.GroupVersionKind)
}
```

### func NewEquivalentResourceRegistry

```go
func NewEquivalentResourceRegistry() EquivalentResourceRegistry
```

NewEquivalentResourceRegistry creates a resource registry that considers all versions of a GroupResource to be equivalent.

### func NewEquivalentResourceRegistryWithIdentity

```go
func NewEquivalentResourceRegistryWithIdentity(keyFunc func(schema.GroupResource) string) EquivalentResourceRegistry
```

NewEquivalentResourceRegistryWithIdentity creates a resource mapper with a custom identity function. If "" is returned by the function, GroupResource\#String is used as the identity. GroupResources with the same identity string are considered equivalent.

## type FieldLabelConversionFunc

FieldLabelConversionFunc converts a field selector to internal representation.

```go
type FieldLabelConversionFunc func(label, value string) (internalLabel, internalValue string, err error)
```

## type Framer

Framer is a factory for creating readers and writers that obey a particular framing pattern.

```go
type Framer interface {
    NewFrameReader(r io.ReadCloser) io.ReadCloser
    NewFrameWriter(w io.Writer) io.Writer
}
```

## type GroupVersioner

GroupVersioner refines a set of possible conversion targets into a single option.

```go
type GroupVersioner interface {
    // KindForGroupVersionKinds returns a desired target group version kind for the given input, or returns ok false if no
    // target is known. In general, if the return target is not in the input list, the caller is expected to invoke
    // Scheme.New(target) and then perform a conversion between the current Go type and the destination Go type.
    // Sophisticated implementations may use additional information about the input kinds to pick a destination kind.
    KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (target schema.GroupVersionKind, ok bool)
    // Identifier returns string representation of the object.
    // Identifiers of two different encoders should be equal only if for every input
    // kinds they return the same result.
    Identifier() string
}
```

```go
var (
    // InternalGroupVersioner will always prefer the internal version for a given group version kind.
    InternalGroupVersioner GroupVersioner = internalGroupVersioner{}
    // DisabledGroupVersioner will reject all kinds passed to it.
    DisabledGroupVersioner GroupVersioner = disabledGroupVersioner{}
)
```

### func NewCoercingMultiGroupVersioner

```go
func NewCoercingMultiGroupVersioner(gv schema.GroupVersion, groupKinds ...schema.GroupKind) GroupVersioner
```

NewCoercingMultiGroupVersioner returns the provided group version for any incoming kind. Incoming kinds that match the provided groupKinds are preferred. Kind may be empty in the provided group kind, in which case any kind will match. Examples: gv=mygroup/\_\_internal, groupKinds=mygroup/Foo, anothergroup/Bar KindForGroupVersionKinds\(yetanother/v1/Baz, anothergroup/v1/Bar\) \-\> mygroup/\_\_internal/Bar \(matched preferred group/kind\)

```
gv=mygroup/__internal, groupKinds=mygroup, anothergroup
KindForGroupVersionKinds(yetanother/v1/Baz, anothergroup/v1/Bar) -> mygroup/__internal/Bar (matched preferred group)

gv=mygroup/__internal, groupKinds=mygroup, anothergroup
KindForGroupVersionKinds(yetanother/v1/Baz, yetanother/v1/Bar) -> mygroup/__internal/Baz (no preferred group/kind match, uses first kind in list)
```

### func NewMultiGroupVersioner

```go
func NewMultiGroupVersioner(gv schema.GroupVersion, groupKinds ...schema.GroupKind) GroupVersioner
```

NewMultiGroupVersioner returns the provided group version for any kind that matches one of the provided group kinds. Kind may be empty in the provided group kind, in which case any kind will match.

## type Identifier

Identifier represents an identifier. Identitier of two different objects should be equal if and only if for every input the output they produce is exactly the same.

```go
type Identifier string
```

## type KubeTypes

KubeTypes is an array to represent all available types in a parsed file. \[0\] is for the type itself

```go
type KubeTypes []Pair
```

### func ParseDocumentationFrom

```go
func ParseDocumentationFrom(src string) []KubeTypes
```

ParseDocumentationFrom gets all types' documentation and returns them as an array. Each type is again represented as an array \(we have to use arrays as we need to be sure for the order of the fields\). This function returns fields and struct definitions that have no documentation as \{name, ""\}.

## type MultiObjectTyper

MultiObjectTyper returns the types of objects across multiple schemes in order.

```go
type MultiObjectTyper []ObjectTyper
```

### func \(MultiObjectTyper\) ObjectKinds

```go
func (m MultiObjectTyper) ObjectKinds(obj Object) (gvks []schema.GroupVersionKind, unversionedType bool, err error)
```

### func \(MultiObjectTyper\) Recognizes

```go
func (m MultiObjectTyper) Recognizes(gvk schema.GroupVersionKind) bool
```

## type NegotiateError

NegotiateError is returned when a ClientNegotiator is unable to locate a serializer for the requested operation.

```go
type NegotiateError struct {
    ContentType string
    Stream      bool
}
```

### func \(NegotiateError\) Error

```go
func (e NegotiateError) Error() string
```

## type NegotiatedSerializer

NegotiatedSerializer is an interface used for obtaining encoders, decoders, and serializers for multiple supported media types. This would commonly be accepted by a server component that performs HTTP content negotiation to accept multiple formats.

```go
type NegotiatedSerializer interface {
    // SupportedMediaTypes is the media types supported for reading and writing single objects.
    SupportedMediaTypes() []SerializerInfo

    // EncoderForVersion returns an encoder that ensures objects being written to the provided
    // serializer are in the provided group version.
    EncoderForVersion(serializer Encoder, gv GroupVersioner) Encoder
    // DecoderForVersion returns a decoder that ensures objects being read by the provided
    // serializer are in the provided group version by default.
    DecoderToVersion(serializer Decoder, gv GroupVersioner) Decoder
}
```

### func NewSimpleNegotiatedSerializer

```go
func NewSimpleNegotiatedSerializer(info SerializerInfo) NegotiatedSerializer
```

## type NestedObjectDecoder

NestedObjectDecoder is an optional interface that objects may implement to be given an opportunity to decode any nested Objects / RawExtensions during serialization.

```go
type NestedObjectDecoder interface {
    DecodeNestedObjects(d Decoder) error
}
```

## type NestedObjectEncoder

NestedObjectEncoder is an optional interface that objects may implement to be given an opportunity to encode any nested Objects / RawExtensions during serialization.

```go
type NestedObjectEncoder interface {
    EncodeNestedObjects(e Encoder) error
}
```

## type NoopDecoder

NoopDecoder converts an Encoder to a Serializer or Codec for code that expects them but only uses encoding.

```go
type NoopDecoder struct {
    Encoder
}
```

### func \(NoopDecoder\) Decode

```go
func (n NoopDecoder) Decode(data []byte, gvk *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)
```

## type NoopEncoder

NoopEncoder converts an Decoder to a Serializer or Codec for code that expects them but only uses decoding.

```go
type NoopEncoder struct {
    Decoder
}
```

### func \(NoopEncoder\) Encode

```go
func (n NoopEncoder) Encode(obj Object, w io.Writer) error
```

### func \(NoopEncoder\) Identifier

```go
func (n NoopEncoder) Identifier() Identifier
```

Identifier implements runtime.Encoder interface.

## type Object

Object interface must be supported by all API types registered with Scheme. Since objects in a scheme are expected to be serialized to the wire, the interface an Object must provide to the Scheme allows serializers to set the kind, version, and group the object is represented as. An Object may choose to return a no\-op ObjectKindAccessor in cases where it is not expected to be serialized.

```go
type Object interface {
    GetObjectKind() schema.ObjectKind
    DeepCopyObject() Object
}
```

### func Decode

```go
func Decode(d Decoder, data []byte) (Object, error)
```

Decode is a convenience wrapper for decoding data into an Object.

### func NewEncodable

```go
func NewEncodable(e Encoder, obj Object, versions ...schema.GroupVersion) Object
```

NewEncodable creates an object that will be encoded with the provided codec on demand. Provided as a convenience for test cases dealing with internal objects.

### func NewEncodableList

```go
func NewEncodableList(e Encoder, objects []Object, versions ...schema.GroupVersion) []Object
```

NewEncodableList creates an object that will be encoded with the provided codec on demand. Provided as a convenience for test cases dealing with internal objects.

### func UseOrCreateObject

```go
func UseOrCreateObject(t ObjectTyper, c ObjectCreater, gvk schema.GroupVersionKind, obj Object) (Object, error)
```

UseOrCreateObject returns obj if the canonical ObjectKind returned by the provided typer matches gvk, or invokes the ObjectCreator to instantiate a new gvk. Returns an error if the typer cannot find the object.

## type ObjectConvertor

ObjectConvertor converts an object to a different version.

```go
type ObjectConvertor interface {
    // Convert attempts to convert one object into another, or returns an error. This
    // method does not mutate the in object, but the in and out object might share data structures,
    // i.e. the out object cannot be mutated without mutating the in object as well.
    // The context argument will be passed to all nested conversions.
    Convert(in, out, context interface{}) error
    // ConvertToVersion takes the provided object and converts it the provided version. This
    // method does not mutate the in object, but the in and out object might share data structures,
    // i.e. the out object cannot be mutated without mutating the in object as well.
    // This method is similar to Convert() but handles specific details of choosing the correct
    // output version.
    ConvertToVersion(in Object, gv GroupVersioner) (out Object, err error)
    ConvertFieldLabel(gvk schema.GroupVersionKind, label, value string) (string, string, error)
}
```

### func UnsafeObjectConvertor

```go
func UnsafeObjectConvertor(scheme *Scheme) ObjectConvertor
```

UnsafeObjectConvertor performs object conversion without copying the object structure, for use when the converted object will not be reused or mutated. Primarily for use within versioned codecs, which use the external object for serialization but do not return it.

## type ObjectCreater

ObjectCreater contains methods for instantiating an object by kind and version.

```go
type ObjectCreater interface {
    New(kind schema.GroupVersionKind) (out Object, err error)
}
```

## type ObjectDefaulter

```go
type ObjectDefaulter interface {
    // Default takes an object (must be a pointer) and applies any default values.
    // Defaulters may not error.
    Default(in Object)
}
```

## type ObjectTyper

ObjectTyper contains methods for extracting the APIVersion and Kind of objects.

```go
type ObjectTyper interface {
    // ObjectKinds returns the all possible group,version,kind of the provided object, true if
    // the object is unversioned, or an error if the object is not recognized
    // (IsNotRegisteredError will return true).
    ObjectKinds(Object) ([]schema.GroupVersionKind, bool, error)
    // Recognizes returns true if the scheme is able to handle the provided version and kind,
    // or more precisely that the provided version is a possible conversion or decoding
    // target.
    Recognizes(gvk schema.GroupVersionKind) bool
}
```

## type ObjectVersioner

```go
type ObjectVersioner interface {
    ConvertToVersion(in Object, gv GroupVersioner) (out Object, err error)
}
```

## type Pair

Pair of strings. We keed the name of fields and the doc

```go
type Pair struct {
    Name, Doc string
}
```

## type ParameterCodec

ParameterCodec defines methods for serializing and deserializing API objects to url.Values and performing any necessary conversion. Unlike the normal Codec, query parameters are not self describing and the desired version must be specified.

```go
type ParameterCodec interface {
    // DecodeParameters takes the given url.Values in the specified group version and decodes them
    // into the provided object, or returns an error.
    DecodeParameters(parameters url.Values, from schema.GroupVersion, into Object) error
    // EncodeParameters encodes the provided object as query parameters or returns an error.
    EncodeParameters(obj Object, to schema.GroupVersion) (url.Values, error)
}
```

### func NewParameterCodec

```go
func NewParameterCodec(scheme *Scheme) ParameterCodec
```

NewParameterCodec creates a ParameterCodec capable of transforming url values into versioned objects and back.

## type ProtobufMarshaller

```go
type ProtobufMarshaller interface {
    MarshalTo(data []byte) (int, error)
}
```

## type ProtobufReverseMarshaller

```go
type ProtobufReverseMarshaller interface {
    MarshalToSizedBuffer(data []byte) (int, error)
}
```

## type RawExtension

RawExtension is used to hold extensions in external versions.

To use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.

// Internal package: type MyAPIObject struct \{ runtime.TypeMeta \`json:",inline"\` MyPlugin runtime.Object \`json:"myPlugin"\` \} type PluginA struct \{ AOption string \`json:"aOption"\` \}

// External package: type MyAPIObject struct \{ runtime.TypeMeta \`json:",inline"\` MyPlugin runtime.RawExtension \`json:"myPlugin"\` \} type PluginA struct \{ AOption string \`json:"aOption"\` \}

// On the wire, the JSON will look something like this: \{ "kind":"MyAPIObject", "apiVersion":"v1", "myPlugin": \{ "kind":"PluginA", "aOption":"foo", \}, \}

So what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy \(using pkg/conversion\) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. \(TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.\)

\+k8s:deepcopy\-gen=true \+protobuf=true \+k8s:openapi\-gen=true

```go
type RawExtension struct {
    // Raw is the underlying serialization of this object.
    //
    // TODO: Determine how to detect ContentType and ContentEncoding of 'Raw' data.
    Raw []byte `json:"-" protobuf:"bytes,1,opt,name=raw"`
    // Object can hold a representation of this extension - useful for working with versioned
    // structs.
    Object Object `json:"-"`
}
```

### func \(\*RawExtension\) DeepCopy

```go
func (in *RawExtension) DeepCopy() *RawExtension
```

DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RawExtension.

### func \(\*RawExtension\) DeepCopyInto

```go
func (in *RawExtension) DeepCopyInto(out *RawExtension)
```

DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non\-nil.

### func \(\*RawExtension\) Descriptor

```go
func (*RawExtension) Descriptor() ([]byte, []int)
```

### func \(\*RawExtension\) Marshal

```go
func (m *RawExtension) Marshal() (dAtA []byte, err error)
```

### func \(RawExtension\) MarshalJSON

```go
func (re RawExtension) MarshalJSON() ([]byte, error)
```

MarshalJSON may get called on pointers or values, so implement MarshalJSON on value. http://stackoverflow.com/questions/21390979/custom-marshaljson-never-gets-called-in-go

### func \(\*RawExtension\) MarshalTo

```go
func (m *RawExtension) MarshalTo(dAtA []byte) (int, error)
```

### func \(\*RawExtension\) MarshalToSizedBuffer

```go
func (m *RawExtension) MarshalToSizedBuffer(dAtA []byte) (int, error)
```

### func \(\*RawExtension\) ProtoMessage

```go
func (*RawExtension) ProtoMessage()
```

### func \(\*RawExtension\) Reset

```go
func (m *RawExtension) Reset()
```

### func \(\*RawExtension\) Size

```go
func (m *RawExtension) Size() (n int)
```

### func \(\*RawExtension\) String

```go
func (this *RawExtension) String() string
```

### func \(\*RawExtension\) Unmarshal

```go
func (m *RawExtension) Unmarshal(dAtA []byte) error
```

### func \(\*RawExtension\) UnmarshalJSON

```go
func (re *RawExtension) UnmarshalJSON(in []byte) error
```

### func \(\*RawExtension\) XXX\_DiscardUnknown

```go
func (m *RawExtension) XXX_DiscardUnknown()
```

### func \(\*RawExtension\) XXX\_Marshal

```go
func (m *RawExtension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
```

### func \(\*RawExtension\) XXX\_Merge

```go
func (m *RawExtension) XXX_Merge(src proto.Message)
```

### func \(\*RawExtension\) XXX\_Size

```go
func (m *RawExtension) XXX_Size() int
```

### func \(\*RawExtension\) XXX\_Unmarshal

```go
func (m *RawExtension) XXX_Unmarshal(b []byte) error
```

## type ResourceVersioner

ResourceVersioner provides methods for setting and retrieving the resource version from an API object.

```go
type ResourceVersioner interface {
    SetResourceVersion(obj Object, version string) error
    ResourceVersion(obj Object) (string, error)
}
```

## type Scheme

Scheme defines methods for serializing and deserializing API objects, a type registry for converting group, version, and kind information to and from Go schemas, and mappings between Go schemas of different versions. A scheme is the foundation for a versioned API and versioned configuration over time.

In a Scheme, a Type is a particular Go struct, a Version is a point\-in\-time identifier for a particular representation of that Type \(typically backwards compatible\), a Kind is the unique name for that Type within the Version, and a Group identifies a set of Versions, Kinds, and Types that evolve over time. An Unversioned Type is one that is not yet formally bound to a type and is promised to be backwards compatible \(effectively a "v1" of a Type that does not expect to break in the future\).

Schemes are not expected to change at runtime and are only threadsafe after registration is complete.

```go
type Scheme struct {
    // contains filtered or unexported fields
}
```

### func NewScheme

```go
func NewScheme() *Scheme
```

NewScheme creates a new Scheme. This scheme is pluggable by default.

### func \(\*Scheme\) AddConversionFunc

```go
func (s *Scheme) AddConversionFunc(a, b interface{}, fn conversion.ConversionFunc) error
```

AddConversionFunc registers a function that converts between a and b by passing objects of those types to the provided function. The function \*must\* accept objects of a and b \- this machinery will not enforce any other guarantee.

### func \(\*Scheme\) AddFieldLabelConversionFunc

```go
func (s *Scheme) AddFieldLabelConversionFunc(gvk schema.GroupVersionKind, conversionFunc FieldLabelConversionFunc) error
```

AddFieldLabelConversionFunc adds a conversion function to convert field selectors of the given kind from the given version to internal version representation.

### func \(\*Scheme\) AddGeneratedConversionFunc

```go
func (s *Scheme) AddGeneratedConversionFunc(a, b interface{}, fn conversion.ConversionFunc) error
```

AddGeneratedConversionFunc registers a function that converts between a and b by passing objects of those types to the provided function. The function \*must\* accept objects of a and b \- this machinery will not enforce any other guarantee.

### func \(\*Scheme\) AddIgnoredConversionType

```go
func (s *Scheme) AddIgnoredConversionType(from, to interface{}) error
```

AddIgnoredConversionType identifies a pair of types that should be skipped by conversion \(because the data inside them is explicitly dropped during conversion\).

### func \(\*Scheme\) AddKnownTypeWithName

```go
func (s *Scheme) AddKnownTypeWithName(gvk schema.GroupVersionKind, obj Object)
```

AddKnownTypeWithName is like AddKnownTypes, but it lets you specify what this type should be encoded as. Useful for testing when you don't want to make multiple packages to define your structs. Version may not be empty \- use the APIVersionInternal constant if you have a type that does not have a formal version.

### func \(\*Scheme\) AddKnownTypes

```go
func (s *Scheme) AddKnownTypes(gv schema.GroupVersion, types ...Object)
```

AddKnownTypes registers all types passed in 'types' as being members of version 'version'. All objects passed to types should be pointers to structs. The name that go reports for the struct becomes the "kind" field when encoding. Version may not be empty \- use the APIVersionInternal constant if you have a type that does not have a formal version.

### func \(\*Scheme\) AddTypeDefaultingFunc

```go
func (s *Scheme) AddTypeDefaultingFunc(srcType Object, fn func(interface{}))
```

AddTypeDefaultingFunc registers a function that is passed a pointer to an object and can default fields on the object. These functions will be invoked when Default\(\) is called. The function will never be called unless the defaulted object matches srcType. If this function is invoked twice with the same srcType, the fn passed to the later call will be used instead.

### func \(\*Scheme\) AddUnversionedTypes

```go
func (s *Scheme) AddUnversionedTypes(version schema.GroupVersion, types ...Object)
```

AddUnversionedTypes registers the provided types as "unversioned", which means that they follow special rules. Whenever an object of this type is serialized, it is serialized with the provided group version and is not converted. Thus unversioned objects are expected to remain backwards compatible forever, as if they were in an API group and version that would never be updated.

TODO: there is discussion about removing unversioned and replacing it with objects that are manifest into every version with particular schemas. Resolve this method at that point.

### func \(\*Scheme\) AllKnownTypes

```go
func (s *Scheme) AllKnownTypes() map[schema.GroupVersionKind]reflect.Type
```

AllKnownTypes returns the all known types.

### func \(\*Scheme\) Convert

```go
func (s *Scheme) Convert(in, out interface{}, context interface{}) error
```

Convert will attempt to convert in into out. Both must be pointers. For easy testing of conversion functions. Returns an error if the conversion isn't possible. You can call this with types that haven't been registered \(for example, a to test conversion of types that are nested within registered types\). The context interface is passed to the convertor. Convert also supports Unstructured types and will convert them intelligently.

### func \(\*Scheme\) ConvertFieldLabel

```go
func (s *Scheme) ConvertFieldLabel(gvk schema.GroupVersionKind, label, value string) (string, string, error)
```

ConvertFieldLabel alters the given field label and value for an kind field selector from versioned representation to an unversioned one or returns an error.

### func \(\*Scheme\) ConvertToVersion

```go
func (s *Scheme) ConvertToVersion(in Object, target GroupVersioner) (Object, error)
```

ConvertToVersion attempts to convert an input object to its matching Kind in another version within this scheme. Will return an error if the provided version does not contain the inKind \(or a mapping by name defined with AddKnownTypeWithName\). Will also return an error if the conversion does not result in a valid Object being returned. Passes target down to the conversion methods as the Context on the scope.

### func \(\*Scheme\) Converter

```go
func (s *Scheme) Converter() *conversion.Converter
```

Converter allows access to the converter for the scheme

### func \(\*Scheme\) Default

```go
func (s *Scheme) Default(src Object)
```

Default sets defaults on the provided Object.

### func \(\*Scheme\) IsGroupRegistered

```go
func (s *Scheme) IsGroupRegistered(group string) bool
```

IsGroupRegistered returns true if types for the group have been registered with the scheme

### func \(\*Scheme\) IsUnversioned

```go
func (s *Scheme) IsUnversioned(obj Object) (bool, bool)
```

### func \(\*Scheme\) IsVersionRegistered

```go
func (s *Scheme) IsVersionRegistered(version schema.GroupVersion) bool
```

IsVersionRegistered returns true if types for the version have been registered with the scheme

### func \(\*Scheme\) KnownTypes

```go
func (s *Scheme) KnownTypes(gv schema.GroupVersion) map[string]reflect.Type
```

KnownTypes returns the types known for the given version.

### func \(\*Scheme\) Name

```go
func (s *Scheme) Name() string
```

### func \(\*Scheme\) New

```go
func (s *Scheme) New(kind schema.GroupVersionKind) (Object, error)
```

New returns a new API object of the given version and name, or an error if it hasn't been registered. The version and kind fields must be specified.

### func \(\*Scheme\) ObjectKinds

```go
func (s *Scheme) ObjectKinds(obj Object) ([]schema.GroupVersionKind, bool, error)
```

ObjectKinds returns all possible group,version,kind of the go object, true if the object is considered unversioned, or an error if it's not a pointer or is unregistered.

### func \(\*Scheme\) PreferredVersionAllGroups

```go
func (s *Scheme) PreferredVersionAllGroups() []schema.GroupVersion
```

PreferredVersionAllGroups returns the most preferred version for every group. group ordering is random.

### func \(\*Scheme\) PrioritizedVersionsAllGroups

```go
func (s *Scheme) PrioritizedVersionsAllGroups() []schema.GroupVersion
```

PrioritizedVersionsAllGroups returns all known versions in their priority order.  Groups are random, but versions for a single group are prioritized

### func \(\*Scheme\) PrioritizedVersionsForGroup

```go
func (s *Scheme) PrioritizedVersionsForGroup(group string) []schema.GroupVersion
```

PrioritizedVersionsForGroup returns versions for a single group in priority order

### func \(\*Scheme\) Recognizes

```go
func (s *Scheme) Recognizes(gvk schema.GroupVersionKind) bool
```

Recognizes returns true if the scheme is able to handle the provided group,version,kind of an object.

### func \(\*Scheme\) SetVersionPriority

```go
func (s *Scheme) SetVersionPriority(versions ...schema.GroupVersion) error
```

SetVersionPriority allows specifying a precise order of priority. All specified versions must be in the same group, and the specified order overwrites any previously specified order for this group

### func \(\*Scheme\) UnsafeConvertToVersion

```go
func (s *Scheme) UnsafeConvertToVersion(in Object, target GroupVersioner) (Object, error)
```

UnsafeConvertToVersion will convert in to the provided target if such a conversion is possible, but does not guarantee the output object does not share fields with the input object. It attempts to be as efficient as possible when doing conversion.

### func \(\*Scheme\) VersionsForGroupKind

```go
func (s *Scheme) VersionsForGroupKind(gk schema.GroupKind) []schema.GroupVersion
```

VersionsForGroupKind returns the versions that a particular GroupKind can be converted to within the given group. A GroupKind might be converted to a different group. That information is available in EquivalentResourceMapper.

## type SchemeBuilder

SchemeBuilder collects functions that add things to a scheme. It's to allow code to compile without explicitly referencing generated types. You should declare one in each package that will have generated deep copy or conversion functions.

```go
type SchemeBuilder []func(*Scheme) error
```

### func NewSchemeBuilder

```go
func NewSchemeBuilder(funcs ...func(*Scheme) error) SchemeBuilder
```

NewSchemeBuilder calls Register for you.

### func \(\*SchemeBuilder\) AddToScheme

```go
func (sb *SchemeBuilder) AddToScheme(s *Scheme) error
```

AddToScheme applies all the stored functions to the scheme. A non\-nil error indicates that one function failed and the attempt was abandoned.

### func \(\*SchemeBuilder\) Register

```go
func (sb *SchemeBuilder) Register(funcs ...func(*Scheme) error)
```

Register adds a scheme setup function to the list.

## type SelfLinker

SelfLinker provides methods for setting and retrieving the SelfLink field of an API object.

```go
type SelfLinker interface {
    SetSelfLink(obj Object, selfLink string) error
    SelfLink(obj Object) (string, error)

    // Knowing Name is sometimes necessary to use a SelfLinker.
    Name(obj Object) (string, error)
    // Knowing Namespace is sometimes necessary to use a SelfLinker
    Namespace(obj Object) (string, error)
}
```

## type Serializer

Serializer is the core interface for transforming objects into a serialized format and back. Implementations may choose to perform conversion of the object, but no assumptions should be made.

```go
type Serializer interface {
    Encoder
    Decoder
}
```

### func NewBase64Serializer

```go
func NewBase64Serializer(e Encoder, d Decoder) Serializer
```

## type SerializerInfo

SerializerInfo contains information about a specific serialization format

```go
type SerializerInfo struct {
    // MediaType is the value that represents this serializer over the wire.
    MediaType string
    // MediaTypeType is the first part of the MediaType ("application" in "application/json").
    MediaTypeType string
    // MediaTypeSubType is the second part of the MediaType ("json" in "application/json").
    MediaTypeSubType string
    // EncodesAsText indicates this serializer can be encoded to UTF-8 safely.
    EncodesAsText bool
    // Serializer is the individual object serializer for this media type.
    Serializer Serializer
    // PrettySerializer, if set, can serialize this object in a form biased towards
    // readability.
    PrettySerializer Serializer
    // StreamSerializer, if set, describes the streaming serialization format
    // for this media type.
    StreamSerializer *StreamSerializerInfo
}
```

### func SerializerInfoForMediaType

```go
func SerializerInfoForMediaType(types []SerializerInfo, mediaType string) (SerializerInfo, bool)
```

SerializerInfoForMediaType returns the first info in types that has a matching media type \(which cannot include media\-type parameters\), or the first info with an empty media type, or false if no type matches.

## type StorageSerializer

StorageSerializer is an interface used for obtaining encoders, decoders, and serializers that can read and write data at rest. This would commonly be used by client tools that must read files, or server side storage interfaces that persist restful objects.

```go
type StorageSerializer interface {
    // SupportedMediaTypes are the media types supported for reading and writing objects.
    SupportedMediaTypes() []SerializerInfo

    // UniversalDeserializer returns a Serializer that can read objects in multiple supported formats
    // by introspecting the data at rest.
    UniversalDeserializer() Decoder

    // EncoderForVersion returns an encoder that ensures objects being written to the provided
    // serializer are in the provided group version.
    EncoderForVersion(serializer Encoder, gv GroupVersioner) Encoder
    // DecoderForVersion returns a decoder that ensures objects being read by the provided
    // serializer are in the provided group version by default.
    DecoderToVersion(serializer Decoder, gv GroupVersioner) Decoder
}
```

## type StreamSerializerInfo

StreamSerializerInfo contains information about a specific stream serialization format

```go
type StreamSerializerInfo struct {
    // EncodesAsText indicates this serializer can be encoded to UTF-8 safely.
    EncodesAsText bool
    // Serializer is the top level object serializer for this type when streaming
    Serializer
    // Framer is the factory for retrieving streams that separate objects on the wire
    Framer
}
```

## type TypeMeta

TypeMeta is shared by all top level objects. The proper way to use it is to inline it in your type, like this: type MyAwesomeAPIObject struct \{ runtime.TypeMeta    \`json:",inline"\` ... // other fields \} func \(obj \*MyAwesomeAPIObject\) SetGroupVersionKind\(gvk \*metav1.GroupVersionKind\) \{ metav1.UpdateTypeMeta\(obj,gvk\) \}; GroupVersionKind\(\) \*GroupVersionKind

TypeMeta is provided here for convenience. You may use it directly from this package or define your own with the same fields.

\+k8s:deepcopy\-gen=false \+protobuf=true \+k8s:openapi\-gen=true

```go
type TypeMeta struct {
    // +optional
    APIVersion string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" protobuf:"bytes,1,opt,name=apiVersion"`
    // +optional
    Kind string `json:"kind,omitempty" yaml:"kind,omitempty" protobuf:"bytes,2,opt,name=kind"`
}
```

### func \(\*TypeMeta\) Descriptor

```go
func (*TypeMeta) Descriptor() ([]byte, []int)
```

### func \(\*TypeMeta\) GetObjectKind

```go
func (obj *TypeMeta) GetObjectKind() schema.ObjectKind
```

### func \(\*TypeMeta\) GroupVersionKind

```go
func (obj *TypeMeta) GroupVersionKind() schema.GroupVersionKind
```

GroupVersionKind satisfies the ObjectKind interface for all objects that embed TypeMeta

### func \(\*TypeMeta\) Marshal

```go
func (m *TypeMeta) Marshal() (dAtA []byte, err error)
```

### func \(\*TypeMeta\) MarshalTo

```go
func (m *TypeMeta) MarshalTo(dAtA []byte) (int, error)
```

### func \(\*TypeMeta\) MarshalToSizedBuffer

```go
func (m *TypeMeta) MarshalToSizedBuffer(dAtA []byte) (int, error)
```

### func \(\*TypeMeta\) ProtoMessage

```go
func (*TypeMeta) ProtoMessage()
```

### func \(\*TypeMeta\) Reset

```go
func (m *TypeMeta) Reset()
```

### func \(\*TypeMeta\) SetGroupVersionKind

```go
func (obj *TypeMeta) SetGroupVersionKind(gvk schema.GroupVersionKind)
```

SetGroupVersionKind satisfies the ObjectKind interface for all objects that embed TypeMeta

### func \(\*TypeMeta\) Size

```go
func (m *TypeMeta) Size() (n int)
```

### func \(\*TypeMeta\) String

```go
func (this *TypeMeta) String() string
```

### func \(\*TypeMeta\) Unmarshal

```go
func (m *TypeMeta) Unmarshal(dAtA []byte) error
```

### func \(\*TypeMeta\) XXX\_DiscardUnknown

```go
func (m *TypeMeta) XXX_DiscardUnknown()
```

### func \(\*TypeMeta\) XXX\_Marshal

```go
func (m *TypeMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
```

### func \(\*TypeMeta\) XXX\_Merge

```go
func (m *TypeMeta) XXX_Merge(src proto.Message)
```

### func \(\*TypeMeta\) XXX\_Size

```go
func (m *TypeMeta) XXX_Size() int
```

### func \(\*TypeMeta\) XXX\_Unmarshal

```go
func (m *TypeMeta) XXX_Unmarshal(b []byte) error
```

## type Unknown

Unknown allows api objects with unknown types to be passed\-through. This can be used to deal with the API objects from a plug\-in. Unknown objects still have functioning TypeMeta features\-\- kind, version, etc. TODO: Make this object have easy access to field based accessors and settors for metadata and field mutatation.

\+k8s:deepcopy\-gen=true \+k8s:deepcopy\-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object \+protobuf=true \+k8s:openapi\-gen=true

```go
type Unknown struct {
    TypeMeta `json:",inline" protobuf:"bytes,1,opt,name=typeMeta"`
    // Raw will hold the complete serialized object which couldn't be matched
    // with a registered type. Most likely, nothing should be done with this
    // except for passing it through the system.
    Raw []byte `protobuf:"bytes,2,opt,name=raw"`
    // ContentEncoding is encoding used to encode 'Raw' data.
    // Unspecified means no encoding.
    ContentEncoding string `protobuf:"bytes,3,opt,name=contentEncoding"`
    // ContentType  is serialization method used to serialize 'Raw'.
    // Unspecified means ContentTypeJSON.
    ContentType string `protobuf:"bytes,4,opt,name=contentType"`
}
```

### func \(\*Unknown\) DeepCopy

```go
func (in *Unknown) DeepCopy() *Unknown
```

DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Unknown.

### func \(\*Unknown\) DeepCopyInto

```go
func (in *Unknown) DeepCopyInto(out *Unknown)
```

DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non\-nil.

### func \(\*Unknown\) DeepCopyObject

```go
func (in *Unknown) DeepCopyObject() Object
```

DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new Object.

### func \(\*Unknown\) Descriptor

```go
func (*Unknown) Descriptor() ([]byte, []int)
```

### func \(\*Unknown\) Marshal

```go
func (m *Unknown) Marshal() (dAtA []byte, err error)
```

### func \(Unknown\) MarshalJSON

```go
func (e Unknown) MarshalJSON() ([]byte, error)
```

Marshal may get called on pointers or values, so implement MarshalJSON on value. http://stackoverflow.com/questions/21390979/custom-marshaljson-never-gets-called-in-go

### func \(\*Unknown\) MarshalTo

```go
func (m *Unknown) MarshalTo(dAtA []byte) (int, error)
```

### func \(\*Unknown\) MarshalToSizedBuffer

```go
func (m *Unknown) MarshalToSizedBuffer(dAtA []byte) (int, error)
```

### func \(\*Unknown\) NestedMarshalTo

```go
func (m *Unknown) NestedMarshalTo(data []byte, b ProtobufMarshaller, size uint64) (int, error)
```

NestedMarshalTo allows a caller to avoid extra allocations during serialization of an Unknown that will contain an object that implements ProtobufMarshaller or ProtobufReverseMarshaller.

### func \(\*Unknown\) ProtoMessage

```go
func (*Unknown) ProtoMessage()
```

### func \(\*Unknown\) Reset

```go
func (m *Unknown) Reset()
```

### func \(\*Unknown\) Size

```go
func (m *Unknown) Size() (n int)
```

### func \(\*Unknown\) String

```go
func (this *Unknown) String() string
```

### func \(\*Unknown\) Unmarshal

```go
func (m *Unknown) Unmarshal(dAtA []byte) error
```

### func \(\*Unknown\) UnmarshalJSON

```go
func (e *Unknown) UnmarshalJSON(in []byte) error
```

### func \(\*Unknown\) XXX\_DiscardUnknown

```go
func (m *Unknown) XXX_DiscardUnknown()
```

### func \(\*Unknown\) XXX\_Marshal

```go
func (m *Unknown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
```

### func \(\*Unknown\) XXX\_Merge

```go
func (m *Unknown) XXX_Merge(src proto.Message)
```

### func \(\*Unknown\) XXX\_Size

```go
func (m *Unknown) XXX_Size() int
```

### func \(\*Unknown\) XXX\_Unmarshal

```go
func (m *Unknown) XXX_Unmarshal(b []byte) error
```

## type Unstructured

Unstructured objects store values as map\[string\]interface\{\}, with only values that can be serialized to JSON allowed.

```go
type Unstructured interface {
    Object
    // NewEmptyInstance returns a new instance of the concrete type containing only kind/apiVersion and no other data.
    // This should be called instead of reflect.New() for unstructured types because the go type alone does not preserve kind/apiVersion info.
    NewEmptyInstance() Unstructured
    // UnstructuredContent returns a non-nil map with this object's contents. Values may be
    // []interface{}, map[string]interface{}, or any primitive type. Contents are typically serialized to
    // and from JSON. SetUnstructuredContent should be used to mutate the contents.
    UnstructuredContent() map[string]interface{}
    // SetUnstructuredContent updates the object content to match the provided map.
    SetUnstructuredContent(map[string]interface{})
    // IsList returns true if this type is a list or matches the list convention - has an array called "items".
    IsList() bool
    // EachListItem should pass a single item out of the list as an Object to the provided function. Any
    // error should terminate the iteration. If IsList() returns false, this method should return an error
    // instead of calling the provided function.
    EachListItem(func(Object) error) error
}
```

## type UnstructuredConverter

UnstructuredConverter is an interface for converting between interface\{\} and map\[string\]interface representation.

```go
type UnstructuredConverter interface {
    ToUnstructured(obj interface{}) (map[string]interface{}, error)
    FromUnstructured(u map[string]interface{}, obj interface{}) error
}
```

### func NewTestUnstructuredConverter

```go
func NewTestUnstructuredConverter(comparison conversion.Equalities) UnstructuredConverter
```

NewTestUnstructuredConverter creates an UnstructuredConverter that accepts JSON typed maps and translates them to Go types via reflection. It performs mismatch detection automatically and is intended for use by external test tools. Use DefaultUnstructuredConverter if you do not explicitly need mismatch detection.

## type WithVersionEncoder

WithVersionEncoder serializes an object and ensures the GVK is set.

```go
type WithVersionEncoder struct {
    Version GroupVersioner
    Encoder
    ObjectTyper
}
```

### func \(WithVersionEncoder\) Encode

```go
func (e WithVersionEncoder) Encode(obj Object, stream io.Writer) error
```

Encode does not do conversion. It sets the gvk during serialization.

## type WithoutVersionDecoder

WithoutVersionDecoder clears the group version kind of a deserialized object.

```go
type WithoutVersionDecoder struct {
    Decoder
}
```

### func \(WithoutVersionDecoder\) Decode

```go
func (d WithoutVersionDecoder) Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)
```

Decode does not do conversion. It removes the gvk during deserialization.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
