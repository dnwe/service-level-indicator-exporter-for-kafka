<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# schema

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/k8s.io/apimachinery/pkg/runtime/schema"
```

## Index

- [Variables](<#variables>)
- [func ParseKindArg(arg string) (*GroupVersionKind, GroupKind)](<#func-parsekindarg>)
- [func ParseResourceArg(arg string) (*GroupVersionResource, GroupResource)](<#func-parseresourcearg>)
- [type GroupKind](<#type-groupkind>)
  - [func ParseGroupKind(gk string) GroupKind](<#func-parsegroupkind>)
  - [func (gk GroupKind) Empty() bool](<#func-groupkind-empty>)
  - [func (gk GroupKind) String() string](<#func-groupkind-string>)
  - [func (gk GroupKind) WithVersion(version string) GroupVersionKind](<#func-groupkind-withversion>)
- [type GroupResource](<#type-groupresource>)
  - [func ParseGroupResource(gr string) GroupResource](<#func-parsegroupresource>)
  - [func (gr GroupResource) Empty() bool](<#func-groupresource-empty>)
  - [func (gr GroupResource) String() string](<#func-groupresource-string>)
  - [func (gr GroupResource) WithVersion(version string) GroupVersionResource](<#func-groupresource-withversion>)
- [type GroupVersion](<#type-groupversion>)
  - [func ParseGroupVersion(gv string) (GroupVersion, error)](<#func-parsegroupversion>)
  - [func (gv GroupVersion) Empty() bool](<#func-groupversion-empty>)
  - [func (gv GroupVersion) Identifier() string](<#func-groupversion-identifier>)
  - [func (gv GroupVersion) KindForGroupVersionKinds(kinds []GroupVersionKind) (target GroupVersionKind, ok bool)](<#func-groupversion-kindforgroupversionkinds>)
  - [func (gv GroupVersion) String() string](<#func-groupversion-string>)
  - [func (gv GroupVersion) WithKind(kind string) GroupVersionKind](<#func-groupversion-withkind>)
  - [func (gv GroupVersion) WithResource(resource string) GroupVersionResource](<#func-groupversion-withresource>)
- [type GroupVersionKind](<#type-groupversionkind>)
  - [func FromAPIVersionAndKind(apiVersion, kind string) GroupVersionKind](<#func-fromapiversionandkind>)
  - [func (gvk GroupVersionKind) Empty() bool](<#func-groupversionkind-empty>)
  - [func (gvk GroupVersionKind) GroupKind() GroupKind](<#func-groupversionkind-groupkind>)
  - [func (gvk GroupVersionKind) GroupVersion() GroupVersion](<#func-groupversionkind-groupversion>)
  - [func (gvk GroupVersionKind) String() string](<#func-groupversionkind-string>)
  - [func (gvk GroupVersionKind) ToAPIVersionAndKind() (string, string)](<#func-groupversionkind-toapiversionandkind>)
- [type GroupVersionResource](<#type-groupversionresource>)
  - [func (gvr GroupVersionResource) Empty() bool](<#func-groupversionresource-empty>)
  - [func (gvr GroupVersionResource) GroupResource() GroupResource](<#func-groupversionresource-groupresource>)
  - [func (gvr GroupVersionResource) GroupVersion() GroupVersion](<#func-groupversionresource-groupversion>)
  - [func (gvr GroupVersionResource) String() string](<#func-groupversionresource-string>)
- [type GroupVersions](<#type-groupversions>)
  - [func (gvs GroupVersions) Identifier() string](<#func-groupversions-identifier>)
  - [func (gvs GroupVersions) KindForGroupVersionKinds(kinds []GroupVersionKind) (GroupVersionKind, bool)](<#func-groupversions-kindforgroupversionkinds>)
- [type ObjectKind](<#type-objectkind>)


## Variables

EmptyObjectKind implements the ObjectKind interface as a noop

```go
var EmptyObjectKind = emptyObjectKind{}
```

## func ParseKindArg

```go
func ParseKindArg(arg string) (*GroupVersionKind, GroupKind)
```

ParseKindArg takes the common style of string which may be either \`Kind.group.com\` or \`Kind.version.group.com\` and parses it out into both possibilities. This code takes no responsibility for knowing which representation was intended but with a knowledge of all GroupKinds, calling code can take a very good guess. If there are only two segments, then \`\*GroupVersionResource\` is nil. \`Kind.group.com\` \-\> \`group=com, version=group, kind=Kind\` and \`group=group.com, kind=Kind\`

## func ParseResourceArg

```go
func ParseResourceArg(arg string) (*GroupVersionResource, GroupResource)
```

ParseResourceArg takes the common style of string which may be either \`resource.group.com\` or \`resource.version.group.com\` and parses it out into both possibilities.  This code takes no responsibility for knowing which representation was intended but with a knowledge of all GroupVersions, calling code can take a very good guess.  If there are only two segments, then \`\*GroupVersionResource\` is nil. \`resource.group.com\` \-\> \`group=com, version=group, resource=resource\` and \`group=group.com, resource=resource\`

## type GroupKind

GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types

```go
type GroupKind struct {
    Group string
    Kind  string
}
```

### func ParseGroupKind

```go
func ParseGroupKind(gk string) GroupKind
```

### func \(GroupKind\) Empty

```go
func (gk GroupKind) Empty() bool
```

### func \(GroupKind\) String

```go
func (gk GroupKind) String() string
```

### func \(GroupKind\) WithVersion

```go
func (gk GroupKind) WithVersion(version string) GroupVersionKind
```

## type GroupResource

GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types

```go
type GroupResource struct {
    Group    string
    Resource string
}
```

### func ParseGroupResource

```go
func ParseGroupResource(gr string) GroupResource
```

ParseGroupResource turns "resource.group" string into a GroupResource struct.  Empty strings are allowed for each field.

### func \(GroupResource\) Empty

```go
func (gr GroupResource) Empty() bool
```

### func \(GroupResource\) String

```go
func (gr GroupResource) String() string
```

### func \(GroupResource\) WithVersion

```go
func (gr GroupResource) WithVersion(version string) GroupVersionResource
```

## type GroupVersion

GroupVersion contains the "group" and the "version", which uniquely identifies the API.

```go
type GroupVersion struct {
    Group   string
    Version string
}
```

### func ParseGroupVersion

```go
func ParseGroupVersion(gv string) (GroupVersion, error)
```

ParseGroupVersion turns "group/version" string into a GroupVersion struct. It reports error if it cannot parse the string.

### func \(GroupVersion\) Empty

```go
func (gv GroupVersion) Empty() bool
```

Empty returns true if group and version are empty

### func \(GroupVersion\) Identifier

```go
func (gv GroupVersion) Identifier() string
```

Identifier implements runtime.GroupVersioner interface.

### func \(GroupVersion\) KindForGroupVersionKinds

```go
func (gv GroupVersion) KindForGroupVersionKinds(kinds []GroupVersionKind) (target GroupVersionKind, ok bool)
```

KindForGroupVersionKinds identifies the preferred GroupVersionKind out of a list. It returns ok false if none of the options match the group. It prefers a match to group and version over just group. TODO: Move GroupVersion to a package under pkg/runtime, since it's used by scheme. TODO: Introduce an adapter type between GroupVersion and runtime.GroupVersioner, and use LegacyCodec\(GroupVersion\) in fewer places.

### func \(GroupVersion\) String

```go
func (gv GroupVersion) String() string
```

String puts "group" and "version" into a single "group/version" string. For the legacy v1 it returns "v1".

### func \(GroupVersion\) WithKind

```go
func (gv GroupVersion) WithKind(kind string) GroupVersionKind
```

WithKind creates a GroupVersionKind based on the method receiver's GroupVersion and the passed Kind.

### func \(GroupVersion\) WithResource

```go
func (gv GroupVersion) WithResource(resource string) GroupVersionResource
```

WithResource creates a GroupVersionResource based on the method receiver's GroupVersion and the passed Resource.

## type GroupVersionKind

GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling

```go
type GroupVersionKind struct {
    Group   string
    Version string
    Kind    string
}
```

### func FromAPIVersionAndKind

```go
func FromAPIVersionAndKind(apiVersion, kind string) GroupVersionKind
```

FromAPIVersionAndKind returns a GVK representing the provided fields for types that do not use TypeMeta. This method exists to support test types and legacy serializations that have a distinct group and kind. TODO: further reduce usage of this method.

### func \(GroupVersionKind\) Empty

```go
func (gvk GroupVersionKind) Empty() bool
```

Empty returns true if group, version, and kind are empty

### func \(GroupVersionKind\) GroupKind

```go
func (gvk GroupVersionKind) GroupKind() GroupKind
```

### func \(GroupVersionKind\) GroupVersion

```go
func (gvk GroupVersionKind) GroupVersion() GroupVersion
```

### func \(GroupVersionKind\) String

```go
func (gvk GroupVersionKind) String() string
```

### func \(GroupVersionKind\) ToAPIVersionAndKind

```go
func (gvk GroupVersionKind) ToAPIVersionAndKind() (string, string)
```

ToAPIVersionAndKind is a convenience method for satisfying runtime.Object on types that do not use TypeMeta.

## type GroupVersionResource

GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling

```go
type GroupVersionResource struct {
    Group    string
    Version  string
    Resource string
}
```

### func \(GroupVersionResource\) Empty

```go
func (gvr GroupVersionResource) Empty() bool
```

### func \(GroupVersionResource\) GroupResource

```go
func (gvr GroupVersionResource) GroupResource() GroupResource
```

### func \(GroupVersionResource\) GroupVersion

```go
func (gvr GroupVersionResource) GroupVersion() GroupVersion
```

### func \(GroupVersionResource\) String

```go
func (gvr GroupVersionResource) String() string
```

## type GroupVersions

GroupVersions can be used to represent a set of desired group versions. TODO: Move GroupVersions to a package under pkg/runtime, since it's used by scheme. TODO: Introduce an adapter type between GroupVersions and runtime.GroupVersioner, and use LegacyCodec\(GroupVersion\) in fewer places.

```go
type GroupVersions []GroupVersion
```

### func \(GroupVersions\) Identifier

```go
func (gvs GroupVersions) Identifier() string
```

Identifier implements runtime.GroupVersioner interface.

### func \(GroupVersions\) KindForGroupVersionKinds

```go
func (gvs GroupVersions) KindForGroupVersionKinds(kinds []GroupVersionKind) (GroupVersionKind, bool)
```

KindForGroupVersionKinds identifies the preferred GroupVersionKind out of a list. It returns ok false if none of the options match the group.

## type ObjectKind

All objects that are serialized from a Scheme encode their type information. This interface is used by serialization to set type information from the Scheme onto the serialized version of an object. For objects that cannot be serialized or have unique requirements, this interface may be a no\-op.

```go
type ObjectKind interface {
    // SetGroupVersionKind sets or clears the intended serialized kind of an object. Passing kind nil
    // should clear the current setting.
    SetGroupVersionKind(kind GroupVersionKind)
    // GroupVersionKind returns the stored group, version, and kind of an object, or an empty struct
    // if the object does not expose or provide these fields.
    GroupVersionKind() GroupVersionKind
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
