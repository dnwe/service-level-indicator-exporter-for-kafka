<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# labels

```go
import "k8s.io/apimachinery/pkg/labels"
```

Package labels implements a simple label system, parsing and matching selectors with sets of labels.

## Index

- [func Conflicts(labels1, labels2 Set) bool](<#func-conflicts>)
- [func Equals(labels1, labels2 Set) bool](<#func-equals>)
- [func FormatLabels(labelMap map[string]string) string](<#func-formatlabels>)
- [type ByKey](<#type-bykey>)
  - [func (a ByKey) Len() int](<#func-bykey-len>)
  - [func (a ByKey) Less(i, j int) bool](<#func-bykey-less>)
  - [func (a ByKey) Swap(i, j int)](<#func-bykey-swap>)
- [type Labels](<#type-labels>)
- [type Lexer](<#type-lexer>)
  - [func (l *Lexer) Lex() (tok Token, lit string)](<#func-lexer-lex>)
- [type Parser](<#type-parser>)
- [type ParserContext](<#type-parsercontext>)
- [type Requirement](<#type-requirement>)
  - [func NewRequirement(key string, op selection.Operator, vals []string, opts ...field.PathOption) (*Requirement, error)](<#func-newrequirement>)
  - [func ParseToRequirements(selector string, opts ...field.PathOption) ([]Requirement, error)](<#func-parsetorequirements>)
  - [func (in *Requirement) DeepCopy() *Requirement](<#func-requirement-deepcopy>)
  - [func (in *Requirement) DeepCopyInto(out *Requirement)](<#func-requirement-deepcopyinto>)
  - [func (r Requirement) Equal(x Requirement) bool](<#func-requirement-equal>)
  - [func (r *Requirement) Key() string](<#func-requirement-key>)
  - [func (r *Requirement) Matches(ls Labels) bool](<#func-requirement-matches>)
  - [func (r *Requirement) Operator() selection.Operator](<#func-requirement-operator>)
  - [func (r *Requirement) String() string](<#func-requirement-string>)
  - [func (r *Requirement) Values() sets.String](<#func-requirement-values>)
- [type Requirements](<#type-requirements>)
- [type ScannedItem](<#type-scanneditem>)
- [type Selector](<#type-selector>)
  - [func Everything() Selector](<#func-everything>)
  - [func NewSelector() Selector](<#func-newselector>)
  - [func Nothing() Selector](<#func-nothing>)
  - [func Parse(selector string, opts ...field.PathOption) (Selector, error)](<#func-parse>)
  - [func SelectorFromSet(ls Set) Selector](<#func-selectorfromset>)
  - [func SelectorFromValidatedSet(ls Set) Selector](<#func-selectorfromvalidatedset>)
  - [func ValidatedSelectorFromSet(ls Set) (Selector, error)](<#func-validatedselectorfromset>)
- [type Set](<#type-set>)
  - [func ConvertSelectorToLabelsMap(selector string, opts ...field.PathOption) (Set, error)](<#func-convertselectortolabelsmap>)
  - [func Merge(labels1, labels2 Set) Set](<#func-merge>)
  - [func (ls Set) AsSelector() Selector](<#func-set-asselector>)
  - [func (ls Set) AsSelectorPreValidated() Selector](<#func-set-asselectorprevalidated>)
  - [func (ls Set) AsValidatedSelector() (Selector, error)](<#func-set-asvalidatedselector>)
  - [func (ls Set) Get(label string) string](<#func-set-get>)
  - [func (ls Set) Has(label string) bool](<#func-set-has>)
  - [func (ls Set) String() string](<#func-set-string>)
- [type Token](<#type-token>)


## func Conflicts

```go
func Conflicts(labels1, labels2 Set) bool
```

Conflicts takes 2 maps and returns true if there a key match between the maps but the value doesn't match, and returns false in other cases

## func Equals

```go
func Equals(labels1, labels2 Set) bool
```

Equals returns true if the given maps are equal

## func FormatLabels

```go
func FormatLabels(labelMap map[string]string) string
```

FormatLabels converts label map into plain string

## type ByKey

ByKey sorts requirements by key to obtain deterministic parser

```go
type ByKey []Requirement
```

### func \(ByKey\) Len

```go
func (a ByKey) Len() int
```

### func \(ByKey\) Less

```go
func (a ByKey) Less(i, j int) bool
```

### func \(ByKey\) Swap

```go
func (a ByKey) Swap(i, j int)
```

## type Labels

Labels allows you to present labels independently from their storage.

```go
type Labels interface {
    // Has returns whether the provided label exists.
    Has(label string) (exists bool)

    // Get returns the value for the provided label.
    Get(label string) (value string)
}
```

## type Lexer

Lexer represents the Lexer struct for label selector. It contains necessary informationt to tokenize the input string

```go
type Lexer struct {
    // contains filtered or unexported fields
}
```

### func \(\*Lexer\) Lex

```go
func (l *Lexer) Lex() (tok Token, lit string)
```

Lex returns a pair of Token and the literal literal is meaningfull only for IdentifierToken token

## type Parser

Parser data structure contains the label selector parser data structure

```go
type Parser struct {
    // contains filtered or unexported fields
}
```

## type ParserContext

ParserContext represents context during parsing: some literal for example 'in' and 'notin' can be recognized as operator for example 'x in \(a\)' but it can be recognized as value for example 'value in \(in\)'

```go
type ParserContext int
```

```go
const (
    // KeyAndOperator represents key and operator
    KeyAndOperator ParserContext = iota
    // Values represents values
    Values
)
```

## type Requirement

Requirement contains values, a key, and an operator that relates the key and values. The zero value of Requirement is invalid. Requirement implements both set based match and exact match Requirement should be initialized via NewRequirement constructor for creating a valid Requirement. \+k8s:deepcopy\-gen=true

```go
type Requirement struct {
    // contains filtered or unexported fields
}
```

### func NewRequirement

```go
func NewRequirement(key string, op selection.Operator, vals []string, opts ...field.PathOption) (*Requirement, error)
```

NewRequirement is the constructor for a Requirement. If any of these rules is violated, an error is returned: \(1\) The operator can only be In, NotIn, Equals, DoubleEquals, Gt, Lt, NotEquals, Exists, or DoesNotExist. \(2\) If the operator is In or NotIn, the values set must be non\-empty. \(3\) If the operator is Equals, DoubleEquals, or NotEquals, the values set must contain one value. \(4\) If the operator is Exists or DoesNotExist, the value set must be empty. \(5\) If the operator is Gt or Lt, the values set must contain only one value, which will be interpreted as an integer. \(6\) The key is invalid due to its length, or sequence of characters. See validateLabelKey for more details.

The empty string is a valid value in the input values set. Returned error, if not nil, is guaranteed to be an aggregated field.ErrorList

### func ParseToRequirements

```go
func ParseToRequirements(selector string, opts ...field.PathOption) ([]Requirement, error)
```

ParseToRequirements takes a string representing a selector and returns a list of requirements. This function is suitable for those callers that perform additional processing on selector requirements. See the documentation for Parse\(\) function for more details. TODO: Consider exporting the internalSelector type instead.

### func \(\*Requirement\) DeepCopy

```go
func (in *Requirement) DeepCopy() *Requirement
```

DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Requirement.

### func \(\*Requirement\) DeepCopyInto

```go
func (in *Requirement) DeepCopyInto(out *Requirement)
```

DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non\-nil.

### func \(Requirement\) Equal

```go
func (r Requirement) Equal(x Requirement) bool
```

Equal checks the equality of requirement.

### func \(\*Requirement\) Key

```go
func (r *Requirement) Key() string
```

Key returns requirement key

### func \(\*Requirement\) Matches

```go
func (r *Requirement) Matches(ls Labels) bool
```

Matches returns true if the Requirement matches the input Labels. There is a match in the following cases: \(1\) The operator is Exists and Labels has the Requirement's key. \(2\) The operator is In, Labels has the Requirement's key and Labels' value for that key is in Requirement's value set. \(3\) The operator is NotIn, Labels has the Requirement's key and Labels' value for that key is not in Requirement's value set. \(4\) The operator is DoesNotExist or NotIn and Labels does not have the Requirement's key. \(5\) The operator is GreaterThanOperator or LessThanOperator, and Labels has the Requirement's key and the corresponding value satisfies mathematical inequality.

### func \(\*Requirement\) Operator

```go
func (r *Requirement) Operator() selection.Operator
```

Operator returns requirement operator

### func \(\*Requirement\) String

```go
func (r *Requirement) String() string
```

String returns a human\-readable string that represents this Requirement. If called on an invalid Requirement, an error is returned. See NewRequirement for creating a valid Requirement.

### func \(\*Requirement\) Values

```go
func (r *Requirement) Values() sets.String
```

Values returns requirement values

## type Requirements

Requirements is AND of all requirements.

```go
type Requirements []Requirement
```

## type ScannedItem

ScannedItem contains the Token and the literal produced by the lexer.

```go
type ScannedItem struct {
    // contains filtered or unexported fields
}
```

## type Selector

Selector represents a label selector.

```go
type Selector interface {
    // Matches returns true if this selector matches the given set of labels.
    Matches(Labels) bool

    // Empty returns true if this selector does not restrict the selection space.
    Empty() bool

    // String returns a human readable string that represents this selector.
    String() string

    // Add adds requirements to the Selector
    Add(r ...Requirement) Selector

    // Requirements converts this interface into Requirements to expose
    // more detailed selection information.
    // If there are querying parameters, it will return converted requirements and selectable=true.
    // If this selector doesn't want to select anything, it will return selectable=false.
    Requirements() (requirements Requirements, selectable bool)

    // Make a deep copy of the selector.
    DeepCopySelector() Selector

    // RequiresExactMatch allows a caller to introspect whether a given selector
    // requires a single specific label to be set, and if so returns the value it
    // requires.
    RequiresExactMatch(label string) (value string, found bool)
}
```

### func Everything

```go
func Everything() Selector
```

Everything returns a selector that matches all labels.

### func NewSelector

```go
func NewSelector() Selector
```

NewSelector returns a nil selector

### func Nothing

```go
func Nothing() Selector
```

Nothing returns a selector that matches no labels

### func Parse

```go
func Parse(selector string, opts ...field.PathOption) (Selector, error)
```

Parse takes a string representing a selector and returns a selector object, or an error. This parsing function differs from ParseSelector as they parse different selectors with different syntaxes. The input will cause an error if it does not follow this form:

\<selector\-syntax\>         ::= \<requirement\> | \<requirement\> "," \<selector\-syntax\> \<requirement\>             ::= \[\!\] KEY \[ \<set\-based\-restriction\> | \<exact\-match\-restriction\> \] \<set\-based\-restriction\>   ::= "" | \<inclusion\-exclusion\> \<value\-set\> \<inclusion\-exclusion\>     ::= \<inclusion\> | \<exclusion\> \<exclusion\>               ::= "notin" \<inclusion\>               ::= "in" \<value\-set\>               ::= "\(" \<values\> "\)" \<values\>                  ::= VALUE | VALUE "," \<values\> \<exact\-match\-restriction\> ::= \["="|"=="|"\!="\] VALUE

KEY is a sequence of one or more characters following \[ DNS\_SUBDOMAIN "/" \] DNS\_LABEL. Max length is 63 characters. VALUE is a sequence of zero or more characters "\(\[A\-Za\-z0\-9\_\-\\.\]\)". Max length is 63 characters. Delimiter is white space: \(' ', '\\t'\) Example of valid syntax: "x in \(foo,,baz\),y,z notin \(\)"

Note: \(1\) Inclusion \- " in " \- denotes that the KEY exists and is equal to any of the VALUEs in its requirement \(2\) Exclusion \- " notin " \- denotes that the KEY is not equal to any of the VALUEs in its requirement or does not exist \(3\) The empty string is a valid VALUE \(4\) A requirement with just a KEY \- as in "y" above \- denotes that the KEY exists and can be any VALUE. \(5\) A requirement with just \!KEY requires that the KEY not exist.

### func SelectorFromSet

```go
func SelectorFromSet(ls Set) Selector
```

SelectorFromSet returns a Selector which will match exactly the given Set. A nil and empty Sets are considered equivalent to Everything\(\). It does not perform any validation, which means the server will reject the request if the Set contains invalid values.

### func SelectorFromValidatedSet

```go
func SelectorFromValidatedSet(ls Set) Selector
```

SelectorFromValidatedSet returns a Selector which will match exactly the given Set. A nil and empty Sets are considered equivalent to Everything\(\). It assumes that Set is already validated and doesn't do any validation.

### func ValidatedSelectorFromSet

```go
func ValidatedSelectorFromSet(ls Set) (Selector, error)
```

ValidatedSelectorFromSet returns a Selector which will match exactly the given Set. A nil and empty Sets are considered equivalent to Everything\(\). The Set is validated client\-side, which allows to catch errors early.

## type Set

Set is a map of label:value. It implements Labels.

```go
type Set map[string]string
```

### func ConvertSelectorToLabelsMap

```go
func ConvertSelectorToLabelsMap(selector string, opts ...field.PathOption) (Set, error)
```

ConvertSelectorToLabelsMap converts selector string to labels map and validates keys and values

### func Merge

```go
func Merge(labels1, labels2 Set) Set
```

Merge combines given maps, and does not check for any conflicts between the maps. In case of conflicts, second map \(labels2\) wins

### func \(Set\) AsSelector

```go
func (ls Set) AsSelector() Selector
```

AsSelector converts labels into a selectors. It does not perform any validation, which means the server will reject the request if the Set contains invalid values.

### func \(Set\) AsSelectorPreValidated

```go
func (ls Set) AsSelectorPreValidated() Selector
```

AsSelectorPreValidated converts labels into a selector, but assumes that labels are already validated and thus doesn't perform any validation. According to our measurements this is significantly faster in codepaths that matter at high scale.

### func \(Set\) AsValidatedSelector

```go
func (ls Set) AsValidatedSelector() (Selector, error)
```

AsValidatedSelector converts labels into a selectors. The Set is validated client\-side, which allows to catch errors early.

### func \(Set\) Get

```go
func (ls Set) Get(label string) string
```

Get returns the value in the map for the provided label.

### func \(Set\) Has

```go
func (ls Set) Has(label string) bool
```

Has returns whether the provided label exists in the map.

### func \(Set\) String

```go
func (ls Set) String() string
```

String returns all labels listed as a human readable string. Conveniently, exactly the format that ParseSelector takes.

## type Token

Token represents constant definition for lexer token

```go
type Token int
```

```go
const (
    // ErrorToken represents scan error
    ErrorToken Token = iota
    // EndOfStringToken represents end of string
    EndOfStringToken
    // ClosedParToken represents close parenthesis
    ClosedParToken
    // CommaToken represents the comma
    CommaToken
    // DoesNotExistToken represents logic not
    DoesNotExistToken
    // DoubleEqualsToken represents double equals
    DoubleEqualsToken
    // EqualsToken represents equal
    EqualsToken
    // GreaterThanToken represents greater than
    GreaterThanToken
    // IdentifierToken represents identifier, e.g. keys and values
    IdentifierToken
    // InToken represents in
    InToken
    // LessThanToken represents less than
    LessThanToken
    // NotEqualsToken represents not equal
    NotEqualsToken
    // NotInToken represents not in
    NotInToken
    // OpenParToken represents open parenthesis
    OpenParToken
)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
