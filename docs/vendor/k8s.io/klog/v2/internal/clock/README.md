<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# clock

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/k8s.io/klog/v2/internal/clock"
```

## Index

- [type Clock](<#type-clock>)
- [type PassiveClock](<#type-passiveclock>)
- [type RealClock](<#type-realclock>)
  - [func (RealClock) After(d time.Duration) <-chan time.Time](<#func-realclock-after>)
  - [func (RealClock) AfterFunc(d time.Duration, f func()) Timer](<#func-realclock-afterfunc>)
  - [func (RealClock) NewTicker(d time.Duration) Ticker](<#func-realclock-newticker>)
  - [func (RealClock) NewTimer(d time.Duration) Timer](<#func-realclock-newtimer>)
  - [func (RealClock) Now() time.Time](<#func-realclock-now>)
  - [func (RealClock) Since(ts time.Time) time.Duration](<#func-realclock-since>)
  - [func (RealClock) Sleep(d time.Duration)](<#func-realclock-sleep>)
  - [func (RealClock) Tick(d time.Duration) <-chan time.Time](<#func-realclock-tick>)
- [type Ticker](<#type-ticker>)
- [type Timer](<#type-timer>)
- [type WithDelayedExecution](<#type-withdelayedexecution>)
- [type WithTicker](<#type-withticker>)
- [type WithTickerAndDelayedExecution](<#type-withtickeranddelayedexecution>)


## type Clock

Clock allows for injecting fake or real clocks into code that needs to do arbitrary things based on time.

```go
type Clock interface {
    PassiveClock
    // After returns the channel of a new Timer.
    // This method does not allow to free/GC the backing timer before it fires. Use
    // NewTimer instead.
    After(d time.Duration) <-chan time.Time
    // NewTimer returns a new Timer.
    NewTimer(d time.Duration) Timer
    // Sleep sleeps for the provided duration d.
    // Consider making the sleep interruptible by using 'select' on a context channel and a timer channel.
    Sleep(d time.Duration)
    // Tick returns the channel of a new Ticker.
    // This method does not allow to free/GC the backing ticker. Use
    // NewTicker from WithTicker instead.
    Tick(d time.Duration) <-chan time.Time
}
```

## type PassiveClock

PassiveClock allows for injecting fake or real clocks into code that needs to read the current time but does not support scheduling activity in the future.

```go
type PassiveClock interface {
    Now() time.Time
    Since(time.Time) time.Duration
}
```

## type RealClock

RealClock really calls time.Now\(\)

```go
type RealClock struct{}
```

### func \(RealClock\) After

```go
func (RealClock) After(d time.Duration) <-chan time.Time
```

After is the same as time.After\(d\). This method does not allow to free/GC the backing timer before it fires. Use NewTimer instead.

### func \(RealClock\) AfterFunc

```go
func (RealClock) AfterFunc(d time.Duration, f func()) Timer
```

AfterFunc is the same as time.AfterFunc\(d, f\).

### func \(RealClock\) NewTicker

```go
func (RealClock) NewTicker(d time.Duration) Ticker
```

NewTicker returns a new Ticker.

### func \(RealClock\) NewTimer

```go
func (RealClock) NewTimer(d time.Duration) Timer
```

NewTimer is the same as time.NewTimer\(d\)

### func \(RealClock\) Now

```go
func (RealClock) Now() time.Time
```

Now returns the current time.

### func \(RealClock\) Since

```go
func (RealClock) Since(ts time.Time) time.Duration
```

Since returns time since the specified timestamp.

### func \(RealClock\) Sleep

```go
func (RealClock) Sleep(d time.Duration)
```

Sleep is the same as time.Sleep\(d\) Consider making the sleep interruptible by using 'select' on a context channel and a timer channel.

### func \(RealClock\) Tick

```go
func (RealClock) Tick(d time.Duration) <-chan time.Time
```

Tick is the same as time.Tick\(d\) This method does not allow to free/GC the backing ticker. Use NewTicker instead.

## type Ticker

Ticker defines the Ticker interface.

```go
type Ticker interface {
    C() <-chan time.Time
    Stop()
}
```

## type Timer

Timer allows for injecting fake or real timers into code that needs to do arbitrary things based on time.

```go
type Timer interface {
    C() <-chan time.Time
    Stop() bool
    Reset(d time.Duration) bool
}
```

## type WithDelayedExecution

WithDelayedExecution allows for injecting fake or real clocks into code that needs to make use of AfterFunc functionality.

```go
type WithDelayedExecution interface {
    Clock
    // AfterFunc executes f in its own goroutine after waiting
    // for d duration and returns a Timer whose channel can be
    // closed by calling Stop() on the Timer.
    AfterFunc(d time.Duration, f func()) Timer
}
```

## type WithTicker

WithTicker allows for injecting fake or real clocks into code that needs to do arbitrary things based on time.

```go
type WithTicker interface {
    Clock
    // NewTicker returns a new Ticker.
    NewTicker(time.Duration) Ticker
}
```

## type WithTickerAndDelayedExecution

WithTickerAndDelayedExecution allows for injecting fake or real clocks into code that needs Ticker and AfterFunc functionality

```go
type WithTickerAndDelayedExecution interface {
    WithTicker
    // AfterFunc executes f in its own goroutine after waiting
    // for d duration and returns a Timer whose channel can be
    // closed by calling Stop() on the Timer.
    AfterFunc(d time.Duration, f func()) Timer
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
