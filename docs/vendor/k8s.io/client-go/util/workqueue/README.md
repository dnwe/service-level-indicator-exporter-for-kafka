<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# workqueue

```go
import "k8s.io/client-go/util/workqueue"
```

Package workqueue provides a simple queue that supports the following features: \* Fair: items processed in the order in which they are added. \* Stingy: a single item will not be processed multiple times concurrently, and if an item is added multiple times before it can be processed, it will only be processed once. \* Multiple consumers and producers. In particular, it is allowed for an item to be reenqueued while it is being processed. \* Shutdown notifications.

## Index

- [func ParallelizeUntil(ctx context.Context, workers, pieces int, doWorkPiece DoWorkPieceFunc, opts ...Options)](<#func-parallelizeuntil>)
- [func SetProvider(metricsProvider MetricsProvider)](<#func-setprovider>)
- [func WithChunkSize(c int) func(*options)](<#func-withchunksize>)
- [type BucketRateLimiter](<#type-bucketratelimiter>)
  - [func (r *BucketRateLimiter) Forget(item interface{})](<#func-bucketratelimiter-forget>)
  - [func (r *BucketRateLimiter) NumRequeues(item interface{}) int](<#func-bucketratelimiter-numrequeues>)
  - [func (r *BucketRateLimiter) When(item interface{}) time.Duration](<#func-bucketratelimiter-when>)
- [type CounterMetric](<#type-countermetric>)
- [type DelayingInterface](<#type-delayinginterface>)
  - [func NewDelayingQueue() DelayingInterface](<#func-newdelayingqueue>)
  - [func NewDelayingQueueWithCustomClock(clock clock.Clock, name string) DelayingInterface](<#func-newdelayingqueuewithcustomclock>)
  - [func NewDelayingQueueWithCustomQueue(q Interface, name string) DelayingInterface](<#func-newdelayingqueuewithcustomqueue>)
  - [func NewNamedDelayingQueue(name string) DelayingInterface](<#func-newnameddelayingqueue>)
- [type DoWorkPieceFunc](<#type-doworkpiecefunc>)
- [type GaugeMetric](<#type-gaugemetric>)
- [type HistogramMetric](<#type-histogrammetric>)
- [type Interface](<#type-interface>)
- [type ItemExponentialFailureRateLimiter](<#type-itemexponentialfailureratelimiter>)
  - [func (r *ItemExponentialFailureRateLimiter) Forget(item interface{})](<#func-itemexponentialfailureratelimiter-forget>)
  - [func (r *ItemExponentialFailureRateLimiter) NumRequeues(item interface{}) int](<#func-itemexponentialfailureratelimiter-numrequeues>)
  - [func (r *ItemExponentialFailureRateLimiter) When(item interface{}) time.Duration](<#func-itemexponentialfailureratelimiter-when>)
- [type ItemFastSlowRateLimiter](<#type-itemfastslowratelimiter>)
  - [func (r *ItemFastSlowRateLimiter) Forget(item interface{})](<#func-itemfastslowratelimiter-forget>)
  - [func (r *ItemFastSlowRateLimiter) NumRequeues(item interface{}) int](<#func-itemfastslowratelimiter-numrequeues>)
  - [func (r *ItemFastSlowRateLimiter) When(item interface{}) time.Duration](<#func-itemfastslowratelimiter-when>)
- [type MaxOfRateLimiter](<#type-maxofratelimiter>)
  - [func (r *MaxOfRateLimiter) Forget(item interface{})](<#func-maxofratelimiter-forget>)
  - [func (r *MaxOfRateLimiter) NumRequeues(item interface{}) int](<#func-maxofratelimiter-numrequeues>)
  - [func (r *MaxOfRateLimiter) When(item interface{}) time.Duration](<#func-maxofratelimiter-when>)
- [type MetricsProvider](<#type-metricsprovider>)
- [type Options](<#type-options>)
- [type RateLimiter](<#type-ratelimiter>)
  - [func DefaultControllerRateLimiter() RateLimiter](<#func-defaultcontrollerratelimiter>)
  - [func DefaultItemBasedRateLimiter() RateLimiter](<#func-defaultitembasedratelimiter>)
  - [func NewItemExponentialFailureRateLimiter(baseDelay time.Duration, maxDelay time.Duration) RateLimiter](<#func-newitemexponentialfailureratelimiter>)
  - [func NewItemFastSlowRateLimiter(fastDelay, slowDelay time.Duration, maxFastAttempts int) RateLimiter](<#func-newitemfastslowratelimiter>)
  - [func NewMaxOfRateLimiter(limiters ...RateLimiter) RateLimiter](<#func-newmaxofratelimiter>)
- [type RateLimitingInterface](<#type-ratelimitinginterface>)
  - [func NewNamedRateLimitingQueue(rateLimiter RateLimiter, name string) RateLimitingInterface](<#func-newnamedratelimitingqueue>)
  - [func NewRateLimitingQueue(rateLimiter RateLimiter) RateLimitingInterface](<#func-newratelimitingqueue>)
- [type SettableGaugeMetric](<#type-settablegaugemetric>)
- [type SummaryMetric](<#type-summarymetric>)
- [type Type](<#type-type>)
  - [func New() *Type](<#func-new>)
  - [func NewNamed(name string) *Type](<#func-newnamed>)
  - [func (q *Type) Add(item interface{})](<#func-type-add>)
  - [func (q *Type) Done(item interface{})](<#func-type-done>)
  - [func (q *Type) Get() (item interface{}, shutdown bool)](<#func-type-get>)
  - [func (q *Type) Len() int](<#func-type-len>)
  - [func (q *Type) ShutDown()](<#func-type-shutdown>)
  - [func (q *Type) ShuttingDown() bool](<#func-type-shuttingdown>)


## func ParallelizeUntil

```go
func ParallelizeUntil(ctx context.Context, workers, pieces int, doWorkPiece DoWorkPieceFunc, opts ...Options)
```

ParallelizeUntil is a framework that allows for parallelizing N independent pieces of work until done or the context is canceled.

## func SetProvider

```go
func SetProvider(metricsProvider MetricsProvider)
```

SetProvider sets the metrics provider for all subsequently created work queues. Only the first call has an effect.

## func WithChunkSize

```go
func WithChunkSize(c int) func(*options)
```

WithChunkSize allows to set chunks of work items to the workers, rather than processing one by one. It is recommended to use this option if the number of pieces significantly higher than the number of workers and the work done for each item is small.

## type BucketRateLimiter

BucketRateLimiter adapts a standard bucket to the workqueue ratelimiter API

```go
type BucketRateLimiter struct {
    *rate.Limiter
}
```

### func \(\*BucketRateLimiter\) Forget

```go
func (r *BucketRateLimiter) Forget(item interface{})
```

### func \(\*BucketRateLimiter\) NumRequeues

```go
func (r *BucketRateLimiter) NumRequeues(item interface{}) int
```

### func \(\*BucketRateLimiter\) When

```go
func (r *BucketRateLimiter) When(item interface{}) time.Duration
```

## type CounterMetric

CounterMetric represents a single numerical value that only ever goes up.

```go
type CounterMetric interface {
    Inc()
}
```

## type DelayingInterface

DelayingInterface is an Interface that can Add an item at a later time. This makes it easier to requeue items after failures without ending up in a hot\-loop.

```go
type DelayingInterface interface {
    Interface
    // AddAfter adds an item to the workqueue after the indicated duration has passed
    AddAfter(item interface{}, duration time.Duration)
}
```

### func NewDelayingQueue

```go
func NewDelayingQueue() DelayingInterface
```

NewDelayingQueue constructs a new workqueue with delayed queuing ability

### func NewDelayingQueueWithCustomClock

```go
func NewDelayingQueueWithCustomClock(clock clock.Clock, name string) DelayingInterface
```

NewDelayingQueueWithCustomClock constructs a new named workqueue with ability to inject real or fake clock for testing purposes

### func NewDelayingQueueWithCustomQueue

```go
func NewDelayingQueueWithCustomQueue(q Interface, name string) DelayingInterface
```

NewDelayingQueueWithCustomQueue constructs a new workqueue with ability to inject custom queue Interface instead of the default one

### func NewNamedDelayingQueue

```go
func NewNamedDelayingQueue(name string) DelayingInterface
```

NewNamedDelayingQueue constructs a new named workqueue with delayed queuing ability

## type DoWorkPieceFunc

```go
type DoWorkPieceFunc func(piece int)
```

## type GaugeMetric

GaugeMetric represents a single numerical value that can arbitrarily go up and down.

```go
type GaugeMetric interface {
    Inc()
    Dec()
}
```

## type HistogramMetric

HistogramMetric counts individual observations.

```go
type HistogramMetric interface {
    Observe(float64)
}
```

## type Interface

```go
type Interface interface {
    Add(item interface{})
    Len() int
    Get() (item interface{}, shutdown bool)
    Done(item interface{})
    ShutDown()
    ShuttingDown() bool
}
```

## type ItemExponentialFailureRateLimiter

ItemExponentialFailureRateLimiter does a simple baseDelay\*2^\<num\-failures\> limit dealing with max failures and expiration are up to the caller

```go
type ItemExponentialFailureRateLimiter struct {
    // contains filtered or unexported fields
}
```

### func \(\*ItemExponentialFailureRateLimiter\) Forget

```go
func (r *ItemExponentialFailureRateLimiter) Forget(item interface{})
```

### func \(\*ItemExponentialFailureRateLimiter\) NumRequeues

```go
func (r *ItemExponentialFailureRateLimiter) NumRequeues(item interface{}) int
```

### func \(\*ItemExponentialFailureRateLimiter\) When

```go
func (r *ItemExponentialFailureRateLimiter) When(item interface{}) time.Duration
```

## type ItemFastSlowRateLimiter

ItemFastSlowRateLimiter does a quick retry for a certain number of attempts, then a slow retry after that

```go
type ItemFastSlowRateLimiter struct {
    // contains filtered or unexported fields
}
```

### func \(\*ItemFastSlowRateLimiter\) Forget

```go
func (r *ItemFastSlowRateLimiter) Forget(item interface{})
```

### func \(\*ItemFastSlowRateLimiter\) NumRequeues

```go
func (r *ItemFastSlowRateLimiter) NumRequeues(item interface{}) int
```

### func \(\*ItemFastSlowRateLimiter\) When

```go
func (r *ItemFastSlowRateLimiter) When(item interface{}) time.Duration
```

## type MaxOfRateLimiter

MaxOfRateLimiter calls every RateLimiter and returns the worst case response When used with a token bucket limiter, the burst could be apparently exceeded in cases where particular items were separately delayed a longer time.

```go
type MaxOfRateLimiter struct {
    // contains filtered or unexported fields
}
```

### func \(\*MaxOfRateLimiter\) Forget

```go
func (r *MaxOfRateLimiter) Forget(item interface{})
```

### func \(\*MaxOfRateLimiter\) NumRequeues

```go
func (r *MaxOfRateLimiter) NumRequeues(item interface{}) int
```

### func \(\*MaxOfRateLimiter\) When

```go
func (r *MaxOfRateLimiter) When(item interface{}) time.Duration
```

## type MetricsProvider

MetricsProvider generates various metrics used by the queue.

```go
type MetricsProvider interface {
    NewDepthMetric(name string) GaugeMetric
    NewAddsMetric(name string) CounterMetric
    NewLatencyMetric(name string) HistogramMetric
    NewWorkDurationMetric(name string) HistogramMetric
    NewUnfinishedWorkSecondsMetric(name string) SettableGaugeMetric
    NewLongestRunningProcessorSecondsMetric(name string) SettableGaugeMetric
    NewRetriesMetric(name string) CounterMetric
}
```

## type Options

```go
type Options func(*options)
```

## type RateLimiter

```go
type RateLimiter interface {
    // When gets an item and gets to decide how long that item should wait
    When(item interface{}) time.Duration
    // Forget indicates that an item is finished being retried.  Doesn't matter whether its for perm failing
    // or for success, we'll stop tracking it
    Forget(item interface{})
    // NumRequeues returns back how many failures the item has had
    NumRequeues(item interface{}) int
}
```

### func DefaultControllerRateLimiter

```go
func DefaultControllerRateLimiter() RateLimiter
```

DefaultControllerRateLimiter is a no\-arg constructor for a default rate limiter for a workqueue.  It has both overall and per\-item rate limiting.  The overall is a token bucket and the per\-item is exponential

### func DefaultItemBasedRateLimiter

```go
func DefaultItemBasedRateLimiter() RateLimiter
```

### func NewItemExponentialFailureRateLimiter

```go
func NewItemExponentialFailureRateLimiter(baseDelay time.Duration, maxDelay time.Duration) RateLimiter
```

### func NewItemFastSlowRateLimiter

```go
func NewItemFastSlowRateLimiter(fastDelay, slowDelay time.Duration, maxFastAttempts int) RateLimiter
```

### func NewMaxOfRateLimiter

```go
func NewMaxOfRateLimiter(limiters ...RateLimiter) RateLimiter
```

## type RateLimitingInterface

RateLimitingInterface is an interface that rate limits items being added to the queue.

```go
type RateLimitingInterface interface {
    DelayingInterface

    // AddRateLimited adds an item to the workqueue after the rate limiter says it's ok
    AddRateLimited(item interface{})

    // Forget indicates that an item is finished being retried.  Doesn't matter whether it's for perm failing
    // or for success, we'll stop the rate limiter from tracking it.  This only clears the `rateLimiter`, you
    // still have to call `Done` on the queue.
    Forget(item interface{})

    // NumRequeues returns back how many times the item was requeued
    NumRequeues(item interface{}) int
}
```

### func NewNamedRateLimitingQueue

```go
func NewNamedRateLimitingQueue(rateLimiter RateLimiter, name string) RateLimitingInterface
```

### func NewRateLimitingQueue

```go
func NewRateLimitingQueue(rateLimiter RateLimiter) RateLimitingInterface
```

NewRateLimitingQueue constructs a new workqueue with rateLimited queuing ability Remember to call Forget\!  If you don't, you may end up tracking failures forever.

## type SettableGaugeMetric

SettableGaugeMetric represents a single numerical value that can arbitrarily go up and down. \(Separate from GaugeMetric to preserve backwards compatibility.\)

```go
type SettableGaugeMetric interface {
    Set(float64)
}
```

## type SummaryMetric

SummaryMetric captures individual observations.

```go
type SummaryMetric interface {
    Observe(float64)
}
```

## type Type

Type is a work queue \(see the package comment\).

```go
type Type struct {
    // contains filtered or unexported fields
}
```

### func New

```go
func New() *Type
```

New constructs a new work queue \(see the package comment\).

### func NewNamed

```go
func NewNamed(name string) *Type
```

### func \(\*Type\) Add

```go
func (q *Type) Add(item interface{})
```

Add marks item as needing processing.

### func \(\*Type\) Done

```go
func (q *Type) Done(item interface{})
```

Done marks item as done processing, and if it has been marked as dirty again while it was being processed, it will be re\-added to the queue for re\-processing.

### func \(\*Type\) Get

```go
func (q *Type) Get() (item interface{}, shutdown bool)
```

Get blocks until it can return an item to be processed. If shutdown = true, the caller should end their goroutine. You must call Done with item when you have finished processing it.

### func \(\*Type\) Len

```go
func (q *Type) Len() int
```

Len returns the current queue length, for informational purposes only. You shouldn't e.g. gate a call to Add\(\) or Get\(\) on Len\(\) being a particular value, that can't be synchronized properly.

### func \(\*Type\) ShutDown

```go
func (q *Type) ShutDown()
```

ShutDown will cause q to ignore all new items added to it. As soon as the worker goroutines have drained the existing items in the queue, they will be instructed to exit.

### func \(\*Type\) ShuttingDown

```go
func (q *Type) ShuttingDown() bool
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
