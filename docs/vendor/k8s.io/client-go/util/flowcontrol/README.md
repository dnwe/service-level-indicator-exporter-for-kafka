<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# flowcontrol

```go
import "github.com/vmware/service-level-indicator-exporter-for-kafka/vendor/k8s.io/client-go/util/flowcontrol"
```

## Index

- [type Backoff](<#type-backoff>)
  - [func NewBackOff(initial, max time.Duration) *Backoff](<#func-newbackoff>)
  - [func NewFakeBackOff(initial, max time.Duration, tc *clock.FakeClock) *Backoff](<#func-newfakebackoff>)
  - [func (p *Backoff) DeleteEntry(id string)](<#func-backoff-deleteentry>)
  - [func (p *Backoff) GC()](<#func-backoff-gc>)
  - [func (p *Backoff) Get(id string) time.Duration](<#func-backoff-get>)
  - [func (p *Backoff) IsInBackOffSince(id string, eventTime time.Time) bool](<#func-backoff-isinbackoffsince>)
  - [func (p *Backoff) IsInBackOffSinceUpdate(id string, eventTime time.Time) bool](<#func-backoff-isinbackoffsinceupdate>)
  - [func (p *Backoff) Next(id string, eventTime time.Time)](<#func-backoff-next>)
  - [func (p *Backoff) Reset(id string)](<#func-backoff-reset>)
- [type Clock](<#type-clock>)
- [type RateLimiter](<#type-ratelimiter>)
  - [func NewFakeAlwaysRateLimiter() RateLimiter](<#func-newfakealwaysratelimiter>)
  - [func NewFakeNeverRateLimiter() RateLimiter](<#func-newfakeneverratelimiter>)
  - [func NewTokenBucketRateLimiter(qps float32, burst int) RateLimiter](<#func-newtokenbucketratelimiter>)
  - [func NewTokenBucketRateLimiterWithClock(qps float32, burst int, c Clock) RateLimiter](<#func-newtokenbucketratelimiterwithclock>)


## type Backoff

```go
type Backoff struct {
    sync.RWMutex
    Clock clock.Clock
    // contains filtered or unexported fields
}
```

### func NewBackOff

```go
func NewBackOff(initial, max time.Duration) *Backoff
```

### func NewFakeBackOff

```go
func NewFakeBackOff(initial, max time.Duration, tc *clock.FakeClock) *Backoff
```

### func \(\*Backoff\) DeleteEntry

```go
func (p *Backoff) DeleteEntry(id string)
```

### func \(\*Backoff\) GC

```go
func (p *Backoff) GC()
```

Garbage collect records that have aged past maxDuration. Backoff users are expected to invoke this periodically.

### func \(\*Backoff\) Get

```go
func (p *Backoff) Get(id string) time.Duration
```

Get the current backoff Duration

### func \(\*Backoff\) IsInBackOffSince

```go
func (p *Backoff) IsInBackOffSince(id string, eventTime time.Time) bool
```

Returns True if the elapsed time since eventTime is smaller than the current backoff window

### func \(\*Backoff\) IsInBackOffSinceUpdate

```go
func (p *Backoff) IsInBackOffSinceUpdate(id string, eventTime time.Time) bool
```

Returns True if time since lastupdate is less than the current backoff window.

### func \(\*Backoff\) Next

```go
func (p *Backoff) Next(id string, eventTime time.Time)
```

move backoff to the next mark, capping at maxDuration

### func \(\*Backoff\) Reset

```go
func (p *Backoff) Reset(id string)
```

Reset forces clearing of all backoff data for a given key.

## type Clock

An injectable, mockable clock interface.

```go
type Clock interface {
    Now() time.Time
    Sleep(time.Duration)
}
```

## type RateLimiter

```go
type RateLimiter interface {
    // TryAccept returns true if a token is taken immediately. Otherwise,
    // it returns false.
    TryAccept() bool
    // Accept returns once a token becomes available.
    Accept()
    // Stop stops the rate limiter, subsequent calls to CanAccept will return false
    Stop()
    // QPS returns QPS of this rate limiter
    QPS() float32
    // Wait returns nil if a token is taken before the Context is done.
    Wait(ctx context.Context) error
}
```

### func NewFakeAlwaysRateLimiter

```go
func NewFakeAlwaysRateLimiter() RateLimiter
```

### func NewFakeNeverRateLimiter

```go
func NewFakeNeverRateLimiter() RateLimiter
```

### func NewTokenBucketRateLimiter

```go
func NewTokenBucketRateLimiter(qps float32, burst int) RateLimiter
```

NewTokenBucketRateLimiter creates a rate limiter which implements a token bucket approach. The rate limiter allows bursts of up to 'burst' to exceed the QPS, while still maintaining a smoothed qps rate of 'qps'. The bucket is initially filled with 'burst' tokens, and refills at a rate of 'qps'. The maximum number of tokens in the bucket is capped at 'burst'.

### func NewTokenBucketRateLimiterWithClock

```go
func NewTokenBucketRateLimiterWithClock(qps float32, burst int, c Clock) RateLimiter
```

NewTokenBucketRateLimiterWithClock is identical to NewTokenBucketRateLimiter but allows an injectable clock, for testing.



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
